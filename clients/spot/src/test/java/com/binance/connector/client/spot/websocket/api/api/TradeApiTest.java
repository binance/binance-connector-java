/*
 * Binance Public Spot WebSocket API
 * OpenAPI Specifications for the Binance Public Spot WebSocket API  API documents:   - [Github web-socket-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-api.md)   - [General API information for web-socket-api on website](https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/general-api-information)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.spot.websocket.api.api;

import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.websocket.adapter.ConnectionWrapper;
import com.binance.connector.client.common.websocket.configuration.SessionMode;
import com.binance.connector.client.common.websocket.configuration.WebSocketClientConfiguration;
import com.binance.connector.client.common.websocket.dtos.RequestWrapperDTO;
import com.binance.connector.client.spot.websocket.api.model.AboveType;
import com.binance.connector.client.spot.websocket.api.model.BelowType;
import com.binance.connector.client.spot.websocket.api.model.CancelReplaceMode;
import com.binance.connector.client.spot.websocket.api.model.OpenOrderListsStatusRequest;
import com.binance.connector.client.spot.websocket.api.model.OpenOrderListsStatusResponse;
import com.binance.connector.client.spot.websocket.api.model.OpenOrdersCancelAllRequest;
import com.binance.connector.client.spot.websocket.api.model.OpenOrdersCancelAllResponse;
import com.binance.connector.client.spot.websocket.api.model.OpenOrdersStatusRequest;
import com.binance.connector.client.spot.websocket.api.model.OpenOrdersStatusResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderCancelReplaceRequest;
import com.binance.connector.client.spot.websocket.api.model.OrderCancelReplaceResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderCancelRequest;
import com.binance.connector.client.spot.websocket.api.model.OrderCancelResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderListCancelRequest;
import com.binance.connector.client.spot.websocket.api.model.OrderListCancelResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderListPlaceOcoRequest;
import com.binance.connector.client.spot.websocket.api.model.OrderListPlaceOcoResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderListPlaceOtoRequest;
import com.binance.connector.client.spot.websocket.api.model.OrderListPlaceOtoResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderListPlaceOtocoRequest;
import com.binance.connector.client.spot.websocket.api.model.OrderListPlaceOtocoResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderListPlaceRequest;
import com.binance.connector.client.spot.websocket.api.model.OrderListPlaceResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderListStatusRequest;
import com.binance.connector.client.spot.websocket.api.model.OrderListStatusResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderPlaceRequest;
import com.binance.connector.client.spot.websocket.api.model.OrderPlaceResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderStatusRequest;
import com.binance.connector.client.spot.websocket.api.model.OrderStatusResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderTestRequest;
import com.binance.connector.client.spot.websocket.api.model.OrderTestResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderType;
import com.binance.connector.client.spot.websocket.api.model.PendingAboveType;
import com.binance.connector.client.spot.websocket.api.model.PendingSide;
import com.binance.connector.client.spot.websocket.api.model.PendingType;
import com.binance.connector.client.spot.websocket.api.model.Side;
import com.binance.connector.client.spot.websocket.api.model.SorOrderPlaceRequest;
import com.binance.connector.client.spot.websocket.api.model.SorOrderPlaceResponse;
import com.binance.connector.client.spot.websocket.api.model.SorOrderTestRequest;
import com.binance.connector.client.spot.websocket.api.model.SorOrderTestResponse;
import com.binance.connector.client.spot.websocket.api.model.WorkingSide;
import com.binance.connector.client.spot.websocket.api.model.WorkingType;
import java.io.File;
import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.concurrent.CompletableFuture;

import org.eclipse.jetty.websocket.api.RemoteEndpoint;
import org.eclipse.jetty.websocket.api.Session;
import org.eclipse.jetty.websocket.client.WebSocketClient;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;
import org.skyscreamer.jsonassert.JSONAssert;

/** API tests for TradeApi */
public class TradeApiTest {

    private TradeApi api;
    private ConnectionWrapper connectionSpy;
    private Session sessionMock;

    @BeforeEach
    public void initApiClient() throws Exception {
        URL resource = TradeApi.class.getResource("/test-ed25519-prv-key.pem");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        File file = new File(resource.toURI());
        signatureConfiguration.setPrivateKey(file.getAbsolutePath());
        WebSocketClientConfiguration clientConfiguration = new WebSocketClientConfiguration();
        // @TODO: run tests for LOGON as well
        clientConfiguration.setAutoLogon(false);
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);
        clientConfiguration.setUrl("wss://localhost:8080");

        WebSocketClient webSocketClient = Mockito.mock(WebSocketClient.class);
        CompletableFuture<Session> sessionCompletableFuture = new CompletableFuture<>();
        Mockito.doReturn(sessionCompletableFuture)
                .when(webSocketClient)
                .connect(Mockito.any(), Mockito.any(), Mockito.any());
        sessionMock = Mockito.mock(Session.class);

        RemoteEndpoint remoteEndpointMock = Mockito.mock(RemoteEndpoint.class);
        Mockito.doReturn(remoteEndpointMock).when(sessionMock).getRemote();

        sessionCompletableFuture.complete(sessionMock);
        ConnectionWrapper connectionWrapper =
                new ConnectionWrapper(clientConfiguration, webSocketClient);
        connectionSpy = Mockito.spy(connectionWrapper);
        Mockito.doReturn(1736393892000L).when(connectionSpy).getTimestamp();
        connectionSpy.connect();
        TradeApi accountApi = new TradeApi(connectionSpy);
        api = Mockito.spy(accountApi);
        Mockito.doReturn("eaf3292c-64b6-4c04-ad4f-4ca2608b42b4").when(api).getRequestID();
    }

    /**
     * WebSocket Current open Order lists
     *
     * <p>Query execution status of all open order lists. If you need to continuously monitor order
     * status updates, please consider using WebSocket Streams: * &#x60;userDataStream.start&#x60;
     * request * &#x60;executionReport&#x60; user data stream event Weight: 6
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void openOrderListsStatusTest() throws ApiException, URISyntaxException, IOException {
        OpenOrderListsStatusRequest openOrderListsStatusRequest = new OpenOrderListsStatusRequest();
        CompletableFuture<OpenOrderListsStatusResponse> response =
                api.openOrderListsStatus(openOrderListsStatusRequest);
        ArgumentCaptor<RequestWrapperDTO<OpenOrderListsStatusRequest, OpenOrderListsStatusResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<OpenOrderListsStatusRequest, OpenOrderListsStatusResponse>
                requestWrapperDTO = callArgumentCaptor.getValue();
        OpenOrderListsStatusRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                TradeApiTest.class.getResource(
                        "/expected/api/TradeApi/openOrderLists.status-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Cancel open orders
     *
     * <p>Cancel all open orders on a symbol. This includes orders that are part of an order list.
     * Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void openOrdersCancelAllTest() throws ApiException, URISyntaxException, IOException {
        OpenOrdersCancelAllRequest openOrdersCancelAllRequest = new OpenOrdersCancelAllRequest();
        openOrdersCancelAllRequest.setSymbol("BTCUSDT");
        CompletableFuture<OpenOrdersCancelAllResponse> response =
                api.openOrdersCancelAll(openOrdersCancelAllRequest);
        ArgumentCaptor<RequestWrapperDTO<OpenOrdersCancelAllRequest, OpenOrdersCancelAllResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<OpenOrdersCancelAllRequest, OpenOrdersCancelAllResponse>
                requestWrapperDTO = callArgumentCaptor.getValue();
        OpenOrdersCancelAllRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                TradeApiTest.class.getResource(
                        "/expected/api/TradeApi/openOrders.cancelAll-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Current open orders
     *
     * <p>Query execution status of all open orders. If you need to continuously monitor order
     * status updates, please consider using WebSocket Streams: * &#x60;userDataStream.start&#x60;
     * request * &#x60;executionReport&#x60; user data stream event Weight: Adjusted based on the
     * number of requested symbols: | Parameter | Weight | | --------- | ------ | |
     * &#x60;symbol&#x60; | 6 | | none | 80 |
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void openOrdersStatusTest() throws ApiException, URISyntaxException, IOException {
        OpenOrdersStatusRequest openOrdersStatusRequest = new OpenOrdersStatusRequest();
        CompletableFuture<OpenOrdersStatusResponse> response =
                api.openOrdersStatus(openOrdersStatusRequest);
        ArgumentCaptor<RequestWrapperDTO<OpenOrdersStatusRequest, OpenOrdersStatusResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<OpenOrdersStatusRequest, OpenOrdersStatusResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        OpenOrdersStatusRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                TradeApiTest.class.getResource(
                        "/expected/api/TradeApi/openOrders.status-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Cancel order
     *
     * <p>Cancel an active order. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void orderCancelTest() throws ApiException, URISyntaxException, IOException {
        OrderCancelRequest orderCancelRequest = new OrderCancelRequest();
        orderCancelRequest.setSymbol("BTCUSDT");
        CompletableFuture<OrderCancelResponse> response = api.orderCancel(orderCancelRequest);
        ArgumentCaptor<RequestWrapperDTO<OrderCancelRequest, OrderCancelResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<OrderCancelRequest, OrderCancelResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        OrderCancelRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                TradeApiTest.class.getResource("/expected/api/TradeApi/order.cancel-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Cancel and replace order
     *
     * <p>Cancel an existing order and immediately place a new order instead of the canceled one.
     * Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void orderCancelReplaceTest() throws ApiException, URISyntaxException, IOException {
        OrderCancelReplaceRequest orderCancelReplaceRequest = new OrderCancelReplaceRequest();
        orderCancelReplaceRequest
                .cancelReplaceMode(CancelReplaceMode.STOP_ON_FAILURE)
                .symbol("BTCUSDT")
                .type(OrderType.LIMIT)
                .side(Side.BUY);
        CompletableFuture<OrderCancelReplaceResponse> response =
                api.orderCancelReplace(orderCancelReplaceRequest);
        ArgumentCaptor<RequestWrapperDTO<OrderCancelReplaceRequest, OrderCancelReplaceResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<OrderCancelReplaceRequest, OrderCancelReplaceResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        OrderCancelReplaceRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                TradeApiTest.class.getResource(
                        "/expected/api/TradeApi/order.cancelReplace-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Cancel Order list
     *
     * <p>Cancel an active order list. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void orderListCancelTest() throws ApiException, URISyntaxException, IOException {
        OrderListCancelRequest orderListCancelRequest = new OrderListCancelRequest();
        orderListCancelRequest.setSymbol("BTCUSDT");
        CompletableFuture<OrderListCancelResponse> response =
                api.orderListCancel(orderListCancelRequest);
        ArgumentCaptor<RequestWrapperDTO<OrderListCancelRequest, OrderListCancelResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<OrderListCancelRequest, OrderListCancelResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        OrderListCancelRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                TradeApiTest.class.getResource("/expected/api/TradeApi/orderList.cancel-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Place new OCO - Deprecated
     *
     * <p>Send in a new one-cancels-the-other (OCO) pair: &#x60;LIMIT_MAKER&#x60; +
     * &#x60;STOP_LOSS&#x60;/&#x60;STOP_LOSS_LIMIT&#x60; orders (called *legs*), where activation of
     * one order immediately cancels the other. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void orderListPlaceTest() throws ApiException, URISyntaxException, IOException {
        OrderListPlaceRequest orderListPlaceRequest = new OrderListPlaceRequest();
        orderListPlaceRequest.side(Side.BUY).symbol("BTCUSDT").quantity(0.00).price(0.00);
        CompletableFuture<OrderListPlaceResponse> response =
                api.orderListPlace(orderListPlaceRequest);
        ArgumentCaptor<RequestWrapperDTO<OrderListPlaceRequest, OrderListPlaceResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<OrderListPlaceRequest, OrderListPlaceResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        OrderListPlaceRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                TradeApiTest.class.getResource("/expected/api/TradeApi/orderList.place-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Place new Order list - OCO
     *
     * <p>Send in an one-cancels the other (OCO) pair, where activation of one order immediately
     * cancels the other. * An OCO has 2 orders called the **above order** and **below order**. *
     * One of the orders must be a &#x60;LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT&#x60; order and
     * the other must be &#x60;STOP_LOSS&#x60; or &#x60;STOP_LOSS_LIMIT&#x60; order. * Price
     * restrictions: * If the OCO is on the &#x60;SELL&#x60; side: *
     * &#x60;LIMIT_MAKER/TAKE_PROFIT_LIMIT&#x60; &#x60;price&#x60; &gt; Last Traded Price &gt;
     * &#x60;STOP_LOSS/STOP_LOSS_LIMIT&#x60; &#x60;stopPrice&#x60; * &#x60;TAKE_PROFIT
     * stopPrice&#x60; &gt; Last Traded Price &gt; &#x60;STOP_LOSS/STOP_LOSS_LIMIT stopPrice&#x60; *
     * If the OCO is on the &#x60;BUY&#x60; side: * &#x60;LIMIT_MAKER&#x60; &#x60;price&#x60; &lt;
     * Last Traded Price &lt; &#x60;STOP_LOSS/STOP_LOSS_LIMIT&#x60; &#x60;stopPrice&#x60; *
     * &#x60;TAKE_PROFIT stopPrice&#x60; &gt; Last Traded Price &gt; &#x60;STOP_LOSS/STOP_LOSS_LIMIT
     * stopPrice&#x60; * OCOs add **2 orders** to the unfilled order count,
     * &#x60;EXCHANGE_MAX_ORDERS&#x60; filter, and &#x60;MAX_NUM_ORDERS&#x60; filter. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void orderListPlaceOcoTest() throws ApiException, URISyntaxException, IOException {
        OrderListPlaceOcoRequest orderListPlaceOcoRequest = new OrderListPlaceOcoRequest();
        orderListPlaceOcoRequest
                .aboveType(AboveType.STOP_LOSS)
                .belowPrice(0.00)
                .belowType(BelowType.TAKE_PROFIT)
                .symbol("BTCUSDT")
                .side(Side.BUY)
                .quantity(0.00);
        CompletableFuture<OrderListPlaceOcoResponse> response =
                api.orderListPlaceOco(orderListPlaceOcoRequest);
        ArgumentCaptor<RequestWrapperDTO<OrderListPlaceOcoRequest, OrderListPlaceOcoResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<OrderListPlaceOcoRequest, OrderListPlaceOcoResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        OrderListPlaceOcoRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                TradeApiTest.class.getResource(
                        "/expected/api/TradeApi/orderList.place.oco-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Place new Order list - OTO
     *
     * <p>Places an OTO. * An OTO (One-Triggers-the-Other) is an order list comprised of 2 orders. *
     * The first order is called the **working order** and must be &#x60;LIMIT&#x60; or
     * &#x60;LIMIT_MAKER&#x60;. Initially, only the working order goes on the order book. * The
     * second order is called the **pending order**. It can be any order type except for
     * &#x60;MARKET&#x60; orders using parameter &#x60;quoteOrderQty&#x60;. The pending order is
     * only placed on the order book when the working order gets **fully filled**. * If either the
     * working order or the pending order is cancelled individually, the other order in the order
     * list will also be canceled or expired. * OTOs add **2 orders** to the unfilled order count,
     * &#x60;EXCHANGE_MAX_NUM_ORDERS&#x60; filter and &#x60;MAX_NUM_ORDERS&#x60; filter. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void orderListPlaceOtoTest() throws ApiException, URISyntaxException, IOException {
        OrderListPlaceOtoRequest orderListPlaceOtoRequest = new OrderListPlaceOtoRequest();
        orderListPlaceOtoRequest
                .pendingQuantity(0.00)
                .workingType(WorkingType.LIMIT)
                .pendingType(PendingType.MARKET)
                .pendingSide(PendingSide.BUY)
                .workingSide(WorkingSide.BUY)
                .symbol("BTCUSDT")
                .workingQuantity(0.00)
                .workingPrice(0.00);
        CompletableFuture<OrderListPlaceOtoResponse> response =
                api.orderListPlaceOto(orderListPlaceOtoRequest);
        ArgumentCaptor<RequestWrapperDTO<OrderListPlaceOtoRequest, OrderListPlaceOtoResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<OrderListPlaceOtoRequest, OrderListPlaceOtoResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        OrderListPlaceOtoRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                TradeApiTest.class.getResource(
                        "/expected/api/TradeApi/orderList.place.oto-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Place new Order list - OTOCO
     *
     * <p>Place an OTOCO. * An OTOCO (One-Triggers-One-Cancels-the-Other) is an order list comprised
     * of 3 orders. * The first order is called the **working order** and must be &#x60;LIMIT&#x60;
     * or &#x60;LIMIT_MAKER&#x60;. Initially, only the working order goes on the order book. * The
     * behavior of the working order is the same as the [OTO](#place-new-order-list---oto-trade). *
     * OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The
     * pending orders are only placed on the order book when the working order gets **fully
     * filled**. * OTOCOs add **3 orders** to the unfilled order count,
     * &#x60;EXCHANGE_MAX_NUM_ORDERS&#x60; filter, and &#x60;MAX_NUM_ORDERS&#x60; filter. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void orderListPlaceOtocoTest() throws ApiException, URISyntaxException, IOException {
        OrderListPlaceOtocoRequest orderListPlaceOtocoRequest = new OrderListPlaceOtocoRequest();
        orderListPlaceOtocoRequest
                .pendingAboveType(PendingAboveType.LIMIT_MAKER)
                .pendingQuantity(0.00)
                .pendingSide(PendingSide.BUY)
                .symbol("BTCUSDT")
                .workingType(WorkingType.LIMIT)
                .workingQuantity(0.00)
                .workingSide(WorkingSide.BUY)
                .workingPrice(0.00);
        CompletableFuture<OrderListPlaceOtocoResponse> response =
                api.orderListPlaceOtoco(orderListPlaceOtocoRequest);
        ArgumentCaptor<RequestWrapperDTO<OrderListPlaceOtocoRequest, OrderListPlaceOtocoResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<OrderListPlaceOtocoRequest, OrderListPlaceOtocoResponse>
                requestWrapperDTO = callArgumentCaptor.getValue();
        OrderListPlaceOtocoRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                TradeApiTest.class.getResource(
                        "/expected/api/TradeApi/orderList.place.otoco-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Query Order list
     *
     * <p>Check execution status of an Order list. For execution status of individual orders, use
     * &#x60;order.status&#x60;. Weight: 4
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void orderListStatusTest() throws ApiException, URISyntaxException, IOException {
        OrderListStatusRequest orderListStatusRequest = new OrderListStatusRequest();
        CompletableFuture<OrderListStatusResponse> response =
                api.orderListStatus(orderListStatusRequest);
        ArgumentCaptor<RequestWrapperDTO<OrderListStatusRequest, OrderListStatusResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<OrderListStatusRequest, OrderListStatusResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        OrderListStatusRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                TradeApiTest.class.getResource("/expected/api/TradeApi/orderList.status-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Place new order
     *
     * <p>Send in a new order. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void orderPlaceTest() throws ApiException, URISyntaxException, IOException {
        OrderPlaceRequest orderPlaceRequest = new OrderPlaceRequest();
        orderPlaceRequest.side(Side.BUY).type(OrderType.LIMIT).symbol("BTCUSDT");
        CompletableFuture<OrderPlaceResponse> response = api.orderPlace(orderPlaceRequest);
        ArgumentCaptor<RequestWrapperDTO<OrderPlaceRequest, OrderPlaceResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<OrderPlaceRequest, OrderPlaceResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        OrderPlaceRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                TradeApiTest.class.getResource("/expected/api/TradeApi/order.place-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Query order
     *
     * <p>Check execution status of an order. Weight: 4
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void orderStatusTest() throws ApiException, URISyntaxException, IOException {
        OrderStatusRequest orderStatusRequest = new OrderStatusRequest();
        orderStatusRequest.setSymbol("BTCUSDT");
        CompletableFuture<OrderStatusResponse> response = api.orderStatus(orderStatusRequest);
        ArgumentCaptor<RequestWrapperDTO<OrderStatusRequest, OrderStatusResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<OrderStatusRequest, OrderStatusResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        OrderStatusRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                TradeApiTest.class.getResource("/expected/api/TradeApi/order.status-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Test new order
     *
     * <p>Test order placement. Validates new order parameters and verifies your signature but does
     * not send the order into the matching engine. Weight: |Condition| Request Weight|
     * |------------ | ------------ | |Without &#x60;computeCommissionRates&#x60;| 1| |With
     * &#x60;computeCommissionRates&#x60;|20|
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void orderTestTest() throws ApiException, URISyntaxException, IOException {
        OrderTestRequest orderTestRequest = new OrderTestRequest();
        CompletableFuture<OrderTestResponse> response = api.orderTest(orderTestRequest);
        ArgumentCaptor<RequestWrapperDTO<OrderTestRequest, OrderTestResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<OrderTestRequest, OrderTestResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        OrderTestRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                TradeApiTest.class.getResource("/expected/api/TradeApi/order.test-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Place new order using SOR
     *
     * <p>Places an order using smart order routing (SOR). Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void sorOrderPlaceTest() throws ApiException, URISyntaxException, IOException {
        SorOrderPlaceRequest sorOrderPlaceRequest = new SorOrderPlaceRequest();
        sorOrderPlaceRequest.symbol("BTCUSDT").quantity(0.00).side(Side.BUY).type(OrderType.LIMIT);
        CompletableFuture<SorOrderPlaceResponse> response = api.sorOrderPlace(sorOrderPlaceRequest);
        ArgumentCaptor<RequestWrapperDTO<SorOrderPlaceRequest, SorOrderPlaceResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<SorOrderPlaceRequest, SorOrderPlaceResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        SorOrderPlaceRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                TradeApiTest.class.getResource("/expected/api/TradeApi/sor.order.place-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Test new order using SOR
     *
     * <p>Test new order creation and signature/recvWindow using smart order routing (SOR). Creates
     * and validates a new order but does not send it into the matching engine. Weight: |Condition |
     * Request Weight| |------------ | ------------ | |Without &#x60;computeCommissionRates&#x60;| 1
     * | |With &#x60;computeCommissionRates&#x60; |20 |
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void sorOrderTestTest() throws ApiException, URISyntaxException, IOException {
        SorOrderTestRequest sorOrderTestRequest = new SorOrderTestRequest();
        CompletableFuture<SorOrderTestResponse> response = api.sorOrderTest(sorOrderTestRequest);
        ArgumentCaptor<RequestWrapperDTO<SorOrderTestRequest, SorOrderTestResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<SorOrderTestRequest, SorOrderTestResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        SorOrderTestRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                TradeApiTest.class.getResource("/expected/api/TradeApi/sor.order.test-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }
}
