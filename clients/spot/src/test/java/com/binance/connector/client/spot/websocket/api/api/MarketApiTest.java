/*
 * Binance Public Spot WebSocket API
 * OpenAPI Specifications for the Binance Public Spot WebSocket API  API documents:   - [Github web-socket-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-api.md)   - [General API information for web-socket-api on website](https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/general-api-information)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.spot.websocket.api.api;

import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.websocket.adapter.ConnectionWrapper;

import com.binance.connector.client.common.websocket.configuration.WebSocketClientConfiguration;
import com.binance.connector.client.common.websocket.dtos.RequestWrapperDTO;
import com.binance.connector.client.spot.websocket.api.model.AvgPriceRequest;
import com.binance.connector.client.spot.websocket.api.model.AvgPriceResponse;
import com.binance.connector.client.spot.websocket.api.model.DepthRequest;
import com.binance.connector.client.spot.websocket.api.model.DepthResponse;
import com.binance.connector.client.spot.websocket.api.model.Interval;
import com.binance.connector.client.spot.websocket.api.model.KlinesRequest;
import com.binance.connector.client.spot.websocket.api.model.KlinesResponse;
import com.binance.connector.client.spot.websocket.api.model.Symbols;
import com.binance.connector.client.spot.websocket.api.model.Ticker24hrRequest;
import com.binance.connector.client.spot.websocket.api.model.Ticker24hrResponse;
import com.binance.connector.client.spot.websocket.api.model.TickerBookRequest;
import com.binance.connector.client.spot.websocket.api.model.TickerBookResponse;
import com.binance.connector.client.spot.websocket.api.model.TickerPriceRequest;
import com.binance.connector.client.spot.websocket.api.model.TickerPriceResponse;
import com.binance.connector.client.spot.websocket.api.model.TickerRequest;
import com.binance.connector.client.spot.websocket.api.model.TickerResponse;
import com.binance.connector.client.spot.websocket.api.model.TickerTradingDayRequest;
import com.binance.connector.client.spot.websocket.api.model.TickerTradingDayResponse;
import com.binance.connector.client.spot.websocket.api.model.TradesAggregateRequest;
import com.binance.connector.client.spot.websocket.api.model.TradesAggregateResponse;
import com.binance.connector.client.spot.websocket.api.model.TradesHistoricalRequest;
import com.binance.connector.client.spot.websocket.api.model.TradesHistoricalResponse;
import com.binance.connector.client.spot.websocket.api.model.TradesRecentRequest;
import com.binance.connector.client.spot.websocket.api.model.TradesRecentResponse;
import com.binance.connector.client.spot.websocket.api.model.UiKlinesRequest;
import com.binance.connector.client.spot.websocket.api.model.UiKlinesResponse;
import java.io.File;
import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.concurrent.CompletableFuture;

import org.eclipse.jetty.websocket.api.RemoteEndpoint;
import org.eclipse.jetty.websocket.api.Session;
import org.eclipse.jetty.websocket.client.WebSocketClient;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;
import org.skyscreamer.jsonassert.JSONAssert;

/** API tests for MarketApi */
public class MarketApiTest {

    private MarketApi api;
    private ConnectionWrapper connectionSpy;
    private Session sessionMock;

    @BeforeEach
    public void initApiClient() throws Exception {
        URL resource = MarketApi.class.getResource("/test-ed25519-prv-key.pem");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        File file = new File(resource.toURI());
        signatureConfiguration.setPrivateKey(file.getAbsolutePath());
        WebSocketClientConfiguration clientConfiguration = new WebSocketClientConfiguration();
        // @TODO: run tests for LOGON as well
        clientConfiguration.setAutoLogon(false);
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);
        clientConfiguration.setUrl("wss://localhost:8080");

        WebSocketClient webSocketClient = Mockito.mock(WebSocketClient.class);
        CompletableFuture<Session> sessionCompletableFuture = new CompletableFuture<>();
        Mockito.doReturn(sessionCompletableFuture)
                .when(webSocketClient)
                .connect(Mockito.any(), Mockito.any(), Mockito.any());
        sessionMock = Mockito.mock(Session.class);

        RemoteEndpoint remoteEndpointMock = Mockito.mock(RemoteEndpoint.class);
        Mockito.doReturn(remoteEndpointMock).when(sessionMock).getRemote();

        sessionCompletableFuture.complete(sessionMock);
        ConnectionWrapper connectionWrapper =
                new ConnectionWrapper(clientConfiguration, webSocketClient);
        connectionSpy = Mockito.spy(connectionWrapper);
        Mockito.doReturn(1736393892000L).when(connectionSpy).getTimestamp();
        connectionSpy.connect();
        MarketApi accountApi = new MarketApi(connectionSpy);
        api = Mockito.spy(accountApi);
        Mockito.doReturn("eaf3292c-64b6-4c04-ad4f-4ca2608b42b4").when(api).getRequestID();
    }

    /**
     * WebSocket Current average price
     *
     * <p>Get current average price for a symbol. Weight: 2
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void avgPriceTest() throws ApiException, URISyntaxException, IOException {
        AvgPriceRequest avgPriceRequest = new AvgPriceRequest();
        avgPriceRequest.setSymbol("BTCUSDT");
        CompletableFuture<AvgPriceResponse> response = api.avgPrice(avgPriceRequest);
        ArgumentCaptor<RequestWrapperDTO<AvgPriceRequest, AvgPriceResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<AvgPriceRequest, AvgPriceResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        AvgPriceRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                MarketApiTest.class.getResource("/expected/api/MarketApi/avgPrice-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Order book
     *
     * <p>Get current order book. Note that this request returns limited market depth. If you need
     * to continuously monitor order book updates, please consider using WebSocket Streams: *
     * &#x60;&lt;symbol&gt;@depth&lt;levels&gt;&#x60; * &#x60;&lt;symbol&gt;@depth&#x60; You can use
     * &#x60;depth&#x60; request together with &#x60;&lt;symbol&gt;@depth&#x60; streams to [maintain
     * a local order book](web-socket-streams.md#how-to-manage-a-local-order-book-correctly).
     * Weight: Adjusted based on the limit: | Limit | Weight | |:---------:|:------:| | 1–100 | 5 |
     * | 101–500 | 25| | 501–1000 | 50 | | 1001–5000 | 250 |
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void depthTest() throws ApiException, URISyntaxException, IOException {
        DepthRequest depthRequest = new DepthRequest();
        depthRequest.setSymbol("BTCUSDT");
        CompletableFuture<DepthResponse> response = api.depth(depthRequest);
        ArgumentCaptor<RequestWrapperDTO<DepthRequest, DepthResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<DepthRequest, DepthResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        DepthRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource = MarketApiTest.class.getResource("/expected/api/MarketApi/depth-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Klines
     *
     * <p>Get klines (candlestick bars). Klines are uniquely identified by their open &amp; close
     * time. If you need access to real-time kline updates, please consider using WebSocket Streams:
     * * &#x60;&lt;symbol&gt;@kline_&lt;interval&gt;&#x60; If you need historical kline data, please
     * consider using [data.binance.vision](https://github.com/binance/binance-public-data/#klines).
     * Weight: 2
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void klinesTest() throws ApiException, URISyntaxException, IOException {
        KlinesRequest klinesRequest = new KlinesRequest();
        klinesRequest.setSymbol("BTCUSDT");
        klinesRequest.setInterval(Interval.INTERVAL_1d);
        CompletableFuture<KlinesResponse> response = api.klines(klinesRequest);
        ArgumentCaptor<RequestWrapperDTO<KlinesRequest, KlinesResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<KlinesRequest, KlinesResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        KlinesRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource = MarketApiTest.class.getResource("/expected/api/MarketApi/klines-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Rolling window price change statistics
     *
     * <p>Get rolling window price change statistics with a custom window. This request is similar
     * to &#x60;ticker.24hr&#x60;, but statistics are computed on demand using the arbitrary window
     * you specify. Weight: Adjusted based on the number of requested symbols: | Symbols | Weight |
     * |:-------:|:------:| | 1–50 | 4 per symbol | | 51–100 | 200 |
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void tickerTest() throws ApiException, URISyntaxException, IOException {
        TickerRequest tickerRequest = new TickerRequest();
        tickerRequest.symbols(new Symbols());
        CompletableFuture<TickerResponse> response = api.ticker(tickerRequest);
        ArgumentCaptor<RequestWrapperDTO<TickerRequest, TickerResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<TickerRequest, TickerResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        TickerRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource = MarketApiTest.class.getResource("/expected/api/MarketApi/ticker-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket 24hr ticker price change statistics
     *
     * <p>Get 24-hour rolling window price change statistics. If you need to continuously monitor
     * trading statistics, please consider using WebSocket Streams: *
     * &#x60;&lt;symbol&gt;@ticker&#x60; or &#x60;!ticker@arr&#x60; *
     * &#x60;&lt;symbol&gt;@miniTicker&#x60; or &#x60;!miniTicker@arr&#x60; If you need different
     * window sizes, use the &#x60;ticker&#x60; request. Weight: Adjusted based on the number of
     * requested symbols: | Symbols | Weight | |:-----------:|:------:| | 1–20 | 2 | | 21–100 | 40 |
     * | 101 or more | 80 | | all symbols | 80 |
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void ticker24hrTest() throws ApiException, URISyntaxException, IOException {
        Ticker24hrRequest ticker24hrRequest = new Ticker24hrRequest();
        ticker24hrRequest.symbols(new Symbols());
        CompletableFuture<Ticker24hrResponse> response = api.ticker24hr(ticker24hrRequest);
        ArgumentCaptor<RequestWrapperDTO<Ticker24hrRequest, Ticker24hrResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Ticker24hrRequest, Ticker24hrResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Ticker24hrRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                MarketApiTest.class.getResource("/expected/api/MarketApi/ticker.24hr-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Symbol order book ticker
     *
     * <p>Get the current best price and quantity on the order book. If you need access to real-time
     * order book ticker updates, please consider using WebSocket Streams: *
     * &#x60;&lt;symbol&gt;@bookTicker&#x60; Weight: Adjusted based on the number of requested
     * symbols: | Parameter | Weight | | --------- |:------:| | &#x60;symbol&#x60; | 2 | |
     * &#x60;symbols&#x60; | 4 | | none | 4 |
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void tickerBookTest() throws ApiException, URISyntaxException, IOException {
        TickerBookRequest tickerBookRequest = new TickerBookRequest();
        tickerBookRequest.setSymbols(new Symbols());
        CompletableFuture<TickerBookResponse> response = api.tickerBook(tickerBookRequest);
        ArgumentCaptor<RequestWrapperDTO<TickerBookRequest, TickerBookResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<TickerBookRequest, TickerBookResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        TickerBookRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                MarketApiTest.class.getResource("/expected/api/MarketApi/ticker.book-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Symbol price ticker
     *
     * <p>Get the latest market price for a symbol. If you need access to real-time price updates,
     * please consider using WebSocket Streams: * &#x60;&lt;symbol&gt;@aggTrade&#x60; *
     * &#x60;&lt;symbol&gt;@trade&#x60; Weight: Adjusted based on the number of requested symbols: |
     * Parameter | Weight | | --------- |:------:| | &#x60;symbol&#x60; | 2 | | &#x60;symbols&#x60;
     * | 4 | | none | 4 |
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void tickerPriceTest() throws ApiException, URISyntaxException, IOException {
        TickerPriceRequest tickerPriceRequest = new TickerPriceRequest();
        tickerPriceRequest.symbols(new Symbols());
        CompletableFuture<TickerPriceResponse> response = api.tickerPrice(tickerPriceRequest);
        ArgumentCaptor<RequestWrapperDTO<TickerPriceRequest, TickerPriceResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<TickerPriceRequest, TickerPriceResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        TickerPriceRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                MarketApiTest.class.getResource("/expected/api/MarketApi/ticker.price-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Trading Day Ticker
     *
     * <p>Price change statistics for a trading day. Weight: 4 for each requested
     * &lt;tt&gt;symbol&lt;/tt&gt;. &lt;br/&gt;&lt;br/&gt; The weight for this request will cap at
     * 200 once the number of &#x60;symbols&#x60; in the request is more than 50.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void tickerTradingDayTest() throws ApiException, URISyntaxException, IOException {
        TickerTradingDayRequest tickerTradingDayRequest = new TickerTradingDayRequest();
        tickerTradingDayRequest.symbols(new Symbols());
        CompletableFuture<TickerTradingDayResponse> response =
                api.tickerTradingDay(tickerTradingDayRequest);
        ArgumentCaptor<RequestWrapperDTO<TickerTradingDayRequest, TickerTradingDayResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<TickerTradingDayRequest, TickerTradingDayResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        TickerTradingDayRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                MarketApiTest.class.getResource(
                        "/expected/api/MarketApi/ticker.tradingDay-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Aggregate trades
     *
     * <p>Get aggregate trades. An *aggregate trade* (aggtrade) represents one or more individual
     * trades. Trades that fill at the same time, from the same taker order, with the same price –
     * those trades are collected into an aggregate trade with total quantity of the individual
     * trades. If you need access to real-time trading activity, please consider using WebSocket
     * Streams: * &#x60;&lt;symbol&gt;@aggTrade&#x60; If you need historical aggregate trade data,
     * please consider using
     * [data.binance.vision](https://github.com/binance/binance-public-data/#aggtrades). Weight: 2
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void tradesAggregateTest() throws ApiException, URISyntaxException, IOException {
        TradesAggregateRequest tradesAggregateRequest = new TradesAggregateRequest();
        tradesAggregateRequest.setSymbol("BTCUSDT");
        CompletableFuture<TradesAggregateResponse> response =
                api.tradesAggregate(tradesAggregateRequest);
        ArgumentCaptor<RequestWrapperDTO<TradesAggregateRequest, TradesAggregateResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<TradesAggregateRequest, TradesAggregateResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        TradesAggregateRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                MarketApiTest.class.getResource(
                        "/expected/api/MarketApi/trades.aggregate-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Historical trades
     *
     * <p>Get historical trades. Weight: 25
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void tradesHistoricalTest() throws ApiException, URISyntaxException, IOException {
        TradesHistoricalRequest tradesHistoricalRequest = new TradesHistoricalRequest();
        tradesHistoricalRequest.setSymbol("BTCUSDT");
        CompletableFuture<TradesHistoricalResponse> response =
                api.tradesHistorical(tradesHistoricalRequest);
        ArgumentCaptor<RequestWrapperDTO<TradesHistoricalRequest, TradesHistoricalResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<TradesHistoricalRequest, TradesHistoricalResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        TradesHistoricalRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                MarketApiTest.class.getResource(
                        "/expected/api/MarketApi/trades.historical-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Recent trades
     *
     * <p>Get recent trades. If you need access to real-time trading activity, please consider using
     * WebSocket Streams: * &#x60;&lt;symbol&gt;@trade&#x60; Weight: 25
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void tradesRecentTest() throws ApiException, URISyntaxException, IOException {
        TradesRecentRequest tradesRecentRequest = new TradesRecentRequest();
        tradesRecentRequest.setSymbol("BTCUSDT");
        CompletableFuture<TradesRecentResponse> response = api.tradesRecent(tradesRecentRequest);
        ArgumentCaptor<RequestWrapperDTO<TradesRecentRequest, TradesRecentResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<TradesRecentRequest, TradesRecentResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        TradesRecentRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                MarketApiTest.class.getResource("/expected/api/MarketApi/trades.recent-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket UI Klines
     *
     * <p>Get klines (candlestick bars) optimized for presentation. This request is similar to
     * &#x60;klines&#x60;, having the same parameters and response. &#x60;uiKlines&#x60; return
     * modified kline data, optimized for presentation of candlestick charts. Weight: 2
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void uiKlinesTest() throws ApiException, URISyntaxException, IOException {
        UiKlinesRequest uiKlinesRequest = new UiKlinesRequest();
        uiKlinesRequest.setSymbol("BTCUSDT");
        uiKlinesRequest.setInterval(Interval.INTERVAL_1d);
        CompletableFuture<UiKlinesResponse> response = api.uiKlines(uiKlinesRequest);
        ArgumentCaptor<RequestWrapperDTO<UiKlinesRequest, UiKlinesResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<UiKlinesRequest, UiKlinesResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        UiKlinesRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                MarketApiTest.class.getResource("/expected/api/MarketApi/uiKlines-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }
}
