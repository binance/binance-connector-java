/*
 * Binance Spot REST API
 * OpenAPI Specifications for the Binance Spot REST API  API documents:   - [Github rest-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md)   - [General API information for rest-api on website](https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-api-information)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.spot.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.spot.rest.model.AccountCommissionResponse;
import com.binance.connector.client.spot.rest.model.AllOrderListResponse;
import com.binance.connector.client.spot.rest.model.AllOrdersResponse;
import com.binance.connector.client.spot.rest.model.GetAccountResponse;
import com.binance.connector.client.spot.rest.model.GetOpenOrdersResponse;
import com.binance.connector.client.spot.rest.model.GetOrderListResponse;
import com.binance.connector.client.spot.rest.model.GetOrderResponse;
import com.binance.connector.client.spot.rest.model.MyAllocationsResponse;
import com.binance.connector.client.spot.rest.model.MyPreventedMatchesResponse;
import com.binance.connector.client.spot.rest.model.MyTradesResponse;
import com.binance.connector.client.spot.rest.model.OpenOrderListResponse;
import com.binance.connector.client.spot.rest.model.RateLimitOrderResponse;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for AccountApi */
public class AccountApiTest {

    private AccountApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new AccountApi(apiClientSpy);
    }

    /**
     * Query Commission Rates
     *
     * <p>Get current account commission rates. Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void accountCommissionTest() throws ApiException, CryptoException {
        String symbol = "BNBUSDT";
        ApiResponse<AccountCommissionResponse> response = api.accountCommission(symbol);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=BNBUSDT&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "0ffc690e548c601c0f1fac6208ae531f94448e66a4126acd33db21b4779d0f72",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/api/v3/account/commission", actualRequest.url().encodedPath());
    }

    /**
     * Account information
     *
     * <p>Get current account information. Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAccountTest() throws ApiException, CryptoException {
        Boolean omitZeroBalances = false;
        Long recvWindow = 5000L;
        ApiResponse<GetAccountResponse> response = api.getAccount(omitZeroBalances, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "omitZeroBalances=false&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "80eb12d82de3d921dc6a83f98a28a092b813f6946f7ce7c57c0540c86607a60c",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/api/v3/account", actualRequest.url().encodedPath());
    }

    /**
     * Query Allocations
     *
     * <p>Retrieves allocations resulting from SOR order placement. Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void myAllocationsTest() throws ApiException, CryptoException {
        String symbol = "BNBUSDT";
        Long startTime = 1735693200000L;
        Long endTime = 1735693200000L;
        Integer fromAllocationId = 1;
        Integer limit = 500;
        Long orderId = 1L;
        Long recvWindow = 5000L;
        ApiResponse<MyAllocationsResponse> response =
                api.myAllocations(
                        symbol, startTime, endTime, fromAllocationId, limit, orderId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=BNBUSDT&startTime=1735693200000&endTime=1735693200000&fromAllocationId=1&limit=500&orderId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "e6d3c40d9c6d8b9c03d0a66f5f52d4518182d2e02b8a6471ca535a5478cab087",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/api/v3/myAllocations", actualRequest.url().encodedPath());
    }

    /**
     * Query Prevented Matches
     *
     * <p>Displays the list of orders that were expired due to STP. These are the combinations
     * supported: * &#x60;symbol&#x60; + &#x60;preventedMatchId&#x60; * &#x60;symbol&#x60; +
     * &#x60;orderId&#x60; * &#x60;symbol&#x60; + &#x60;orderId&#x60; +
     * &#x60;fromPreventedMatchId&#x60; (&#x60;limit&#x60; will default to 500) * &#x60;symbol&#x60;
     * + &#x60;orderId&#x60; + &#x60;fromPreventedMatchId&#x60; + &#x60;limit&#x60; Weight: Case |
     * Weight ---- | ----- If &#x60;symbol&#x60; is invalid | 2 Querying by
     * &#x60;preventedMatchId&#x60; | 2 Querying by &#x60;orderId&#x60; | 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void myPreventedMatchesTest() throws ApiException, CryptoException {
        String symbol = "BNBUSDT";
        Long preventedMatchId = 1L;
        Long orderId = 1L;
        Long fromPreventedMatchId = 1L;
        Integer limit = 500;
        Long recvWindow = 5000L;
        ApiResponse<MyPreventedMatchesResponse> response =
                api.myPreventedMatches(
                        symbol, preventedMatchId, orderId, fromPreventedMatchId, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=BNBUSDT&preventedMatchId=1&orderId=1&fromPreventedMatchId=1&limit=500&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "dba5c1473a22f87a0350c80d3754ff03a7e67b8917be6f0a98959cc4c9263b5d",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/api/v3/myPreventedMatches", actualRequest.url().encodedPath());
    }

    /**
     * Account trade list
     *
     * <p>Get trades for a specific account and symbol. Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void myTradesTest() throws ApiException, CryptoException {
        String symbol = "BNBUSDT";
        Long orderId = 1L;
        Long startTime = 1735693200000L;
        Long endTime = 1735693200000L;
        Long fromId = 1L;
        Integer limit = 500;
        Long recvWindow = 5000L;
        ApiResponse<MyTradesResponse> response =
                api.myTrades(symbol, orderId, startTime, endTime, fromId, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=BNBUSDT&orderId=1&startTime=1735693200000&endTime=1735693200000&fromId=1&limit=500&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "87114efcf71607d26ebed7c7ffab3ea9497a74121ac06151116831a22b8c8263",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/api/v3/myTrades", actualRequest.url().encodedPath());
    }

    /**
     * Query Unfilled Order Count
     *
     * <p>Displays the user&#39;s unfilled order count for all intervals. Weight: 40
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void rateLimitOrderTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<RateLimitOrderResponse> response = api.rateLimitOrder(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/api/v3/rateLimit/order", actualRequest.url().encodedPath());
    }

    /**
     * Query all Order lists
     *
     * <p>Retrieves all order lists based on provided optional parameters. Note that the time
     * between &#x60;startTime&#x60; and &#x60;endTime&#x60; can&#39;t be longer than 24 hours.
     * Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void allOrderListTest() throws ApiException, CryptoException {
        Long fromId = 1L;
        Long startTime = 1735693200000L;
        Long endTime = 1735693200000L;
        Integer limit = 500;
        Long recvWindow = 5000L;
        ApiResponse<AllOrderListResponse> response =
                api.allOrderList(fromId, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "fromId=1&startTime=1735693200000&endTime=1735693200000&limit=500&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "3f96b521ab45f68dea5e3b363c355bdd37bc2834d4ec7457ac7990d2d75178c2",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/api/v3/allOrderList", actualRequest.url().encodedPath());
    }

    /**
     * All orders
     *
     * <p>Get all account orders; active, canceled, or filled. Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void allOrdersTest() throws ApiException, CryptoException {
        String symbol = "BNBUSDT";
        Long orderId = 1L;
        Long startTime = 1735693200000L;
        Long endTime = 1735693200000L;
        Integer limit = 500;
        Long recvWindow = 5000L;
        ApiResponse<AllOrdersResponse> response =
                api.allOrders(symbol, orderId, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=BNBUSDT&orderId=1&startTime=1735693200000&endTime=1735693200000&limit=500&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "7f857866c2bd2678db911c5a1084412d274ea5c0dca24c8cca5c97ba0bc38ea6",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/api/v3/allOrders", actualRequest.url().encodedPath());
    }

    /**
     * Current open orders
     *
     * <p>Get all open orders on a symbol. **Careful** when accessing this with no symbol. Weight: 6
     * for a single symbol; **80** when the symbol parameter is omitted
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getOpenOrdersTest() throws ApiException, CryptoException {
        String symbol = "BNBUSDT";
        Long recvWindow = 5000L;
        ApiResponse<GetOpenOrdersResponse> response = api.getOpenOrders(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=BNBUSDT&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "1c2ec70499498e5c5d2f4e98a7e24c74f2801642a8c3743d289dbfc1ca00c7a8",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/api/v3/openOrders", actualRequest.url().encodedPath());
    }

    /**
     * Query order
     *
     * <p>Check an order&#39;s status. Weight: 4
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getOrderTest() throws ApiException, CryptoException {
        String symbol = "BNBUSDT";
        Long orderId = 1L;
        String origClientOrderId = "";
        Long recvWindow = 5000L;
        ApiResponse<GetOrderResponse> response =
                api.getOrder(symbol, orderId, origClientOrderId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=BNBUSDT&orderId=1&origClientOrderId=&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "7df47f2422bd464ff42ac1a57d75c3296c3fd7867f50fd803ad466992b26ef0c",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/api/v3/order", actualRequest.url().encodedPath());
    }

    /**
     * Query Order list
     *
     * <p>Retrieves a specific order list based on provided optional parameters. Weight: 4
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getOrderListTest() throws ApiException, CryptoException {
        Long orderListId = 1L;
        String origClientOrderId = "";
        Long recvWindow = 5000L;
        ApiResponse<GetOrderListResponse> response =
                api.getOrderList(orderListId, origClientOrderId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "orderListId=1&origClientOrderId=&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "6ec9556d1bd19774835e1c8987ff1d260c57f711747a39d4ea50c5e10b099d72",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/api/v3/orderList", actualRequest.url().encodedPath());
    }

    /**
     * Query Open Order lists
     *
     * <p>Weight: 6
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void openOrderListTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<OpenOrderListResponse> response = api.openOrderList(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/api/v3/openOrderList", actualRequest.url().encodedPath());
    }
}
