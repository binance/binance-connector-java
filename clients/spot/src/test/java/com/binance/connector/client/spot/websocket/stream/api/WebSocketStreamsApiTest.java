/*
 * Binance Public Spot WebSocket Streams
 * OpenAPI Specifications for the Binance Public Spot WebSocket Streams  API documents:   - [Github web-socket-streams documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-streams.md)   - [General API information for web-socket-streams on website](https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.spot.websocket.stream.api;

import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.websocket.adapter.stream.StreamConnectionWrapper;
import com.binance.connector.client.common.websocket.configuration.SessionMode;
import com.binance.connector.client.common.websocket.configuration.WebSocketClientConfiguration;
import com.binance.connector.client.common.websocket.dtos.RequestWrapperDTO;
import com.binance.connector.client.common.websocket.service.StreamBlockingQueueWrapper;
import com.binance.connector.client.spot.websocket.stream.model.AggTradeRequest;
import com.binance.connector.client.spot.websocket.stream.model.AggTradeResponse;
import com.binance.connector.client.spot.websocket.stream.model.AllMarketRollingWindowTickerRequest;
import com.binance.connector.client.spot.websocket.stream.model.AllMarketRollingWindowTickerResponse;
import com.binance.connector.client.spot.websocket.stream.model.AllMiniTickerResponse;
import com.binance.connector.client.spot.websocket.stream.model.AllTickerResponse;
import com.binance.connector.client.spot.websocket.stream.model.AvgPriceRequest;
import com.binance.connector.client.spot.websocket.stream.model.AvgPriceResponse;
import com.binance.connector.client.spot.websocket.stream.model.BookTickerRequest;
import com.binance.connector.client.spot.websocket.stream.model.BookTickerResponse;
import com.binance.connector.client.spot.websocket.stream.model.DiffBookDepthRequest;
import com.binance.connector.client.spot.websocket.stream.model.DiffBookDepthResponse;
import com.binance.connector.client.spot.websocket.stream.model.Interval;
import com.binance.connector.client.spot.websocket.stream.model.KlineOffsetRequest;
import com.binance.connector.client.spot.websocket.stream.model.KlineOffsetResponse;
import com.binance.connector.client.spot.websocket.stream.model.KlineRequest;
import com.binance.connector.client.spot.websocket.stream.model.KlineResponse;
import com.binance.connector.client.spot.websocket.stream.model.Levels;
import com.binance.connector.client.spot.websocket.stream.model.MiniTickerRequest;
import com.binance.connector.client.spot.websocket.stream.model.MiniTickerResponse;
import com.binance.connector.client.spot.websocket.stream.model.PartialBookDepthRequest;
import com.binance.connector.client.spot.websocket.stream.model.PartialBookDepthResponse;
import com.binance.connector.client.spot.websocket.stream.model.RollingWindowTickerRequest;
import com.binance.connector.client.spot.websocket.stream.model.RollingWindowTickerResponse;
import com.binance.connector.client.spot.websocket.stream.model.TickerRequest;
import com.binance.connector.client.spot.websocket.stream.model.TickerResponse;
import com.binance.connector.client.spot.websocket.stream.model.TradeRequest;
import com.binance.connector.client.spot.websocket.stream.model.TradeResponse;
import com.binance.connector.client.spot.websocket.stream.model.WindowSize;
import java.io.File;
import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Set;
import java.util.concurrent.CompletableFuture;

import org.eclipse.jetty.websocket.api.RemoteEndpoint;
import org.eclipse.jetty.websocket.api.Session;
import org.eclipse.jetty.websocket.client.WebSocketClient;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;
import org.skyscreamer.jsonassert.JSONAssert;

/** API tests for WebSocketStreamsApi */
public class WebSocketStreamsApiTest {

    private WebSocketStreamsApi api;
    private StreamConnectionWrapper connectionSpy;
    private Session sessionMock;

    @BeforeEach
    public void initApiClient() throws Exception {
        URL resource = WebSocketStreamsApi.class.getResource("/test-ed25519-prv-key.pem");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        File file = new File(resource.toURI());
        signatureConfiguration.setPrivateKey(file.getAbsolutePath());
        WebSocketClientConfiguration clientConfiguration = new WebSocketClientConfiguration();
        // @TODO: run tests for LOGON as well
        clientConfiguration.setAutoLogon(false);
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);
        clientConfiguration.setUrl("wss://localhost:8080");

        WebSocketClient webSocketClient = Mockito.mock(WebSocketClient.class);
        CompletableFuture<Session> sessionCompletableFuture = new CompletableFuture<>();
        Mockito.doReturn(sessionCompletableFuture)
                .when(webSocketClient)
                .connect(Mockito.any(), Mockito.any(), Mockito.any());
        sessionMock = Mockito.mock(Session.class);

        RemoteEndpoint remoteEndpointMock = Mockito.mock(RemoteEndpoint.class);
        Mockito.doReturn(remoteEndpointMock).when(sessionMock).getRemote();

        sessionCompletableFuture.complete(sessionMock);
        StreamConnectionWrapper connectionWrapper =
                new StreamConnectionWrapper(clientConfiguration, webSocketClient);
        connectionSpy = Mockito.spy(connectionWrapper);
        Mockito.doReturn(1736393892000L).when(connectionSpy).getTimestamp();
        connectionSpy.connect();
        WebSocketStreamsApi accountApi = new WebSocketStreamsApi(connectionSpy);
        api = Mockito.spy(accountApi);
        Mockito.doReturn("eaf3292c-64b6-4c04-ad4f-4ca2608b42b4").when(api).getRequestID();
    }

    /**
     * WebSocket Aggregate Trade Streams
     *
     * <p>The Aggregate Trade Streams push trade information that is aggregated for a single taker
     * order.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void aggTradeTest() throws ApiException, URISyntaxException, IOException {
        AggTradeRequest aggTradeRequest = new AggTradeRequest();
        aggTradeRequest.setSymbol("btcusdt");
        StreamBlockingQueueWrapper<AggTradeResponse> response = api.aggTrade(aggTradeRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, AggTradeResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, AggTradeResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebSocketStreamsApiTest.class.getResource(
                        "/expected/stream/WebSocketStreamsApi/symbol@aggTrade-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket All Market Rolling Window Statistics Streams
     *
     * <p>Rolling window ticker statistics for all market symbols, computed over multiple windows.
     * Note that only tickers that have changed will be present in the array.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void allMarketRollingWindowTickerTest()
            throws ApiException, URISyntaxException, IOException {
        AllMarketRollingWindowTickerRequest allMarketRollingWindowTickerRequest =
                new AllMarketRollingWindowTickerRequest();
        allMarketRollingWindowTickerRequest.windowSize(WindowSize.WINDOW_SIZE_1d);
        StreamBlockingQueueWrapper<AllMarketRollingWindowTickerResponse> lists =
                api.allMarketRollingWindowTicker(allMarketRollingWindowTickerRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, AllMarketRollingWindowTickerResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, AllMarketRollingWindowTickerResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebSocketStreamsApiTest.class.getResource(
                        "/expected/stream/WebSocketStreamsApi/ticker_window-size@arr-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket All Market Mini Tickers Stream
     *
     * <p>24hr rolling window mini-ticker statistics for all symbols that changed in an array. These
     * are NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs. Note
     * that only tickers that have changed will be present in the array.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void allMiniTickerTest() throws ApiException, URISyntaxException, IOException {
        StreamBlockingQueueWrapper<AllMiniTickerResponse> lists = api.allMiniTicker();
        ArgumentCaptor<RequestWrapperDTO<Set<String>, AllMiniTickerResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, AllMiniTickerResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebSocketStreamsApiTest.class.getResource(
                        "/expected/stream/WebSocketStreamsApi/!miniTicker@arr-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket All Market Tickers Stream
     *
     * <p>24hr rolling window ticker statistics for all symbols that changed in an array. These are
     * NOT the statistics of the UTC day, but a 24hr rolling window for the previous 24hrs. Note
     * that only tickers that have changed will be present in the array.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void allTickerTest() throws ApiException, URISyntaxException, IOException {
        StreamBlockingQueueWrapper<AllTickerResponse> response = api.allTicker();
        ArgumentCaptor<RequestWrapperDTO<Set<String>, AllTickerResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, AllTickerResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebSocketStreamsApiTest.class.getResource(
                        "/expected/stream/WebSocketStreamsApi/!ticker@arr-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Average Price
     *
     * <p>Average price streams push changes in the average price over a fixed time interval.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void avgPriceTest() throws ApiException, URISyntaxException, IOException {
        AvgPriceRequest avgPriceRequest = new AvgPriceRequest();
        avgPriceRequest.setSymbol("btcusdt");
        StreamBlockingQueueWrapper<AvgPriceResponse> response = api.avgPrice(avgPriceRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, AvgPriceResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, AvgPriceResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebSocketStreamsApiTest.class.getResource(
                        "/expected/stream/WebSocketStreamsApi/symbol@avgPrice-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Individual Symbol Book Ticker Streams
     *
     * <p>Pushes any update to the best bid or ask&#39;s price or quantity in real-time for a
     * specified symbol. Multiple &#x60;&lt;symbol&gt;@bookTicker&#x60; streams can be subscribed to
     * over one connection.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void bookTickerTest() throws ApiException, URISyntaxException, IOException {
        BookTickerRequest bookTickerRequest = new BookTickerRequest();
        bookTickerRequest.setSymbol("btcusdt");
        StreamBlockingQueueWrapper<BookTickerResponse> response = api.bookTicker(bookTickerRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, BookTickerResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, BookTickerResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebSocketStreamsApiTest.class.getResource(
                        "/expected/stream/WebSocketStreamsApi/symbol@bookTicker-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Diff. Depth Stream
     *
     * <p>Order book price and quantity depth updates used to locally manage an order book.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void diffBookDepthTest() throws ApiException, URISyntaxException, IOException {
        DiffBookDepthRequest diffBookDepthRequest = new DiffBookDepthRequest();
        diffBookDepthRequest.setSymbol("btcusdt");
        StreamBlockingQueueWrapper<DiffBookDepthResponse> response =
                api.diffBookDepth(diffBookDepthRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, DiffBookDepthResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, DiffBookDepthResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebSocketStreamsApiTest.class.getResource(
                        "/expected/stream/WebSocketStreamsApi/symbol@depthupdateSpeed-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Kline/Candlestick Streams for UTC
     *
     * <p>The Kline/Candlestick Stream push updates to the current klines/candlestick every second
     * in &#x60;UTC+0&#x60; timezone &lt;a id&#x3D;\&quot;kline-intervals\&quot;&gt;&lt;/a&gt;
     * **Kline/Candlestick chart intervals:** s-&gt; seconds; m -&gt; minutes; h -&gt; hours; d
     * -&gt; days; w -&gt; weeks; M -&gt; months * 1s * 1m * 3m * 5m * 15m * 30m * 1h * 2h * 4h * 6h
     * * 8h * 12h * 1d * 3d * 1w * 1M
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void klineTest() throws ApiException, URISyntaxException, IOException {
        KlineRequest klineRequest = new KlineRequest();
        klineRequest.setSymbol("btcusdt");
        klineRequest.setInterval(Interval.INTERVAL_1d);
        StreamBlockingQueueWrapper<KlineResponse> response = api.kline(klineRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, KlineResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, KlineResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebSocketStreamsApiTest.class.getResource(
                        "/expected/stream/WebSocketStreamsApi/symbol@kline_interval-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Kline/Candlestick Streams with timezone offset
     *
     * <p>The Kline/Candlestick Stream push updates to the current klines/candlestick every second
     * in &#x60;UTC+8&#x60; timezone **Kline/Candlestick chart intervals:** Supported intervals: 1s,
     * &#x60;1m&#x60;, &#x60;3m&#x60;, &#x60;5m&#x60;, &#x60;15m&#x60;, &#x60;30m&#x60;,
     * &#x60;1h&#x60;, &#x60;2h&#x60;, &#x60;4h&#x60;, &#x60;6h&#x60;, &#x60;8h&#x60;,
     * &#x60;12h&#x60;, &#x60;1d&#x60;, &#x60;3d&#x60;, &#x60;1w&#x60;, &#x60;1M&#x60; **UTC+8
     * timezone offset:** * Kline intervals open and close in the &#x60;UTC+8&#x60; timezone. For
     * example the &#x60;1d&#x60; klines will open at the beginning of the &#x60;UTC+8&#x60; day,
     * and close at the end of the &#x60;UTC+8&#x60; day. * Note that &#x60;E&#x60; (event time),
     * &#x60;t&#x60; (start time) and &#x60;T&#x60; (close time) in the payload are Unix timestamps,
     * which are always interpreted in UTC.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void klineOffsetTest() throws ApiException, URISyntaxException, IOException {
        KlineOffsetRequest klineOffsetRequest = new KlineOffsetRequest();
        klineOffsetRequest.setSymbol("btcusdt");
        klineOffsetRequest.setInterval(Interval.INTERVAL_1d);
        StreamBlockingQueueWrapper<KlineOffsetResponse> response =
                api.klineOffset(klineOffsetRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, KlineOffsetResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, KlineOffsetResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebSocketStreamsApiTest.class.getResource(
                        "/expected/stream/WebSocketStreamsApi/symbol@kline_interval@+0800-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Individual Symbol Mini Ticker Stream
     *
     * <p>24hr rolling window mini-ticker statistics. These are NOT the statistics of the UTC day,
     * but a 24hr rolling window for the previous 24hrs.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void miniTickerTest() throws ApiException, URISyntaxException, IOException {
        MiniTickerRequest miniTickerRequest = new MiniTickerRequest();
        miniTickerRequest.setSymbol("btcusdt");
        StreamBlockingQueueWrapper<MiniTickerResponse> response = api.miniTicker(miniTickerRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, MiniTickerResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, MiniTickerResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebSocketStreamsApiTest.class.getResource(
                        "/expected/stream/WebSocketStreamsApi/symbol@miniTicker-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Partial Book Depth Streams
     *
     * <p>Top **\\&lt;levels\\&gt;** bids and asks, pushed every second. Valid
     * **\\&lt;levels\\&gt;** are 5, 10, or 20.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void partialBookDepthTest() throws ApiException, URISyntaxException, IOException {
        PartialBookDepthRequest partialBookDepthRequest = new PartialBookDepthRequest();
        partialBookDepthRequest.setLevels(Levels.LEVELS_5);
        partialBookDepthRequest.setSymbol("btcusdt");
        StreamBlockingQueueWrapper<PartialBookDepthResponse> response =
                api.partialBookDepth(partialBookDepthRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, PartialBookDepthResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, PartialBookDepthResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebSocketStreamsApiTest.class.getResource(
                        "/expected/stream/WebSocketStreamsApi/symbol@depthlevelsupdateSpeed-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    @Test
    public void partialBookDepthUpdateSpeedTest()
            throws ApiException, URISyntaxException, IOException {
        PartialBookDepthRequest partialBookDepthRequest = new PartialBookDepthRequest();
        partialBookDepthRequest.setLevels(Levels.LEVELS_5);
        partialBookDepthRequest.setSymbol("btcusdt");
        partialBookDepthRequest.setUpdateSpeed("100ms");
        StreamBlockingQueueWrapper<PartialBookDepthResponse> response =
                api.partialBookDepth(partialBookDepthRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, PartialBookDepthResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, PartialBookDepthResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebSocketStreamsApiTest.class.getResource(
                        "/expected/stream/WebSocketStreamsApi/symbol@depthlevelsupdateSpeed-test_update_speed.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Individual Symbol Rolling Window Statistics Streams
     *
     * <p>Rolling window ticker statistics for a single symbol, computed over multiple windows.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void rollingWindowTickerTest() throws ApiException, URISyntaxException, IOException {
        RollingWindowTickerRequest rollingWindowTickerRequest = new RollingWindowTickerRequest();
        rollingWindowTickerRequest.setSymbol("btcusdt");
        rollingWindowTickerRequest.setWindowSize(WindowSize.WINDOW_SIZE_1d);
        StreamBlockingQueueWrapper<RollingWindowTickerResponse> response =
                api.rollingWindowTicker(rollingWindowTickerRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, RollingWindowTickerResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, RollingWindowTickerResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebSocketStreamsApiTest.class.getResource(
                        "/expected/stream/WebSocketStreamsApi/symbol@ticker_window-size-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Individual Symbol Ticker Streams
     *
     * <p>24hr rolling window ticker statistics for a single symbol. These are NOT the statistics of
     * the UTC day, but a 24hr rolling window for the previous 24hrs.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void tickerTest() throws ApiException, URISyntaxException, IOException {
        TickerRequest tickerRequest = new TickerRequest();
        tickerRequest.setSymbol("btcusdt");
        StreamBlockingQueueWrapper<TickerResponse> response = api.ticker(tickerRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, TickerResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, TickerResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebSocketStreamsApiTest.class.getResource(
                        "/expected/stream/WebSocketStreamsApi/symbol@ticker-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Trade Streams
     *
     * <p>The Trade Streams push raw trade information; each trade has a unique buyer and seller.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void tradeTest() throws ApiException, URISyntaxException, IOException {
        TradeRequest tradeRequest = new TradeRequest();
        tradeRequest.setSymbol("btcusdt");
        StreamBlockingQueueWrapper<TradeResponse> response = api.trade(tradeRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, TradeResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, TradeResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebSocketStreamsApiTest.class.getResource(
                        "/expected/stream/WebSocketStreamsApi/symbol@trade-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));

        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }
}
