/*
 * Binance Public Spot WebSocket API
 * OpenAPI Specifications for the Binance Public Spot WebSocket API  API documents:   - [Github web-socket-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-api.md)   - [General API information for web-socket-api on website](https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/general-api-information)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.spot.websocket.api.api;

import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.websocket.adapter.ConnectionWrapper;
import com.binance.connector.client.common.websocket.configuration.SessionMode;
import com.binance.connector.client.common.websocket.configuration.WebSocketClientConfiguration;
import com.binance.connector.client.common.websocket.dtos.RequestWrapperDTO;
import com.binance.connector.client.spot.websocket.api.model.AccountCommissionRequest;
import com.binance.connector.client.spot.websocket.api.model.AccountCommissionResponse;
import com.binance.connector.client.spot.websocket.api.model.AccountRateLimitsOrdersRequest;
import com.binance.connector.client.spot.websocket.api.model.AccountRateLimitsOrdersResponse;
import com.binance.connector.client.spot.websocket.api.model.AccountStatusRequest;
import com.binance.connector.client.spot.websocket.api.model.AccountStatusResponse;
import com.binance.connector.client.spot.websocket.api.model.AllOrderListsRequest;
import com.binance.connector.client.spot.websocket.api.model.AllOrderListsResponse;
import com.binance.connector.client.spot.websocket.api.model.AllOrdersRequest;
import com.binance.connector.client.spot.websocket.api.model.AllOrdersResponse;
import com.binance.connector.client.spot.websocket.api.model.MyAllocationsRequest;
import com.binance.connector.client.spot.websocket.api.model.MyAllocationsResponse;
import com.binance.connector.client.spot.websocket.api.model.MyPreventedMatchesRequest;
import com.binance.connector.client.spot.websocket.api.model.MyPreventedMatchesResponse;
import com.binance.connector.client.spot.websocket.api.model.MyTradesRequest;
import com.binance.connector.client.spot.websocket.api.model.MyTradesResponse;
import java.io.File;
import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.concurrent.CompletableFuture;

import org.eclipse.jetty.websocket.api.RemoteEndpoint;
import org.eclipse.jetty.websocket.api.Session;
import org.eclipse.jetty.websocket.client.WebSocketClient;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;
import org.skyscreamer.jsonassert.JSONAssert;

/** API tests for AccountApi */
public class AccountApiTest {

    private AccountApi api;
    private ConnectionWrapper connectionSpy;
    private Session sessionMock;

    @BeforeEach
    public void initApiClient() throws Exception {
        URL resource = AccountApi.class.getResource("/test-ed25519-prv-key.pem");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        File file = new File(resource.toURI());
        signatureConfiguration.setPrivateKey(file.getAbsolutePath());
        WebSocketClientConfiguration clientConfiguration = new WebSocketClientConfiguration();
        // @TODO: run tests for LOGON as well
        clientConfiguration.setAutoLogon(false);
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);
        clientConfiguration.setUrl("wss://localhost:8080");

        WebSocketClient webSocketClient = Mockito.mock(WebSocketClient.class);
        CompletableFuture<Session> sessionCompletableFuture = new CompletableFuture<>();
        Mockito.doReturn(sessionCompletableFuture)
                .when(webSocketClient)
                .connect(Mockito.any(), Mockito.any(), Mockito.any());
        sessionMock = Mockito.mock(Session.class);

        RemoteEndpoint remoteEndpointMock = Mockito.mock(RemoteEndpoint.class);
        Mockito.doReturn(remoteEndpointMock).when(sessionMock).getRemote();

        sessionCompletableFuture.complete(sessionMock);
        ConnectionWrapper connectionWrapper =
                new ConnectionWrapper(clientConfiguration, webSocketClient);
        connectionSpy = Mockito.spy(connectionWrapper);
        Mockito.doReturn(1736393892000L).when(connectionSpy).getTimestamp();
        connectionSpy.connect();
        AccountApi accountApi = new AccountApi(connectionSpy);
        api = Mockito.spy(accountApi);
        Mockito.doReturn("eaf3292c-64b6-4c04-ad4f-4ca2608b42b4").when(api).getRequestID();
    }

    /**
     * WebSocket Account Commission Rates
     *
     * <p>Get current account commission rates. Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void accountCommissionTest() throws ApiException, URISyntaxException, IOException {
        AccountCommissionRequest accountCommissionRequest = new AccountCommissionRequest();
        accountCommissionRequest.setSymbol("BTCUSDT");
        CompletableFuture<AccountCommissionResponse> response =
                api.accountCommission(accountCommissionRequest);
        ArgumentCaptor<RequestWrapperDTO<AccountCommissionRequest, AccountCommissionResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<AccountCommissionRequest, AccountCommissionResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        AccountCommissionRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                AccountApiTest.class.getResource(
                        "/expected/api/AccountApi/account.commission-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Unfilled Order Count
     *
     * <p>Query your current unfilled order count for all intervals. Weight: 40
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void accountRateLimitsOrdersTest() throws ApiException, URISyntaxException, IOException {
        AccountRateLimitsOrdersRequest accountRateLimitsOrdersRequest =
                new AccountRateLimitsOrdersRequest();
        CompletableFuture<AccountRateLimitsOrdersResponse> response =
                api.accountRateLimitsOrders(accountRateLimitsOrdersRequest);
        ArgumentCaptor<
                        RequestWrapperDTO<
                                AccountRateLimitsOrdersRequest, AccountRateLimitsOrdersResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<AccountRateLimitsOrdersRequest, AccountRateLimitsOrdersResponse>
                requestWrapperDTO = callArgumentCaptor.getValue();
        AccountRateLimitsOrdersRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                AccountApiTest.class.getResource(
                        "/expected/api/AccountApi/account.rateLimits.orders-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Account information
     *
     * <p>Query information about your account. Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void accountStatusTest() throws ApiException, URISyntaxException, IOException {
        AccountStatusRequest accountStatusRequest = new AccountStatusRequest();
        CompletableFuture<AccountStatusResponse> response = api.accountStatus(accountStatusRequest);
        ArgumentCaptor<RequestWrapperDTO<AccountStatusRequest, AccountStatusResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<AccountStatusRequest, AccountStatusResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        AccountStatusRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                AccountApiTest.class.getResource(
                        "/expected/api/AccountApi/account.status-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Account Order list history
     *
     * <p>Query information about all your order lists, filtered by time range. Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void allOrderListsTest() throws ApiException, URISyntaxException, IOException {
        AllOrderListsRequest allOrderListsRequest = new AllOrderListsRequest();
        CompletableFuture<AllOrderListsResponse> response = api.allOrderLists(allOrderListsRequest);
        ArgumentCaptor<RequestWrapperDTO<AllOrderListsRequest, AllOrderListsResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<AllOrderListsRequest, AllOrderListsResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        AllOrderListsRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                AccountApiTest.class.getResource(
                        "/expected/api/AccountApi/allOrderLists-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Account order history
     *
     * <p>Query information about all your orders – active, canceled, filled – filtered by time
     * range. Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void allOrdersTest() throws ApiException, URISyntaxException, IOException {
        AllOrdersRequest allOrdersRequest = new AllOrdersRequest();
        allOrdersRequest.setSymbol("BTCUSDT");
        CompletableFuture<AllOrdersResponse> response = api.allOrders(allOrdersRequest);
        ArgumentCaptor<RequestWrapperDTO<AllOrdersRequest, AllOrdersResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<AllOrdersRequest, AllOrdersResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        AllOrdersRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                AccountApiTest.class.getResource("/expected/api/AccountApi/allOrders-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Account allocations
     *
     * <p>Retrieves allocations resulting from SOR order placement. Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void myAllocationsTest() throws ApiException, URISyntaxException, IOException {
        MyAllocationsRequest myAllocationsRequest = new MyAllocationsRequest();
        myAllocationsRequest.setSymbol("BTCUSDT");
        CompletableFuture<MyAllocationsResponse> response = api.myAllocations(myAllocationsRequest);
        ArgumentCaptor<RequestWrapperDTO<MyAllocationsRequest, MyAllocationsResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<MyAllocationsRequest, MyAllocationsResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        MyAllocationsRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                AccountApiTest.class.getResource(
                        "/expected/api/AccountApi/myAllocations-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Account prevented matches
     *
     * <p>Displays the list of orders that were expired due to STP. These are the combinations
     * supported: * &#x60;symbol&#x60; + &#x60;preventedMatchId&#x60; * &#x60;symbol&#x60; +
     * &#x60;orderId&#x60; * &#x60;symbol&#x60; + &#x60;orderId&#x60; +
     * &#x60;fromPreventedMatchId&#x60; (&#x60;limit&#x60; will default to 500) * &#x60;symbol&#x60;
     * + &#x60;orderId&#x60; + &#x60;fromPreventedMatchId&#x60; + &#x60;limit&#x60; Weight: Case |
     * Weight ---- | ----- If &#x60;symbol&#x60; is invalid | 2 Querying by
     * &#x60;preventedMatchId&#x60; | 2 Querying by &#x60;orderId&#x60; | 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void myPreventedMatchesTest() throws ApiException, URISyntaxException, IOException {
        MyPreventedMatchesRequest myPreventedMatchesRequest = new MyPreventedMatchesRequest();
        myPreventedMatchesRequest.setSymbol("BTCUSDT");
        CompletableFuture<MyPreventedMatchesResponse> response =
                api.myPreventedMatches(myPreventedMatchesRequest);
        ArgumentCaptor<RequestWrapperDTO<MyPreventedMatchesRequest, MyPreventedMatchesResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<MyPreventedMatchesRequest, MyPreventedMatchesResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        MyPreventedMatchesRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                AccountApiTest.class.getResource(
                        "/expected/api/AccountApi/myPreventedMatches-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * WebSocket Account trade history
     *
     * <p>Query information about all your trades, filtered by time range. Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void myTradesTest() throws ApiException, URISyntaxException, IOException {
        MyTradesRequest myTradesRequest = new MyTradesRequest();
        myTradesRequest.setSymbol("BTCUSDT");
        CompletableFuture<MyTradesResponse> response = api.myTrades(myTradesRequest);
        ArgumentCaptor<RequestWrapperDTO<MyTradesRequest, MyTradesResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<MyTradesRequest, MyTradesResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        MyTradesRequest params = requestWrapperDTO.getParams();
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                AccountApiTest.class.getResource("/expected/api/AccountApi/myTrades-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }
}
