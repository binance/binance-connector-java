/*
 * Binance Spot WebSocket API
 * OpenAPI Specifications for the Binance Spot WebSocket API  API documents:   - [Github web-socket-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-api.md)   - [General API information for web-socket-api on website](https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/general-api-information)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.spot.websocket.api.api;

import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.exception.ConstraintViolationException;
import com.binance.connector.client.common.websocket.adapter.ConnectionInterface;
import com.binance.connector.client.common.websocket.dtos.ApiRequestWrapperDTO;
import com.binance.connector.client.spot.websocket.api.model.AccountCommissionRequest;
import com.binance.connector.client.spot.websocket.api.model.AccountCommissionResponse;
import com.binance.connector.client.spot.websocket.api.model.AccountRateLimitsOrdersRequest;
import com.binance.connector.client.spot.websocket.api.model.AccountRateLimitsOrdersResponse;
import com.binance.connector.client.spot.websocket.api.model.AccountStatusRequest;
import com.binance.connector.client.spot.websocket.api.model.AccountStatusResponse;
import com.binance.connector.client.spot.websocket.api.model.AllOrderListsRequest;
import com.binance.connector.client.spot.websocket.api.model.AllOrderListsResponse;
import com.binance.connector.client.spot.websocket.api.model.AllOrdersRequest;
import com.binance.connector.client.spot.websocket.api.model.AllOrdersResponse;
import com.binance.connector.client.spot.websocket.api.model.MyAllocationsRequest;
import com.binance.connector.client.spot.websocket.api.model.MyAllocationsResponse;
import com.binance.connector.client.spot.websocket.api.model.MyPreventedMatchesRequest;
import com.binance.connector.client.spot.websocket.api.model.MyPreventedMatchesResponse;
import com.binance.connector.client.spot.websocket.api.model.MyTradesRequest;
import com.binance.connector.client.spot.websocket.api.model.MyTradesResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderAmendmentsRequest;
import com.binance.connector.client.spot.websocket.api.model.OrderAmendmentsResponse;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.constraints.*;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator;

public class AccountApi {
    private ConnectionInterface connection;

    public AccountApi() {}

    public AccountApi(ConnectionInterface connection) {
        this.connection = connection;
    }

    /**
     * WebSocket Account Commission Rates Get current account commission rates. Weight: 20
     *
     * @param accountCommissionRequest (required)
     * @return AccountCommissionResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Account Commission Rates </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/account-requests#account-commission-rates-user_data">WebSocket
     *     Account Commission Rates Documentation</a>
     */
    public CompletableFuture<AccountCommissionResponse> accountCommission(
            AccountCommissionRequest accountCommissionRequest) throws ApiException {
        accountCommissionValidateBeforeCall(accountCommissionRequest);
        String methodName = "/account.commission".substring(1);
        ApiRequestWrapperDTO<AccountCommissionRequest, AccountCommissionResponse> build =
                new ApiRequestWrapperDTO.Builder<
                                AccountCommissionRequest, AccountCommissionResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(accountCommissionRequest)
                        .responseType(AccountCommissionResponse.class)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void accountCommissionValidateBeforeCall(
            AccountCommissionRequest accountCommissionRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<AccountCommissionRequest>> violations =
                    validator.validate(accountCommissionRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Unfilled Order Count Query your current unfilled order count for all intervals.
     * Weight: 40
     *
     * @param accountRateLimitsOrdersRequest (required)
     * @return AccountRateLimitsOrdersResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Unfilled Order Count </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/account-requests#unfilled-order-count-user_data">WebSocket
     *     Unfilled Order Count Documentation</a>
     */
    public CompletableFuture<AccountRateLimitsOrdersResponse> accountRateLimitsOrders(
            AccountRateLimitsOrdersRequest accountRateLimitsOrdersRequest) throws ApiException {
        accountRateLimitsOrdersValidateBeforeCall(accountRateLimitsOrdersRequest);
        String methodName = "/account.rateLimits.orders".substring(1);
        ApiRequestWrapperDTO<AccountRateLimitsOrdersRequest, AccountRateLimitsOrdersResponse>
                build =
                        new ApiRequestWrapperDTO.Builder<
                                        AccountRateLimitsOrdersRequest,
                                        AccountRateLimitsOrdersResponse>()
                                .id(getRequestID())
                                .method(methodName)
                                .params(accountRateLimitsOrdersRequest)
                                .responseType(AccountRateLimitsOrdersResponse.class)
                                .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void accountRateLimitsOrdersValidateBeforeCall(
            AccountRateLimitsOrdersRequest accountRateLimitsOrdersRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<AccountRateLimitsOrdersRequest>> violations =
                    validator.validate(accountRateLimitsOrdersRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Account information Query information about your account. Weight: 20
     *
     * @param accountStatusRequest (required)
     * @return AccountStatusResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Account information </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/account-requests#account-information-user_data">WebSocket
     *     Account information Documentation</a>
     */
    public CompletableFuture<AccountStatusResponse> accountStatus(
            AccountStatusRequest accountStatusRequest) throws ApiException {
        accountStatusValidateBeforeCall(accountStatusRequest);
        String methodName = "/account.status".substring(1);
        ApiRequestWrapperDTO<AccountStatusRequest, AccountStatusResponse> build =
                new ApiRequestWrapperDTO.Builder<AccountStatusRequest, AccountStatusResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(accountStatusRequest)
                        .responseType(AccountStatusResponse.class)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void accountStatusValidateBeforeCall(AccountStatusRequest accountStatusRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<AccountStatusRequest>> violations =
                    validator.validate(accountStatusRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Account Order list history Query information about all your order lists, filtered
     * by time range. Weight: 20
     *
     * @param allOrderListsRequest (required)
     * @return AllOrderListsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Account Order list history </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/account-requests#account-order-list-history-user_data">WebSocket
     *     Account Order list history Documentation</a>
     */
    public CompletableFuture<AllOrderListsResponse> allOrderLists(
            AllOrderListsRequest allOrderListsRequest) throws ApiException {
        allOrderListsValidateBeforeCall(allOrderListsRequest);
        String methodName = "/allOrderLists".substring(1);
        ApiRequestWrapperDTO<AllOrderListsRequest, AllOrderListsResponse> build =
                new ApiRequestWrapperDTO.Builder<AllOrderListsRequest, AllOrderListsResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(allOrderListsRequest)
                        .responseType(AllOrderListsResponse.class)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void allOrderListsValidateBeforeCall(AllOrderListsRequest allOrderListsRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<AllOrderListsRequest>> violations =
                    validator.validate(allOrderListsRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Account order history Query information about all your orders – active, canceled,
     * filled – filtered by time range. Weight: 20
     *
     * @param allOrdersRequest (required)
     * @return AllOrdersResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Account order history </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/account-requests#account-order-history-user_data">WebSocket
     *     Account order history Documentation</a>
     */
    public CompletableFuture<AllOrdersResponse> allOrders(AllOrdersRequest allOrdersRequest)
            throws ApiException {
        allOrdersValidateBeforeCall(allOrdersRequest);
        String methodName = "/allOrders".substring(1);
        ApiRequestWrapperDTO<AllOrdersRequest, AllOrdersResponse> build =
                new ApiRequestWrapperDTO.Builder<AllOrdersRequest, AllOrdersResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(allOrdersRequest)
                        .responseType(AllOrdersResponse.class)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void allOrdersValidateBeforeCall(AllOrdersRequest allOrdersRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<AllOrdersRequest>> violations =
                    validator.validate(allOrdersRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Account allocations Retrieves allocations resulting from SOR order placement.
     * Weight: 20
     *
     * @param myAllocationsRequest (required)
     * @return MyAllocationsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Account allocations </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/account-requests#account-allocations-user_data">WebSocket
     *     Account allocations Documentation</a>
     */
    public CompletableFuture<MyAllocationsResponse> myAllocations(
            MyAllocationsRequest myAllocationsRequest) throws ApiException {
        myAllocationsValidateBeforeCall(myAllocationsRequest);
        String methodName = "/myAllocations".substring(1);
        ApiRequestWrapperDTO<MyAllocationsRequest, MyAllocationsResponse> build =
                new ApiRequestWrapperDTO.Builder<MyAllocationsRequest, MyAllocationsResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(myAllocationsRequest)
                        .responseType(MyAllocationsResponse.class)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void myAllocationsValidateBeforeCall(MyAllocationsRequest myAllocationsRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<MyAllocationsRequest>> violations =
                    validator.validate(myAllocationsRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Account prevented matches Displays the list of orders that were expired due to STP.
     * These are the combinations supported: * &#x60;symbol&#x60; + &#x60;preventedMatchId&#x60; *
     * &#x60;symbol&#x60; + &#x60;orderId&#x60; * &#x60;symbol&#x60; + &#x60;orderId&#x60; +
     * &#x60;fromPreventedMatchId&#x60; (&#x60;limit&#x60; will default to 500) * &#x60;symbol&#x60;
     * + &#x60;orderId&#x60; + &#x60;fromPreventedMatchId&#x60; + &#x60;limit&#x60; Weight: Case |
     * Weight ---- | ----- If &#x60;symbol&#x60; is invalid | 2 Querying by
     * &#x60;preventedMatchId&#x60; | 2 Querying by &#x60;orderId&#x60; | 20
     *
     * @param myPreventedMatchesRequest (required)
     * @return MyPreventedMatchesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Account prevented matches </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/account-requests#account-prevented-matches-user_data">WebSocket
     *     Account prevented matches Documentation</a>
     */
    public CompletableFuture<MyPreventedMatchesResponse> myPreventedMatches(
            MyPreventedMatchesRequest myPreventedMatchesRequest) throws ApiException {
        myPreventedMatchesValidateBeforeCall(myPreventedMatchesRequest);
        String methodName = "/myPreventedMatches".substring(1);
        ApiRequestWrapperDTO<MyPreventedMatchesRequest, MyPreventedMatchesResponse> build =
                new ApiRequestWrapperDTO.Builder<
                                MyPreventedMatchesRequest, MyPreventedMatchesResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(myPreventedMatchesRequest)
                        .responseType(MyPreventedMatchesResponse.class)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void myPreventedMatchesValidateBeforeCall(
            MyPreventedMatchesRequest myPreventedMatchesRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<MyPreventedMatchesRequest>> violations =
                    validator.validate(myPreventedMatchesRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Account trade history Query information about all your trades, filtered by time
     * range. Weight: Condition| Weight| ---| --- |Without orderId|20| |With orderId|5|
     *
     * @param myTradesRequest (required)
     * @return MyTradesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Account trade history </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/account-requests#account-trade-history-user_data">WebSocket
     *     Account trade history Documentation</a>
     */
    public CompletableFuture<MyTradesResponse> myTrades(MyTradesRequest myTradesRequest)
            throws ApiException {
        myTradesValidateBeforeCall(myTradesRequest);
        String methodName = "/myTrades".substring(1);
        ApiRequestWrapperDTO<MyTradesRequest, MyTradesResponse> build =
                new ApiRequestWrapperDTO.Builder<MyTradesRequest, MyTradesResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(myTradesRequest)
                        .responseType(MyTradesResponse.class)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void myTradesValidateBeforeCall(MyTradesRequest myTradesRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<MyTradesRequest>> violations =
                    validator.validate(myTradesRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Query Order Amendments Queries all amendments of a single order. Weight: 4
     *
     * @param orderAmendmentsRequest (required)
     * @return OrderAmendmentsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Query Order Amendments </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/account-requests#query-order-amendments-user_data">WebSocket
     *     Query Order Amendments Documentation</a>
     */
    public CompletableFuture<OrderAmendmentsResponse> orderAmendments(
            OrderAmendmentsRequest orderAmendmentsRequest) throws ApiException {
        orderAmendmentsValidateBeforeCall(orderAmendmentsRequest);
        String methodName = "/order.amendments".substring(1);
        ApiRequestWrapperDTO<OrderAmendmentsRequest, OrderAmendmentsResponse> build =
                new ApiRequestWrapperDTO.Builder<OrderAmendmentsRequest, OrderAmendmentsResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(orderAmendmentsRequest)
                        .responseType(OrderAmendmentsResponse.class)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void orderAmendmentsValidateBeforeCall(OrderAmendmentsRequest orderAmendmentsRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<OrderAmendmentsRequest>> violations =
                    validator.validate(orderAmendmentsRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    public String getRequestID() {
        return UUID.randomUUID().toString();
    }
}
