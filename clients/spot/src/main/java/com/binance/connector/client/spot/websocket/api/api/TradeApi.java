/*
 * Binance Spot WebSocket API
 * OpenAPI Specifications for the Binance Spot WebSocket API  API documents:   - [Github web-socket-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-api.md)   - [General API information for web-socket-api on website](https://developers.binance.com/docs/binance-spot-api-docs/web-socket-api/general-api-information)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.spot.websocket.api.api;

import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.exception.ConstraintViolationException;
import com.binance.connector.client.common.websocket.adapter.ConnectionInterface;
import com.binance.connector.client.common.websocket.dtos.ApiRequestWrapperDTO;
import com.binance.connector.client.spot.websocket.api.model.OpenOrdersCancelAllRequest;
import com.binance.connector.client.spot.websocket.api.model.OpenOrdersCancelAllResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderAmendKeepPriorityRequest;
import com.binance.connector.client.spot.websocket.api.model.OrderAmendKeepPriorityResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderCancelReplaceRequest;
import com.binance.connector.client.spot.websocket.api.model.OrderCancelReplaceResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderCancelRequest;
import com.binance.connector.client.spot.websocket.api.model.OrderCancelResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderListCancelRequest;
import com.binance.connector.client.spot.websocket.api.model.OrderListCancelResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderListPlaceOcoRequest;
import com.binance.connector.client.spot.websocket.api.model.OrderListPlaceOcoResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderListPlaceOpoRequest;
import com.binance.connector.client.spot.websocket.api.model.OrderListPlaceOpoResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderListPlaceOpocoRequest;
import com.binance.connector.client.spot.websocket.api.model.OrderListPlaceOpocoResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderListPlaceOtoRequest;
import com.binance.connector.client.spot.websocket.api.model.OrderListPlaceOtoResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderListPlaceOtocoRequest;
import com.binance.connector.client.spot.websocket.api.model.OrderListPlaceOtocoResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderListPlaceRequest;
import com.binance.connector.client.spot.websocket.api.model.OrderListPlaceResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderPlaceRequest;
import com.binance.connector.client.spot.websocket.api.model.OrderPlaceResponse;
import com.binance.connector.client.spot.websocket.api.model.OrderTestRequest;
import com.binance.connector.client.spot.websocket.api.model.OrderTestResponse;
import com.binance.connector.client.spot.websocket.api.model.SorOrderPlaceRequest;
import com.binance.connector.client.spot.websocket.api.model.SorOrderPlaceResponse;
import com.binance.connector.client.spot.websocket.api.model.SorOrderTestRequest;
import com.binance.connector.client.spot.websocket.api.model.SorOrderTestResponse;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.constraints.*;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator;

public class TradeApi {
    private ConnectionInterface connection;

    public TradeApi() {}

    public TradeApi(ConnectionInterface connection) {
        this.connection = connection;
    }

    /**
     * WebSocket Cancel open orders Cancel all open orders on a symbol. This includes orders that
     * are part of an order list. Weight: 1
     *
     * @param openOrdersCancelAllRequest (required)
     * @return OpenOrdersCancelAllResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cancel open orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#cancel-open-orders-trade">WebSocket
     *     Cancel open orders Documentation</a>
     */
    public CompletableFuture<OpenOrdersCancelAllResponse> openOrdersCancelAll(
            OpenOrdersCancelAllRequest openOrdersCancelAllRequest) throws ApiException {
        openOrdersCancelAllValidateBeforeCall(openOrdersCancelAllRequest);
        String methodName = "/openOrders.cancelAll".substring(1);
        ApiRequestWrapperDTO<OpenOrdersCancelAllRequest, OpenOrdersCancelAllResponse> build =
                new ApiRequestWrapperDTO.Builder<
                                OpenOrdersCancelAllRequest, OpenOrdersCancelAllResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(openOrdersCancelAllRequest)
                        .responseType(OpenOrdersCancelAllResponse.class)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void openOrdersCancelAllValidateBeforeCall(
            OpenOrdersCancelAllRequest openOrdersCancelAllRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<OpenOrdersCancelAllRequest>> violations =
                    validator.validate(openOrdersCancelAllRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Order Amend Keep Priority Reduce the quantity of an existing open order. This adds
     * 0 orders to the &#x60;EXCHANGE_MAX_ORDERS&#x60; filter and the &#x60;MAX_NUM_ORDERS&#x60;
     * filter. Read [Order Amend Keep Priority FAQ](faqs/order_amend_keep_priority.md) to learn
     * more. Weight: 4
     *
     * @param orderAmendKeepPriorityRequest (required)
     * @return OrderAmendKeepPriorityResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Order Amend Keep Priority </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#order-amend-keep-priority-trade">WebSocket
     *     Order Amend Keep Priority Documentation</a>
     */
    public CompletableFuture<OrderAmendKeepPriorityResponse> orderAmendKeepPriority(
            OrderAmendKeepPriorityRequest orderAmendKeepPriorityRequest) throws ApiException {
        orderAmendKeepPriorityValidateBeforeCall(orderAmendKeepPriorityRequest);
        String methodName = "/order.amend.keepPriority".substring(1);
        ApiRequestWrapperDTO<OrderAmendKeepPriorityRequest, OrderAmendKeepPriorityResponse> build =
                new ApiRequestWrapperDTO.Builder<
                                OrderAmendKeepPriorityRequest, OrderAmendKeepPriorityResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(orderAmendKeepPriorityRequest)
                        .responseType(OrderAmendKeepPriorityResponse.class)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void orderAmendKeepPriorityValidateBeforeCall(
            OrderAmendKeepPriorityRequest orderAmendKeepPriorityRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<OrderAmendKeepPriorityRequest>> violations =
                    validator.validate(orderAmendKeepPriorityRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Cancel order Cancel an active order. Weight: 1
     *
     * @param orderCancelRequest (required)
     * @return OrderCancelResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cancel order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#cancel-order-trade">WebSocket
     *     Cancel order Documentation</a>
     */
    public CompletableFuture<OrderCancelResponse> orderCancel(OrderCancelRequest orderCancelRequest)
            throws ApiException {
        orderCancelValidateBeforeCall(orderCancelRequest);
        String methodName = "/order.cancel".substring(1);
        ApiRequestWrapperDTO<OrderCancelRequest, OrderCancelResponse> build =
                new ApiRequestWrapperDTO.Builder<OrderCancelRequest, OrderCancelResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(orderCancelRequest)
                        .responseType(OrderCancelResponse.class)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void orderCancelValidateBeforeCall(OrderCancelRequest orderCancelRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<OrderCancelRequest>> violations =
                    validator.validate(orderCancelRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Cancel and replace order Cancel an existing order and immediately place a new order
     * instead of the canceled one. A new order that was not attempted (i.e. when
     * &#x60;newOrderResult: NOT_ATTEMPTED&#x60;), will still increase the unfilled order count by
     * 1. Weight: 1
     *
     * @param orderCancelReplaceRequest (required)
     * @return OrderCancelReplaceResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cancel and replace order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#cancel-and-replace-order-trade">WebSocket
     *     Cancel and replace order Documentation</a>
     */
    public CompletableFuture<OrderCancelReplaceResponse> orderCancelReplace(
            OrderCancelReplaceRequest orderCancelReplaceRequest) throws ApiException {
        orderCancelReplaceValidateBeforeCall(orderCancelReplaceRequest);
        String methodName = "/order.cancelReplace".substring(1);
        ApiRequestWrapperDTO<OrderCancelReplaceRequest, OrderCancelReplaceResponse> build =
                new ApiRequestWrapperDTO.Builder<
                                OrderCancelReplaceRequest, OrderCancelReplaceResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(orderCancelReplaceRequest)
                        .responseType(OrderCancelReplaceResponse.class)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void orderCancelReplaceValidateBeforeCall(
            OrderCancelReplaceRequest orderCancelReplaceRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<OrderCancelReplaceRequest>> violations =
                    validator.validate(orderCancelReplaceRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Cancel Order list Cancel an active order list. Weight: 1
     *
     * @param orderListCancelRequest (required)
     * @return OrderListCancelResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cancel Order list </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#cancel-order-list-trade">WebSocket
     *     Cancel Order list Documentation</a>
     */
    public CompletableFuture<OrderListCancelResponse> orderListCancel(
            OrderListCancelRequest orderListCancelRequest) throws ApiException {
        orderListCancelValidateBeforeCall(orderListCancelRequest);
        String methodName = "/orderList.cancel".substring(1);
        ApiRequestWrapperDTO<OrderListCancelRequest, OrderListCancelResponse> build =
                new ApiRequestWrapperDTO.Builder<OrderListCancelRequest, OrderListCancelResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(orderListCancelRequest)
                        .responseType(OrderListCancelResponse.class)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void orderListCancelValidateBeforeCall(OrderListCancelRequest orderListCancelRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<OrderListCancelRequest>> violations =
                    validator.validate(orderListCancelRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Place new OCO - Deprecated Send in a new one-cancels-the-other (OCO) pair:
     * &#x60;LIMIT_MAKER&#x60; + &#x60;STOP_LOSS&#x60;/&#x60;STOP_LOSS_LIMIT&#x60; orders (called
     * *legs*), where activation of one order immediately cancels the other. This adds 1 order to
     * &#x60;EXCHANGE_MAX_ORDERS&#x60; filter and the &#x60;MAX_NUM_ORDERS&#x60; filter Weight: 1
     * Unfilled Order Count: 1
     *
     * @param orderListPlaceRequest (required)
     * @return OrderListPlaceResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Place new OCO - Deprecated </td><td>  -  </td></tr>
     * </table>
     *
     * @deprecated
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#place-new-oco---deprecated-trade">WebSocket
     *     Place new OCO - Deprecated Documentation</a>
     */
    @Deprecated
    public CompletableFuture<OrderListPlaceResponse> orderListPlace(
            OrderListPlaceRequest orderListPlaceRequest) throws ApiException {
        orderListPlaceValidateBeforeCall(orderListPlaceRequest);
        String methodName = "/orderList.place".substring(1);
        ApiRequestWrapperDTO<OrderListPlaceRequest, OrderListPlaceResponse> build =
                new ApiRequestWrapperDTO.Builder<OrderListPlaceRequest, OrderListPlaceResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(orderListPlaceRequest)
                        .responseType(OrderListPlaceResponse.class)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private void orderListPlaceValidateBeforeCall(OrderListPlaceRequest orderListPlaceRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<OrderListPlaceRequest>> violations =
                    validator.validate(orderListPlaceRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Place new Order list - OCO Send in an one-cancels-the-other (OCO) pair, where
     * activation of one order immediately cancels the other. * An OCO has 2 orders called the
     * **above order** and **below order**. * One of the orders must be a
     * &#x60;LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT&#x60; order and the other must be
     * &#x60;STOP_LOSS&#x60; or &#x60;STOP_LOSS_LIMIT&#x60; order. * Price restrictions: * If the
     * OCO is on the &#x60;SELL&#x60; side: * &#x60;LIMIT_MAKER/TAKE_PROFIT_LIMIT&#x60;
     * &#x60;price&#x60; &gt; Last Traded Price &gt; &#x60;STOP_LOSS/STOP_LOSS_LIMIT&#x60;
     * &#x60;stopPrice&#x60; * &#x60;TAKE_PROFIT stopPrice&#x60; &gt; Last Traded Price &gt;
     * &#x60;STOP_LOSS/STOP_LOSS_LIMIT stopPrice&#x60; * If the OCO is on the &#x60;BUY&#x60; side:
     * * &#x60;LIMIT_MAKER&#x60; &#x60;price&#x60; &lt; Last Traded Price &lt;
     * &#x60;STOP_LOSS/STOP_LOSS_LIMIT&#x60; &#x60;stopPrice&#x60; * &#x60;TAKE_PROFIT
     * stopPrice&#x60; &gt; Last Traded Price &gt; &#x60;STOP_LOSS/STOP_LOSS_LIMIT stopPrice&#x60; *
     * OCOs add **2 orders** to the &#x60;EXCHANGE_MAX_ORDERS&#x60; filter and
     * &#x60;MAX_NUM_ORDERS&#x60; filter. Weight: 1 Unfilled Order Count: 2
     *
     * @param orderListPlaceOcoRequest (required)
     * @return OrderListPlaceOcoResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Place new Order list - OCO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#place-new-order-list---oco-trade">WebSocket
     *     Place new Order list - OCO Documentation</a>
     */
    public CompletableFuture<OrderListPlaceOcoResponse> orderListPlaceOco(
            OrderListPlaceOcoRequest orderListPlaceOcoRequest) throws ApiException {
        orderListPlaceOcoValidateBeforeCall(orderListPlaceOcoRequest);
        String methodName = "/orderList.place.oco".substring(1);
        ApiRequestWrapperDTO<OrderListPlaceOcoRequest, OrderListPlaceOcoResponse> build =
                new ApiRequestWrapperDTO.Builder<
                                OrderListPlaceOcoRequest, OrderListPlaceOcoResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(orderListPlaceOcoRequest)
                        .responseType(OrderListPlaceOcoResponse.class)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void orderListPlaceOcoValidateBeforeCall(
            OrderListPlaceOcoRequest orderListPlaceOcoRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<OrderListPlaceOcoRequest>> violations =
                    validator.validate(orderListPlaceOcoRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket OPO Place an [OPO](./faqs/opo.md). * OPOs add 2 orders to the
     * EXCHANGE_MAX_NUM_ORDERS filter and MAX_NUM_ORDERS filter. Weight: 1 Unfilled Order Count: 2
     *
     * @param orderListPlaceOpoRequest (required)
     * @return OrderListPlaceOpoResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OPO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#opo-trade">WebSocket
     *     OPO Documentation</a>
     */
    public CompletableFuture<OrderListPlaceOpoResponse> orderListPlaceOpo(
            OrderListPlaceOpoRequest orderListPlaceOpoRequest) throws ApiException {
        orderListPlaceOpoValidateBeforeCall(orderListPlaceOpoRequest);
        String methodName = "/orderList.place.opo".substring(1);
        ApiRequestWrapperDTO<OrderListPlaceOpoRequest, OrderListPlaceOpoResponse> build =
                new ApiRequestWrapperDTO.Builder<
                                OrderListPlaceOpoRequest, OrderListPlaceOpoResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(orderListPlaceOpoRequest)
                        .responseType(OrderListPlaceOpoResponse.class)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void orderListPlaceOpoValidateBeforeCall(
            OrderListPlaceOpoRequest orderListPlaceOpoRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<OrderListPlaceOpoRequest>> violations =
                    validator.validate(orderListPlaceOpoRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket OPOCO Place an [OPOCO](./faqs/opo.md). Weight: 1 Unfilled Order Count: 3
     *
     * @param orderListPlaceOpocoRequest (required)
     * @return OrderListPlaceOpocoResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OPOCO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#opoco-trade">WebSocket
     *     OPOCO Documentation</a>
     */
    public CompletableFuture<OrderListPlaceOpocoResponse> orderListPlaceOpoco(
            OrderListPlaceOpocoRequest orderListPlaceOpocoRequest) throws ApiException {
        orderListPlaceOpocoValidateBeforeCall(orderListPlaceOpocoRequest);
        String methodName = "/orderList.place.opoco".substring(1);
        ApiRequestWrapperDTO<OrderListPlaceOpocoRequest, OrderListPlaceOpocoResponse> build =
                new ApiRequestWrapperDTO.Builder<
                                OrderListPlaceOpocoRequest, OrderListPlaceOpocoResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(orderListPlaceOpocoRequest)
                        .responseType(OrderListPlaceOpocoResponse.class)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void orderListPlaceOpocoValidateBeforeCall(
            OrderListPlaceOpocoRequest orderListPlaceOpocoRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<OrderListPlaceOpocoRequest>> violations =
                    validator.validate(orderListPlaceOpocoRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Place new Order list - OTO Places an OTO. * An OTO (One-Triggers-the-Other) is an
     * order list comprised of 2 orders. * The first order is called the **working order** and must
     * be &#x60;LIMIT&#x60; or &#x60;LIMIT_MAKER&#x60;. Initially, only the working order goes on
     * the order book. * The second order is called the **pending order**. It can be any order type
     * except for &#x60;MARKET&#x60; orders using parameter &#x60;quoteOrderQty&#x60;. The pending
     * order is only placed on the order book when the working order gets **fully filled**. * If
     * either the working order or the pending order is cancelled individually, the other order in
     * the order list will also be canceled or expired. * When the order list is placed, if the
     * working order gets **immediately fully filled**, the placement response will show the working
     * order as &#x60;FILLED&#x60; but the pending order will still appear as
     * &#x60;PENDING_NEW&#x60;. You need to query the status of the pending order again to see its
     * updated status. * OTOs add **2 orders** to the &#x60;EXCHANGE_MAX_NUM_ORDERS&#x60; filter and
     * &#x60;MAX_NUM_ORDERS&#x60; filter. Weight: 1 Unfilled Order Count: 2
     *
     * @param orderListPlaceOtoRequest (required)
     * @return OrderListPlaceOtoResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Place new Order list - OTO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#place-new-order-list---oto-trade">WebSocket
     *     Place new Order list - OTO Documentation</a>
     */
    public CompletableFuture<OrderListPlaceOtoResponse> orderListPlaceOto(
            OrderListPlaceOtoRequest orderListPlaceOtoRequest) throws ApiException {
        orderListPlaceOtoValidateBeforeCall(orderListPlaceOtoRequest);
        String methodName = "/orderList.place.oto".substring(1);
        ApiRequestWrapperDTO<OrderListPlaceOtoRequest, OrderListPlaceOtoResponse> build =
                new ApiRequestWrapperDTO.Builder<
                                OrderListPlaceOtoRequest, OrderListPlaceOtoResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(orderListPlaceOtoRequest)
                        .responseType(OrderListPlaceOtoResponse.class)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void orderListPlaceOtoValidateBeforeCall(
            OrderListPlaceOtoRequest orderListPlaceOtoRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<OrderListPlaceOtoRequest>> violations =
                    validator.validate(orderListPlaceOtoRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Place new Order list - OTOCO Place an OTOCO. * An OTOCO
     * (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders. * The first
     * order is called the **working order** and must be &#x60;LIMIT&#x60; or
     * &#x60;LIMIT_MAKER&#x60;. Initially, only the working order goes on the order book. * The
     * behavior of the working order is the same as the [OTO](#place-new-order-list---oto-trade). *
     * OTOCO has 2 pending orders (pending above and pending below), forming an OCO pair. The
     * pending orders are only placed on the order book when the working order gets **fully
     * filled**. * The rules of the pending above and pending below follow the same rules as the
     * [Order list OCO](#new-order-list---oco-trade). * OTOCOs add **3 orders** to the
     * &#x60;EXCHANGE_MAX_NUM_ORDERS&#x60; filter and &#x60;MAX_NUM_ORDERS&#x60; filter. Weight: 1
     * Unfilled Order Count: 3
     *
     * @param orderListPlaceOtocoRequest (required)
     * @return OrderListPlaceOtocoResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Place new Order list - OTOCO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#place-new-order-list---otoco-trade">WebSocket
     *     Place new Order list - OTOCO Documentation</a>
     */
    public CompletableFuture<OrderListPlaceOtocoResponse> orderListPlaceOtoco(
            OrderListPlaceOtocoRequest orderListPlaceOtocoRequest) throws ApiException {
        orderListPlaceOtocoValidateBeforeCall(orderListPlaceOtocoRequest);
        String methodName = "/orderList.place.otoco".substring(1);
        ApiRequestWrapperDTO<OrderListPlaceOtocoRequest, OrderListPlaceOtocoResponse> build =
                new ApiRequestWrapperDTO.Builder<
                                OrderListPlaceOtocoRequest, OrderListPlaceOtocoResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(orderListPlaceOtocoRequest)
                        .responseType(OrderListPlaceOtocoResponse.class)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void orderListPlaceOtocoValidateBeforeCall(
            OrderListPlaceOtocoRequest orderListPlaceOtocoRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<OrderListPlaceOtocoRequest>> violations =
                    validator.validate(orderListPlaceOtocoRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Place new order Send in a new order. This adds 1 order to the
     * &#x60;EXCHANGE_MAX_ORDERS&#x60; filter and the &#x60;MAX_NUM_ORDERS&#x60; filter. Weight: 1
     *
     * @param orderPlaceRequest (required)
     * @return OrderPlaceResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Place new order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#place-new-order-trade">WebSocket
     *     Place new order Documentation</a>
     */
    public CompletableFuture<OrderPlaceResponse> orderPlace(OrderPlaceRequest orderPlaceRequest)
            throws ApiException {
        orderPlaceValidateBeforeCall(orderPlaceRequest);
        String methodName = "/order.place".substring(1);
        ApiRequestWrapperDTO<OrderPlaceRequest, OrderPlaceResponse> build =
                new ApiRequestWrapperDTO.Builder<OrderPlaceRequest, OrderPlaceResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(orderPlaceRequest)
                        .responseType(OrderPlaceResponse.class)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void orderPlaceValidateBeforeCall(OrderPlaceRequest orderPlaceRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<OrderPlaceRequest>> violations =
                    validator.validate(orderPlaceRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Test new order Test order placement. Validates new order parameters and verifies
     * your signature but does not send the order into the matching engine. Weight: |Condition|
     * Request Weight| |------------ | ------------ | |Without &#x60;computeCommissionRates&#x60;|
     * 1| |With &#x60;computeCommissionRates&#x60;|20|
     *
     * @param orderTestRequest (required)
     * @return OrderTestResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Test new order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#test-new-order-trade">WebSocket
     *     Test new order Documentation</a>
     */
    public CompletableFuture<OrderTestResponse> orderTest(OrderTestRequest orderTestRequest)
            throws ApiException {
        orderTestValidateBeforeCall(orderTestRequest);
        String methodName = "/order.test".substring(1);
        ApiRequestWrapperDTO<OrderTestRequest, OrderTestResponse> build =
                new ApiRequestWrapperDTO.Builder<OrderTestRequest, OrderTestResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(orderTestRequest)
                        .responseType(OrderTestResponse.class)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void orderTestValidateBeforeCall(OrderTestRequest orderTestRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<OrderTestRequest>> violations =
                    validator.validate(orderTestRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Place new order using SOR Places an order using smart order routing (SOR). This
     * adds 1 order to the &#x60;EXCHANGE_MAX_ORDERS&#x60; filter and the &#x60;MAX_NUM_ORDERS&#x60;
     * filter. Read [SOR FAQ](../faqs/sor_faq.md) to learn more. Weight: 1 Unfilled Order Count: 1
     *
     * @param sorOrderPlaceRequest (required)
     * @return SorOrderPlaceResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Place new order using SOR </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#place-new-order-using-sor-trade">WebSocket
     *     Place new order using SOR Documentation</a>
     */
    public CompletableFuture<SorOrderPlaceResponse> sorOrderPlace(
            SorOrderPlaceRequest sorOrderPlaceRequest) throws ApiException {
        sorOrderPlaceValidateBeforeCall(sorOrderPlaceRequest);
        String methodName = "/sor.order.place".substring(1);
        ApiRequestWrapperDTO<SorOrderPlaceRequest, SorOrderPlaceResponse> build =
                new ApiRequestWrapperDTO.Builder<SorOrderPlaceRequest, SorOrderPlaceResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(sorOrderPlaceRequest)
                        .responseType(SorOrderPlaceResponse.class)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void sorOrderPlaceValidateBeforeCall(SorOrderPlaceRequest sorOrderPlaceRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<SorOrderPlaceRequest>> violations =
                    validator.validate(sorOrderPlaceRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Test new order using SOR Test new order creation and signature/recvWindow using
     * smart order routing (SOR). Creates and validates a new order but does not send it into the
     * matching engine. Weight: |Condition | Request Weight| |------------ | ------------ | |Without
     * &#x60;computeCommissionRates&#x60;| 1 | |With &#x60;computeCommissionRates&#x60; |20 |
     *
     * @param sorOrderTestRequest (required)
     * @return SorOrderTestResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Test new order using SOR </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/trading-requests#test-new-order-using-sor-trade">WebSocket
     *     Test new order using SOR Documentation</a>
     */
    public CompletableFuture<SorOrderTestResponse> sorOrderTest(
            SorOrderTestRequest sorOrderTestRequest) throws ApiException {
        sorOrderTestValidateBeforeCall(sorOrderTestRequest);
        String methodName = "/sor.order.test".substring(1);
        ApiRequestWrapperDTO<SorOrderTestRequest, SorOrderTestResponse> build =
                new ApiRequestWrapperDTO.Builder<SorOrderTestRequest, SorOrderTestResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(sorOrderTestRequest)
                        .responseType(SorOrderTestResponse.class)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void sorOrderTestValidateBeforeCall(SorOrderTestRequest sorOrderTestRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<SorOrderTestRequest>> violations =
                    validator.validate(sorOrderTestRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    public String getRequestID() {
        return UUID.randomUUID().toString();
    }
}
