/*
 * Binance Spot WebSocket Streams
 * OpenAPI Specifications for the Binance Spot WebSocket Streams  API documents:   - [Github web-socket-streams documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-streams.md)   - [General API information for web-socket-streams on website](https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.spot.websocket.stream.api;

import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.exception.ConstraintViolationException;
import com.binance.connector.client.common.websocket.adapter.stream.StreamConnectionInterface;
import com.binance.connector.client.common.websocket.dtos.RequestWrapperDTO;
import com.binance.connector.client.common.websocket.service.StreamBlockingQueue;
import com.binance.connector.client.common.websocket.service.StreamBlockingQueueWrapper;
import com.binance.connector.client.spot.websocket.stream.model.AggTradeRequest;
import com.binance.connector.client.spot.websocket.stream.model.AggTradeResponse;
import com.binance.connector.client.spot.websocket.stream.model.AllMarketRollingWindowTickerRequest;
import com.binance.connector.client.spot.websocket.stream.model.AllMarketRollingWindowTickerResponse;
import com.binance.connector.client.spot.websocket.stream.model.AllMiniTickerResponse;
import com.binance.connector.client.spot.websocket.stream.model.AvgPriceRequest;
import com.binance.connector.client.spot.websocket.stream.model.AvgPriceResponse;
import com.binance.connector.client.spot.websocket.stream.model.BookTickerRequest;
import com.binance.connector.client.spot.websocket.stream.model.BookTickerResponse;
import com.binance.connector.client.spot.websocket.stream.model.DiffBookDepthRequest;
import com.binance.connector.client.spot.websocket.stream.model.DiffBookDepthResponse;
import com.binance.connector.client.spot.websocket.stream.model.KlineOffsetRequest;
import com.binance.connector.client.spot.websocket.stream.model.KlineOffsetResponse;
import com.binance.connector.client.spot.websocket.stream.model.KlineRequest;
import com.binance.connector.client.spot.websocket.stream.model.KlineResponse;
import com.binance.connector.client.spot.websocket.stream.model.MiniTickerRequest;
import com.binance.connector.client.spot.websocket.stream.model.MiniTickerResponse;
import com.binance.connector.client.spot.websocket.stream.model.PartialBookDepthRequest;
import com.binance.connector.client.spot.websocket.stream.model.PartialBookDepthResponse;
import com.binance.connector.client.spot.websocket.stream.model.RollingWindowTickerRequest;
import com.binance.connector.client.spot.websocket.stream.model.RollingWindowTickerResponse;
import com.binance.connector.client.spot.websocket.stream.model.TickerRequest;
import com.binance.connector.client.spot.websocket.stream.model.TickerResponse;
import com.binance.connector.client.spot.websocket.stream.model.TradeRequest;
import com.binance.connector.client.spot.websocket.stream.model.TradeResponse;
import com.google.gson.reflect.TypeToken;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.constraints.*;
import java.util.Collections;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator;

public class WebSocketStreamsApi {
    private StreamConnectionInterface connection;

    public WebSocketStreamsApi() {}

    public WebSocketStreamsApi(StreamConnectionInterface connection) {
        this.connection = connection;
    }

    /**
     * WebSocket Aggregate Trade Streams The Aggregate Trade Streams push trade information that is
     * aggregated for a single taker order.
     *
     * @param aggTradeRequest (required)
     * @return AggTradeResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Aggregate Trade Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#aggregate-trade-streams">WebSocket
     *     Aggregate Trade Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<AggTradeResponse> aggTrade(AggTradeRequest aggTradeRequest)
            throws ApiException {
        StreamBlockingQueue<String> queue = aggTradeRaw(aggTradeRequest);

        TypeToken<AggTradeResponse> typeToken = new TypeToken<AggTradeResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> aggTradeRaw(AggTradeRequest aggTradeRequest)
            throws ApiException {
        aggTradeValidateBeforeCall(aggTradeRequest);

        String methodName =
                "/<symbol>@aggTrade"
                        .substring(1)
                        .replace(
                                "<symbol>",
                                aggTradeRequest.getSymbol() != null
                                        ? aggTradeRequest.getSymbol().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void aggTradeValidateBeforeCall(AggTradeRequest aggTradeRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<AggTradeRequest>> violations =
                    validator.validate(aggTradeRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket All Market Rolling Window Statistics Streams Rolling window ticker statistics for
     * all market symbols, computed over multiple windows. Note that only tickers that have changed
     * will be present in the array.
     *
     * @param allMarketRollingWindowTickerRequest (required)
     * @return AllMarketRollingWindowTickerResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> All Market Rolling Window Statistics Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#all-market-rolling-window-statistics-streams">WebSocket
     *     All Market Rolling Window Statistics Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<AllMarketRollingWindowTickerResponse>
            allMarketRollingWindowTicker(
                    AllMarketRollingWindowTickerRequest allMarketRollingWindowTickerRequest)
                    throws ApiException {
        StreamBlockingQueue<String> queue =
                allMarketRollingWindowTickerRaw(allMarketRollingWindowTickerRequest);

        TypeToken<AllMarketRollingWindowTickerResponse> typeToken =
                new TypeToken<AllMarketRollingWindowTickerResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> allMarketRollingWindowTickerRaw(
            AllMarketRollingWindowTickerRequest allMarketRollingWindowTickerRequest)
            throws ApiException {
        allMarketRollingWindowTickerValidateBeforeCall(allMarketRollingWindowTickerRequest);

        String methodName =
                "/!ticker_<windowSize>@arr"
                        .substring(1)
                        .replace(
                                "<windowSize>",
                                allMarketRollingWindowTickerRequest.getWindowSize() != null
                                        ? allMarketRollingWindowTickerRequest
                                                .getWindowSize()
                                                .toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void allMarketRollingWindowTickerValidateBeforeCall(
            AllMarketRollingWindowTickerRequest allMarketRollingWindowTickerRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<AllMarketRollingWindowTickerRequest>> violations =
                    validator.validate(allMarketRollingWindowTickerRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket All Market Mini Tickers Stream 24hr rolling window mini-ticker statistics for all
     * symbols that changed in an array. These are NOT the statistics of the UTC day, but a 24hr
     * rolling window for the previous 24hrs. Note that only tickers that have changed will be
     * present in the array.
     *
     * @return AllMiniTickerResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> All Market Mini Tickers Stream </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#all-market-mini-tickers-stream">WebSocket
     *     All Market Mini Tickers Stream Documentation</a>
     */
    public StreamBlockingQueueWrapper<AllMiniTickerResponse> allMiniTicker() throws ApiException {
        StreamBlockingQueue<String> queue = allMiniTickerRaw();

        TypeToken<AllMiniTickerResponse> typeToken = new TypeToken<AllMiniTickerResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> allMiniTickerRaw() throws ApiException {
        allMiniTickerValidateBeforeCall();

        String methodName = "/!miniTicker@arr".substring(1);
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void allMiniTickerValidateBeforeCall() throws ApiException {}

    /**
     * WebSocket Average Price Average price streams push changes in the average price over a fixed
     * time interval.
     *
     * @param avgPriceRequest (required)
     * @return AvgPriceResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Average Price </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#average-price">WebSocket
     *     Average Price Documentation</a>
     */
    public StreamBlockingQueueWrapper<AvgPriceResponse> avgPrice(AvgPriceRequest avgPriceRequest)
            throws ApiException {
        StreamBlockingQueue<String> queue = avgPriceRaw(avgPriceRequest);

        TypeToken<AvgPriceResponse> typeToken = new TypeToken<AvgPriceResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> avgPriceRaw(AvgPriceRequest avgPriceRequest)
            throws ApiException {
        avgPriceValidateBeforeCall(avgPriceRequest);

        String methodName =
                "/<symbol>@avgPrice"
                        .substring(1)
                        .replace(
                                "<symbol>",
                                avgPriceRequest.getSymbol() != null
                                        ? avgPriceRequest.getSymbol().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void avgPriceValidateBeforeCall(AvgPriceRequest avgPriceRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<AvgPriceRequest>> violations =
                    validator.validate(avgPriceRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Individual Symbol Book Ticker Streams Pushes any update to the best bid or
     * ask&#39;s price or quantity in real-time for a specified symbol. Multiple
     * &#x60;&lt;symbol&gt;@bookTicker&#x60; streams can be subscribed to over one connection.
     *
     * @param bookTickerRequest (required)
     * @return BookTickerResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Individual Symbol Book Ticker Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-book-ticker-streams">WebSocket
     *     Individual Symbol Book Ticker Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<BookTickerResponse> bookTicker(
            BookTickerRequest bookTickerRequest) throws ApiException {
        StreamBlockingQueue<String> queue = bookTickerRaw(bookTickerRequest);

        TypeToken<BookTickerResponse> typeToken = new TypeToken<BookTickerResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> bookTickerRaw(BookTickerRequest bookTickerRequest)
            throws ApiException {
        bookTickerValidateBeforeCall(bookTickerRequest);

        String methodName =
                "/<symbol>@bookTicker"
                        .substring(1)
                        .replace(
                                "<symbol>",
                                bookTickerRequest.getSymbol() != null
                                        ? bookTickerRequest.getSymbol().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void bookTickerValidateBeforeCall(BookTickerRequest bookTickerRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<BookTickerRequest>> violations =
                    validator.validate(bookTickerRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Diff. Depth Stream Order book price and quantity depth updates used to locally
     * manage an order book.
     *
     * @param diffBookDepthRequest (required)
     * @return DiffBookDepthResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Diff. Depth Stream </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#diff-depth-stream">WebSocket
     *     Diff. Depth Stream Documentation</a>
     */
    public StreamBlockingQueueWrapper<DiffBookDepthResponse> diffBookDepth(
            DiffBookDepthRequest diffBookDepthRequest) throws ApiException {
        StreamBlockingQueue<String> queue = diffBookDepthRaw(diffBookDepthRequest);

        TypeToken<DiffBookDepthResponse> typeToken = new TypeToken<DiffBookDepthResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> diffBookDepthRaw(DiffBookDepthRequest diffBookDepthRequest)
            throws ApiException {
        diffBookDepthValidateBeforeCall(diffBookDepthRequest);

        String methodName =
                "/<symbol>@depth@<updateSpeed>"
                        .substring(1)
                        .replace(
                                "<symbol>",
                                diffBookDepthRequest.getSymbol() != null
                                        ? diffBookDepthRequest.getSymbol().toString()
                                        : "")
                        .replace(
                                "<updateSpeed>",
                                diffBookDepthRequest.getUpdateSpeed() != null
                                        ? diffBookDepthRequest.getUpdateSpeed().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void diffBookDepthValidateBeforeCall(DiffBookDepthRequest diffBookDepthRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<DiffBookDepthRequest>> violations =
                    validator.validate(diffBookDepthRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Kline/Candlestick Streams for UTC The Kline/Candlestick Stream push updates to the
     * current klines/candlestick every second in &#x60;UTC+0&#x60; timezone &lt;a
     * id&#x3D;\&quot;kline-intervals\&quot;&gt;&lt;/a&gt;
     *
     * @param klineRequest (required)
     * @return KlineResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Kline/Candlestick Streams for UTC </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#klinecandlestick-streams-for-utc">WebSocket
     *     Kline/Candlestick Streams for UTC Documentation</a>
     */
    public StreamBlockingQueueWrapper<KlineResponse> kline(KlineRequest klineRequest)
            throws ApiException {
        StreamBlockingQueue<String> queue = klineRaw(klineRequest);

        TypeToken<KlineResponse> typeToken = new TypeToken<KlineResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> klineRaw(KlineRequest klineRequest) throws ApiException {
        klineValidateBeforeCall(klineRequest);

        String methodName =
                "/<symbol>@kline_<interval>"
                        .substring(1)
                        .replace(
                                "<symbol>",
                                klineRequest.getSymbol() != null
                                        ? klineRequest.getSymbol().toString()
                                        : "")
                        .replace(
                                "<interval>",
                                klineRequest.getInterval() != null
                                        ? klineRequest.getInterval().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void klineValidateBeforeCall(KlineRequest klineRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<KlineRequest>> violations = validator.validate(klineRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Kline/Candlestick Streams with timezone offset The Kline/Candlestick Stream push
     * updates to the current klines/candlestick every second in &#x60;UTC+8&#x60; timezone
     *
     * @param klineOffsetRequest (required)
     * @return KlineOffsetResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Kline/Candlestick Streams with timezone offset </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#klinecandlestick-streams-with-timezone-offset">WebSocket
     *     Kline/Candlestick Streams with timezone offset Documentation</a>
     */
    public StreamBlockingQueueWrapper<KlineOffsetResponse> klineOffset(
            KlineOffsetRequest klineOffsetRequest) throws ApiException {
        StreamBlockingQueue<String> queue = klineOffsetRaw(klineOffsetRequest);

        TypeToken<KlineOffsetResponse> typeToken = new TypeToken<KlineOffsetResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> klineOffsetRaw(KlineOffsetRequest klineOffsetRequest)
            throws ApiException {
        klineOffsetValidateBeforeCall(klineOffsetRequest);

        String methodName =
                "/<symbol>@kline_<interval>@+08:00"
                        .substring(1)
                        .replace(
                                "<symbol>",
                                klineOffsetRequest.getSymbol() != null
                                        ? klineOffsetRequest.getSymbol().toString()
                                        : "")
                        .replace(
                                "<interval>",
                                klineOffsetRequest.getInterval() != null
                                        ? klineOffsetRequest.getInterval().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void klineOffsetValidateBeforeCall(KlineOffsetRequest klineOffsetRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<KlineOffsetRequest>> violations =
                    validator.validate(klineOffsetRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Individual Symbol Mini Ticker Stream 24hr rolling window mini-ticker statistics.
     * These are NOT the statistics of the UTC day, but a 24hr rolling window for the previous
     * 24hrs.
     *
     * @param miniTickerRequest (required)
     * @return MiniTickerResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Individual Symbol Mini Ticker Stream </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-mini-ticker-stream">WebSocket
     *     Individual Symbol Mini Ticker Stream Documentation</a>
     */
    public StreamBlockingQueueWrapper<MiniTickerResponse> miniTicker(
            MiniTickerRequest miniTickerRequest) throws ApiException {
        StreamBlockingQueue<String> queue = miniTickerRaw(miniTickerRequest);

        TypeToken<MiniTickerResponse> typeToken = new TypeToken<MiniTickerResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> miniTickerRaw(MiniTickerRequest miniTickerRequest)
            throws ApiException {
        miniTickerValidateBeforeCall(miniTickerRequest);

        String methodName =
                "/<symbol>@miniTicker"
                        .substring(1)
                        .replace(
                                "<symbol>",
                                miniTickerRequest.getSymbol() != null
                                        ? miniTickerRequest.getSymbol().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void miniTickerValidateBeforeCall(MiniTickerRequest miniTickerRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<MiniTickerRequest>> violations =
                    validator.validate(miniTickerRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Partial Book Depth Streams Top **\\&lt;levels\\&gt;** bids and asks, pushed every
     * second. Valid **\\&lt;levels\\&gt;** are 5, 10, or 20.
     *
     * @param partialBookDepthRequest (required)
     * @return PartialBookDepthResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Partial Book Depth Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#partial-book-depth-streams">WebSocket
     *     Partial Book Depth Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<PartialBookDepthResponse> partialBookDepth(
            PartialBookDepthRequest partialBookDepthRequest) throws ApiException {
        StreamBlockingQueue<String> queue = partialBookDepthRaw(partialBookDepthRequest);

        TypeToken<PartialBookDepthResponse> typeToken =
                new TypeToken<PartialBookDepthResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> partialBookDepthRaw(
            PartialBookDepthRequest partialBookDepthRequest) throws ApiException {
        partialBookDepthValidateBeforeCall(partialBookDepthRequest);

        String methodName =
                "/<symbol>@depth<levels>@<updateSpeed>"
                        .substring(1)
                        .replace(
                                "<symbol>",
                                partialBookDepthRequest.getSymbol() != null
                                        ? partialBookDepthRequest.getSymbol().toString()
                                        : "")
                        .replace(
                                "<levels>",
                                partialBookDepthRequest.getLevels() != null
                                        ? partialBookDepthRequest.getLevels().toString()
                                        : "")
                        .replace(
                                "<updateSpeed>",
                                partialBookDepthRequest.getUpdateSpeed() != null
                                        ? partialBookDepthRequest.getUpdateSpeed().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void partialBookDepthValidateBeforeCall(PartialBookDepthRequest partialBookDepthRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<PartialBookDepthRequest>> violations =
                    validator.validate(partialBookDepthRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Individual Symbol Rolling Window Statistics Streams Rolling window ticker
     * statistics for a single symbol, computed over multiple windows.
     *
     * @param rollingWindowTickerRequest (required)
     * @return RollingWindowTickerResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Individual Symbol Rolling Window Statistics Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-rolling-window-statistics-streams">WebSocket
     *     Individual Symbol Rolling Window Statistics Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<RollingWindowTickerResponse> rollingWindowTicker(
            RollingWindowTickerRequest rollingWindowTickerRequest) throws ApiException {
        StreamBlockingQueue<String> queue = rollingWindowTickerRaw(rollingWindowTickerRequest);

        TypeToken<RollingWindowTickerResponse> typeToken =
                new TypeToken<RollingWindowTickerResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> rollingWindowTickerRaw(
            RollingWindowTickerRequest rollingWindowTickerRequest) throws ApiException {
        rollingWindowTickerValidateBeforeCall(rollingWindowTickerRequest);

        String methodName =
                "/<symbol>@ticker_<windowSize>"
                        .substring(1)
                        .replace(
                                "<symbol>",
                                rollingWindowTickerRequest.getSymbol() != null
                                        ? rollingWindowTickerRequest.getSymbol().toString()
                                        : "")
                        .replace(
                                "<windowSize>",
                                rollingWindowTickerRequest.getWindowSize() != null
                                        ? rollingWindowTickerRequest.getWindowSize().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void rollingWindowTickerValidateBeforeCall(
            RollingWindowTickerRequest rollingWindowTickerRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<RollingWindowTickerRequest>> violations =
                    validator.validate(rollingWindowTickerRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Individual Symbol Ticker Streams 24hr rolling window ticker statistics for a single
     * symbol. These are NOT the statistics of the UTC day, but a 24hr rolling window for the
     * previous 24hrs.
     *
     * @param tickerRequest (required)
     * @return TickerResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Individual Symbol Ticker Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#individual-symbol-ticker-streams">WebSocket
     *     Individual Symbol Ticker Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<TickerResponse> ticker(TickerRequest tickerRequest)
            throws ApiException {
        StreamBlockingQueue<String> queue = tickerRaw(tickerRequest);

        TypeToken<TickerResponse> typeToken = new TypeToken<TickerResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> tickerRaw(TickerRequest tickerRequest) throws ApiException {
        tickerValidateBeforeCall(tickerRequest);

        String methodName =
                "/<symbol>@ticker"
                        .substring(1)
                        .replace(
                                "<symbol>",
                                tickerRequest.getSymbol() != null
                                        ? tickerRequest.getSymbol().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void tickerValidateBeforeCall(TickerRequest tickerRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<TickerRequest>> violations = validator.validate(tickerRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * WebSocket Trade Streams The Trade Streams push raw trade information; each trade has a unique
     * buyer and seller.
     *
     * @param tradeRequest (required)
     * @return TradeResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Trade Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/web-socket-streams#trade-streams">WebSocket
     *     Trade Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<TradeResponse> trade(TradeRequest tradeRequest)
            throws ApiException {
        StreamBlockingQueue<String> queue = tradeRaw(tradeRequest);

        TypeToken<TradeResponse> typeToken = new TypeToken<TradeResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> tradeRaw(TradeRequest tradeRequest) throws ApiException {
        tradeValidateBeforeCall(tradeRequest);

        String methodName =
                "/<symbol>@trade"
                        .substring(1)
                        .replace(
                                "<symbol>",
                                tradeRequest.getSymbol() != null
                                        ? tradeRequest.getSymbol().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void tradeValidateBeforeCall(TradeRequest tradeRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<TradeRequest>> violations = validator.validate(tradeRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    public String getRequestID() {
        return UUID.randomUUID().toString();
    }
}
