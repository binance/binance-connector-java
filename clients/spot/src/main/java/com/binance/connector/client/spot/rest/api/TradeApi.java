/*
 * Binance Spot REST API
 * OpenAPI Specifications for the Binance Spot REST API  API documents:   - [Github rest-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md)   - [General API information for rest-api on website](https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-api-information)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.spot.rest.api;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.DecimalFormatter;
import com.binance.connector.client.common.Pair;
import com.binance.connector.client.common.SystemUtil;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.exception.ConstraintViolationException;
import com.binance.connector.client.spot.rest.model.CancelRestrictions;
import com.binance.connector.client.spot.rest.model.DeleteOpenOrdersResponse;
import com.binance.connector.client.spot.rest.model.DeleteOrderListResponse;
import com.binance.connector.client.spot.rest.model.DeleteOrderResponse;
import com.binance.connector.client.spot.rest.model.NewOrderRequest;
import com.binance.connector.client.spot.rest.model.NewOrderResponse;
import com.binance.connector.client.spot.rest.model.OrderAmendKeepPriorityRequest;
import com.binance.connector.client.spot.rest.model.OrderAmendKeepPriorityResponse;
import com.binance.connector.client.spot.rest.model.OrderCancelReplaceRequest;
import com.binance.connector.client.spot.rest.model.OrderCancelReplaceResponse;
import com.binance.connector.client.spot.rest.model.OrderListOcoRequest;
import com.binance.connector.client.spot.rest.model.OrderListOcoResponse;
import com.binance.connector.client.spot.rest.model.OrderListOtoRequest;
import com.binance.connector.client.spot.rest.model.OrderListOtoResponse;
import com.binance.connector.client.spot.rest.model.OrderListOtocoRequest;
import com.binance.connector.client.spot.rest.model.OrderListOtocoResponse;
import com.binance.connector.client.spot.rest.model.OrderOcoRequest;
import com.binance.connector.client.spot.rest.model.OrderOcoResponse;
import com.binance.connector.client.spot.rest.model.OrderTestRequest;
import com.binance.connector.client.spot.rest.model.OrderTestResponse;
import com.binance.connector.client.spot.rest.model.SorOrderRequest;
import com.binance.connector.client.spot.rest.model.SorOrderResponse;
import com.binance.connector.client.spot.rest.model.SorOrderTestRequest;
import com.binance.connector.client.spot.rest.model.SorOrderTestResponse;
import com.google.gson.reflect.TypeToken;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Valid;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.constraints.*;
import jakarta.validation.executable.ExecutableValidator;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator;

public class TradeApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    private static final String USER_AGENT =
            String.format(
                    "binance-spot/4.0.0 (Java/%s; %s; %s)",
                    SystemUtil.getJavaVersion(), SystemUtil.getOs(), SystemUtil.getArch());
    private static final boolean HAS_TIME_UNIT = true;

    public TradeApi(ClientConfiguration clientConfiguration) {
        this(new ApiClient(clientConfiguration));
    }

    public TradeApi(ApiClient apiClient) {
        apiClient.setUserAgent(USER_AGENT);
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for deleteOpenOrders
     *
     * @param symbol (required)
     * @param recvWindow The value cannot be greater than &#x60;60000&#x60; (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cancel All Open Orders on a Symbol </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-all-open-orders-on-a-symbol-trade">Cancel
     *     All Open Orders on a Symbol Documentation</a>
     */
    private okhttp3.Call deleteOpenOrdersCall(String symbol, Long recvWindow) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v3/openOrders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "DELETE",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteOpenOrdersValidateBeforeCall(String symbol, Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, recvWindow};
            Method method = this.getClass().getMethod("deleteOpenOrders", String.class, Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return deleteOpenOrdersCall(symbol, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Cancel All Open Orders on a Symbol Cancels all active orders on a symbol. This includes
     * orders that are part of an order list. Weight: 1
     *
     * @param symbol (required)
     * @param recvWindow The value cannot be greater than &#x60;60000&#x60; (optional)
     * @return ApiResponse&lt;DeleteOpenOrdersResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cancel All Open Orders on a Symbol </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-all-open-orders-on-a-symbol-trade">Cancel
     *     All Open Orders on a Symbol Documentation</a>
     */
    public ApiResponse<DeleteOpenOrdersResponse> deleteOpenOrders(
            @NotNull String symbol, Long recvWindow) throws ApiException {
        okhttp3.Call localVarCall = deleteOpenOrdersValidateBeforeCall(symbol, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<DeleteOpenOrdersResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for deleteOrder
     *
     * @param symbol (required)
     * @param orderId (optional)
     * @param origClientOrderId (optional)
     * @param newClientOrderId A unique id among open orders. Automatically generated if not
     *     sent.&lt;br/&gt; Orders with the same &#x60;newClientOrderID&#x60; can be accepted only
     *     when the previous one is filled, otherwise the order will be rejected. (optional)
     * @param cancelRestrictions (optional)
     * @param recvWindow The value cannot be greater than &#x60;60000&#x60; (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cancel order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-order-trade">Cancel
     *     order Documentation</a>
     */
    private okhttp3.Call deleteOrderCall(
            String symbol,
            Long orderId,
            String origClientOrderId,
            String newClientOrderId,
            CancelRestrictions cancelRestrictions,
            Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v3/order";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (orderId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderId", orderId));
        }

        if (origClientOrderId != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("origClientOrderId", origClientOrderId));
        }

        if (newClientOrderId != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("newClientOrderId", newClientOrderId));
        }

        if (cancelRestrictions != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("cancelRestrictions", cancelRestrictions));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "DELETE",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteOrderValidateBeforeCall(
            String symbol,
            Long orderId,
            String origClientOrderId,
            String newClientOrderId,
            CancelRestrictions cancelRestrictions,
            Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {
                symbol, orderId, origClientOrderId, newClientOrderId, cancelRestrictions, recvWindow
            };
            Method method =
                    this.getClass()
                            .getMethod(
                                    "deleteOrder",
                                    String.class,
                                    Long.class,
                                    String.class,
                                    String.class,
                                    CancelRestrictions.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return deleteOrderCall(
                        symbol,
                        orderId,
                        origClientOrderId,
                        newClientOrderId,
                        cancelRestrictions,
                        recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Cancel order Cancel an active order. Weight: 1
     *
     * @param symbol (required)
     * @param orderId (optional)
     * @param origClientOrderId (optional)
     * @param newClientOrderId A unique id among open orders. Automatically generated if not
     *     sent.&lt;br/&gt; Orders with the same &#x60;newClientOrderID&#x60; can be accepted only
     *     when the previous one is filled, otherwise the order will be rejected. (optional)
     * @param cancelRestrictions (optional)
     * @param recvWindow The value cannot be greater than &#x60;60000&#x60; (optional)
     * @return ApiResponse&lt;DeleteOrderResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cancel order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-order-trade">Cancel
     *     order Documentation</a>
     */
    public ApiResponse<DeleteOrderResponse> deleteOrder(
            @NotNull String symbol,
            Long orderId,
            String origClientOrderId,
            String newClientOrderId,
            CancelRestrictions cancelRestrictions,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                deleteOrderValidateBeforeCall(
                        symbol,
                        orderId,
                        origClientOrderId,
                        newClientOrderId,
                        cancelRestrictions,
                        recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<DeleteOrderResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for deleteOrderList
     *
     * @param symbol (required)
     * @param orderListId Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be
     *     provided (optional)
     * @param listClientOrderId A unique Id for the entire orderList (optional)
     * @param newClientOrderId A unique id among open orders. Automatically generated if not
     *     sent.&lt;br/&gt; Orders with the same &#x60;newClientOrderID&#x60; can be accepted only
     *     when the previous one is filled, otherwise the order will be rejected. (optional)
     * @param recvWindow The value cannot be greater than &#x60;60000&#x60; (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cancel Order list </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-order-list-trade">Cancel
     *     Order list Documentation</a>
     */
    private okhttp3.Call deleteOrderListCall(
            String symbol,
            Long orderListId,
            String listClientOrderId,
            String newClientOrderId,
            Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v3/orderList";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (orderListId != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("orderListId", orderListId));
        }

        if (listClientOrderId != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("listClientOrderId", listClientOrderId));
        }

        if (newClientOrderId != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("newClientOrderId", newClientOrderId));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "DELETE",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteOrderListValidateBeforeCall(
            String symbol,
            Long orderListId,
            String listClientOrderId,
            String newClientOrderId,
            Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {
                symbol, orderListId, listClientOrderId, newClientOrderId, recvWindow
            };
            Method method =
                    this.getClass()
                            .getMethod(
                                    "deleteOrderList",
                                    String.class,
                                    Long.class,
                                    String.class,
                                    String.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return deleteOrderListCall(
                        symbol, orderListId, listClientOrderId, newClientOrderId, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Cancel Order list Cancel an entire Order list Weight: 1
     *
     * @param symbol (required)
     * @param orderListId Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be
     *     provided (optional)
     * @param listClientOrderId A unique Id for the entire orderList (optional)
     * @param newClientOrderId A unique id among open orders. Automatically generated if not
     *     sent.&lt;br/&gt; Orders with the same &#x60;newClientOrderID&#x60; can be accepted only
     *     when the previous one is filled, otherwise the order will be rejected. (optional)
     * @param recvWindow The value cannot be greater than &#x60;60000&#x60; (optional)
     * @return ApiResponse&lt;DeleteOrderListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cancel Order list </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-order-list-trade">Cancel
     *     Order list Documentation</a>
     */
    public ApiResponse<DeleteOrderListResponse> deleteOrderList(
            @NotNull String symbol,
            Long orderListId,
            String listClientOrderId,
            String newClientOrderId,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                deleteOrderListValidateBeforeCall(
                        symbol, orderListId, listClientOrderId, newClientOrderId, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<DeleteOrderListResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for newOrder
     *
     * @param newOrderRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> New order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-trade">New
     *     order Documentation</a>
     */
    private okhttp3.Call newOrderCall(NewOrderRequest newOrderRequest) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v3/order";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (newOrderRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", newOrderRequest.getSymbol());
        }

        if (newOrderRequest.getSide() != null) {
            localVarFormParams.put("side", newOrderRequest.getSide());
        }

        if (newOrderRequest.getType() != null) {
            localVarFormParams.put("type", newOrderRequest.getType());
        }

        if (newOrderRequest.getTimeInForce() != null) {
            localVarFormParams.put("timeInForce", newOrderRequest.getTimeInForce());
        }

        if (newOrderRequest.getQuantity() != null) {
            localVarFormParams.put(
                    "quantity",
                    DecimalFormatter.getFormatter().format(newOrderRequest.getQuantity()));
        }

        if (newOrderRequest.getQuoteOrderQty() != null) {
            localVarFormParams.put(
                    "quoteOrderQty",
                    DecimalFormatter.getFormatter().format(newOrderRequest.getQuoteOrderQty()));
        }

        if (newOrderRequest.getPrice() != null) {
            localVarFormParams.put(
                    "price", DecimalFormatter.getFormatter().format(newOrderRequest.getPrice()));
        }

        if (newOrderRequest.getNewClientOrderId() != null) {
            localVarFormParams.put("newClientOrderId", newOrderRequest.getNewClientOrderId());
        }

        if (newOrderRequest.getStrategyId() != null) {
            localVarFormParams.put("strategyId", newOrderRequest.getStrategyId());
        }

        if (newOrderRequest.getStrategyType() != null) {
            localVarFormParams.put("strategyType", newOrderRequest.getStrategyType());
        }

        if (newOrderRequest.getStopPrice() != null) {
            localVarFormParams.put(
                    "stopPrice",
                    DecimalFormatter.getFormatter().format(newOrderRequest.getStopPrice()));
        }

        if (newOrderRequest.getTrailingDelta() != null) {
            localVarFormParams.put("trailingDelta", newOrderRequest.getTrailingDelta());
        }

        if (newOrderRequest.getIcebergQty() != null) {
            localVarFormParams.put(
                    "icebergQty",
                    DecimalFormatter.getFormatter().format(newOrderRequest.getIcebergQty()));
        }

        if (newOrderRequest.getNewOrderRespType() != null) {
            localVarFormParams.put("newOrderRespType", newOrderRequest.getNewOrderRespType());
        }

        if (newOrderRequest.getSelfTradePreventionMode() != null) {
            localVarFormParams.put(
                    "selfTradePreventionMode", newOrderRequest.getSelfTradePreventionMode());
        }

        if (newOrderRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", newOrderRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call newOrderValidateBeforeCall(NewOrderRequest newOrderRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {newOrderRequest};
            Method method = this.getClass().getMethod("newOrder", NewOrderRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return newOrderCall(newOrderRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * New order Send in a new order. This adds 1 order to the &#x60;EXCHANGE_MAX_ORDERS&#x60;
     * filter and the &#x60;MAX_NUM_ORDERS&#x60; filter. Weight: 1
     *
     * @param newOrderRequest (required)
     * @return ApiResponse&lt;NewOrderResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> New order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-trade">New
     *     order Documentation</a>
     */
    public ApiResponse<NewOrderResponse> newOrder(@Valid @NotNull NewOrderRequest newOrderRequest)
            throws ApiException {
        okhttp3.Call localVarCall = newOrderValidateBeforeCall(newOrderRequest);
        java.lang.reflect.Type localVarReturnType = new TypeToken<NewOrderResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for orderAmendKeepPriority
     *
     * @param orderAmendKeepPriorityRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Order Amend Keep Priority </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#order-amend-keep-priority-trade">Order
     *     Amend Keep Priority Documentation</a>
     */
    private okhttp3.Call orderAmendKeepPriorityCall(
            OrderAmendKeepPriorityRequest orderAmendKeepPriorityRequest) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v3/order/amend/keepPriority";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (orderAmendKeepPriorityRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", orderAmendKeepPriorityRequest.getSymbol());
        }

        if (orderAmendKeepPriorityRequest.getOrderId() != null) {
            localVarFormParams.put("orderId", orderAmendKeepPriorityRequest.getOrderId());
        }

        if (orderAmendKeepPriorityRequest.getOrigClientOrderId() != null) {
            localVarFormParams.put(
                    "origClientOrderId", orderAmendKeepPriorityRequest.getOrigClientOrderId());
        }

        if (orderAmendKeepPriorityRequest.getNewClientOrderId() != null) {
            localVarFormParams.put(
                    "newClientOrderId", orderAmendKeepPriorityRequest.getNewClientOrderId());
        }

        if (orderAmendKeepPriorityRequest.getNewQty() != null) {
            localVarFormParams.put(
                    "newQty",
                    DecimalFormatter.getFormatter()
                            .format(orderAmendKeepPriorityRequest.getNewQty()));
        }

        if (orderAmendKeepPriorityRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", orderAmendKeepPriorityRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "PUT",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call orderAmendKeepPriorityValidateBeforeCall(
            OrderAmendKeepPriorityRequest orderAmendKeepPriorityRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {orderAmendKeepPriorityRequest};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "orderAmendKeepPriority", OrderAmendKeepPriorityRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return orderAmendKeepPriorityCall(orderAmendKeepPriorityRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Order Amend Keep Priority Reduce the quantity of an existing open order. This adds 0 orders
     * to the &#x60;EXCHANGE_MAX_ORDERS&#x60; filter and the &#x60;MAX_NUM_ORDERS&#x60; filter. Read
     * [Order Amend Keep Priority FAQ](faqs/order_amend_keep_priority.md) to learn more. Weight: 4
     *
     * @param orderAmendKeepPriorityRequest (required)
     * @return ApiResponse&lt;OrderAmendKeepPriorityResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Order Amend Keep Priority </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#order-amend-keep-priority-trade">Order
     *     Amend Keep Priority Documentation</a>
     */
    public ApiResponse<OrderAmendKeepPriorityResponse> orderAmendKeepPriority(
            @Valid @NotNull OrderAmendKeepPriorityRequest orderAmendKeepPriorityRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                orderAmendKeepPriorityValidateBeforeCall(orderAmendKeepPriorityRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<OrderAmendKeepPriorityResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for orderCancelReplace
     *
     * @param orderCancelReplaceRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cancel an Existing Order and Send a New Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-an-existing-order-and-send-a-new-order-trade">Cancel
     *     an Existing Order and Send a New Order Documentation</a>
     */
    private okhttp3.Call orderCancelReplaceCall(OrderCancelReplaceRequest orderCancelReplaceRequest)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v3/order/cancelReplace";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (orderCancelReplaceRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", orderCancelReplaceRequest.getSymbol());
        }

        if (orderCancelReplaceRequest.getSide() != null) {
            localVarFormParams.put("side", orderCancelReplaceRequest.getSide());
        }

        if (orderCancelReplaceRequest.getType() != null) {
            localVarFormParams.put("type", orderCancelReplaceRequest.getType());
        }

        if (orderCancelReplaceRequest.getCancelReplaceMode() != null) {
            localVarFormParams.put(
                    "cancelReplaceMode", orderCancelReplaceRequest.getCancelReplaceMode());
        }

        if (orderCancelReplaceRequest.getTimeInForce() != null) {
            localVarFormParams.put("timeInForce", orderCancelReplaceRequest.getTimeInForce());
        }

        if (orderCancelReplaceRequest.getQuantity() != null) {
            localVarFormParams.put(
                    "quantity",
                    DecimalFormatter.getFormatter()
                            .format(orderCancelReplaceRequest.getQuantity()));
        }

        if (orderCancelReplaceRequest.getQuoteOrderQty() != null) {
            localVarFormParams.put(
                    "quoteOrderQty",
                    DecimalFormatter.getFormatter()
                            .format(orderCancelReplaceRequest.getQuoteOrderQty()));
        }

        if (orderCancelReplaceRequest.getPrice() != null) {
            localVarFormParams.put(
                    "price",
                    DecimalFormatter.getFormatter().format(orderCancelReplaceRequest.getPrice()));
        }

        if (orderCancelReplaceRequest.getCancelNewClientOrderId() != null) {
            localVarFormParams.put(
                    "cancelNewClientOrderId",
                    orderCancelReplaceRequest.getCancelNewClientOrderId());
        }

        if (orderCancelReplaceRequest.getCancelOrigClientOrderId() != null) {
            localVarFormParams.put(
                    "cancelOrigClientOrderId",
                    orderCancelReplaceRequest.getCancelOrigClientOrderId());
        }

        if (orderCancelReplaceRequest.getCancelOrderId() != null) {
            localVarFormParams.put("cancelOrderId", orderCancelReplaceRequest.getCancelOrderId());
        }

        if (orderCancelReplaceRequest.getNewClientOrderId() != null) {
            localVarFormParams.put(
                    "newClientOrderId", orderCancelReplaceRequest.getNewClientOrderId());
        }

        if (orderCancelReplaceRequest.getStrategyId() != null) {
            localVarFormParams.put("strategyId", orderCancelReplaceRequest.getStrategyId());
        }

        if (orderCancelReplaceRequest.getStrategyType() != null) {
            localVarFormParams.put("strategyType", orderCancelReplaceRequest.getStrategyType());
        }

        if (orderCancelReplaceRequest.getStopPrice() != null) {
            localVarFormParams.put(
                    "stopPrice",
                    DecimalFormatter.getFormatter()
                            .format(orderCancelReplaceRequest.getStopPrice()));
        }

        if (orderCancelReplaceRequest.getTrailingDelta() != null) {
            localVarFormParams.put("trailingDelta", orderCancelReplaceRequest.getTrailingDelta());
        }

        if (orderCancelReplaceRequest.getIcebergQty() != null) {
            localVarFormParams.put(
                    "icebergQty",
                    DecimalFormatter.getFormatter()
                            .format(orderCancelReplaceRequest.getIcebergQty()));
        }

        if (orderCancelReplaceRequest.getNewOrderRespType() != null) {
            localVarFormParams.put(
                    "newOrderRespType", orderCancelReplaceRequest.getNewOrderRespType());
        }

        if (orderCancelReplaceRequest.getSelfTradePreventionMode() != null) {
            localVarFormParams.put(
                    "selfTradePreventionMode",
                    orderCancelReplaceRequest.getSelfTradePreventionMode());
        }

        if (orderCancelReplaceRequest.getCancelRestrictions() != null) {
            localVarFormParams.put(
                    "cancelRestrictions", orderCancelReplaceRequest.getCancelRestrictions());
        }

        if (orderCancelReplaceRequest.getOrderRateLimitExceededMode() != null) {
            localVarFormParams.put(
                    "orderRateLimitExceededMode",
                    orderCancelReplaceRequest.getOrderRateLimitExceededMode());
        }

        if (orderCancelReplaceRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", orderCancelReplaceRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call orderCancelReplaceValidateBeforeCall(
            OrderCancelReplaceRequest orderCancelReplaceRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {orderCancelReplaceRequest};
            Method method =
                    this.getClass()
                            .getMethod("orderCancelReplace", OrderCancelReplaceRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return orderCancelReplaceCall(orderCancelReplaceRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Cancel an Existing Order and Send a New Order Cancels an existing order and places a new
     * order on the same symbol. Filters and Order Count are evaluated before the processing of the
     * cancellation and order placement occurs. A new order that was not attempted (i.e. when
     * &#x60;newOrderResult: NOT_ATTEMPTED&#x60;), will still increase the unfilled order count by
     * 1. Weight: 1
     *
     * @param orderCancelReplaceRequest (required)
     * @return ApiResponse&lt;OrderCancelReplaceResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cancel an Existing Order and Send a New Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-an-existing-order-and-send-a-new-order-trade">Cancel
     *     an Existing Order and Send a New Order Documentation</a>
     */
    public ApiResponse<OrderCancelReplaceResponse> orderCancelReplace(
            @Valid @NotNull OrderCancelReplaceRequest orderCancelReplaceRequest)
            throws ApiException {
        okhttp3.Call localVarCall = orderCancelReplaceValidateBeforeCall(orderCancelReplaceRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<OrderCancelReplaceResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for orderListOco
     *
     * @param orderListOcoRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> New Order list - OCO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-list---oco-trade">New
     *     Order list - OCO Documentation</a>
     */
    private okhttp3.Call orderListOcoCall(OrderListOcoRequest orderListOcoRequest)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v3/orderList/oco";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (orderListOcoRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", orderListOcoRequest.getSymbol());
        }

        if (orderListOcoRequest.getListClientOrderId() != null) {
            localVarFormParams.put("listClientOrderId", orderListOcoRequest.getListClientOrderId());
        }

        if (orderListOcoRequest.getSide() != null) {
            localVarFormParams.put("side", orderListOcoRequest.getSide());
        }

        if (orderListOcoRequest.getQuantity() != null) {
            localVarFormParams.put(
                    "quantity",
                    DecimalFormatter.getFormatter().format(orderListOcoRequest.getQuantity()));
        }

        if (orderListOcoRequest.getAboveType() != null) {
            localVarFormParams.put("aboveType", orderListOcoRequest.getAboveType());
        }

        if (orderListOcoRequest.getAboveClientOrderId() != null) {
            localVarFormParams.put(
                    "aboveClientOrderId", orderListOcoRequest.getAboveClientOrderId());
        }

        if (orderListOcoRequest.getAboveIcebergQty() != null) {
            localVarFormParams.put("aboveIcebergQty", orderListOcoRequest.getAboveIcebergQty());
        }

        if (orderListOcoRequest.getAbovePrice() != null) {
            localVarFormParams.put(
                    "abovePrice",
                    DecimalFormatter.getFormatter().format(orderListOcoRequest.getAbovePrice()));
        }

        if (orderListOcoRequest.getAboveStopPrice() != null) {
            localVarFormParams.put(
                    "aboveStopPrice",
                    DecimalFormatter.getFormatter()
                            .format(orderListOcoRequest.getAboveStopPrice()));
        }

        if (orderListOcoRequest.getAboveTrailingDelta() != null) {
            localVarFormParams.put(
                    "aboveTrailingDelta", orderListOcoRequest.getAboveTrailingDelta());
        }

        if (orderListOcoRequest.getAboveTimeInForce() != null) {
            localVarFormParams.put(
                    "aboveTimeInForce",
                    DecimalFormatter.getFormatter()
                            .format(orderListOcoRequest.getAboveTimeInForce()));
        }

        if (orderListOcoRequest.getAboveStrategyId() != null) {
            localVarFormParams.put("aboveStrategyId", orderListOcoRequest.getAboveStrategyId());
        }

        if (orderListOcoRequest.getAboveStrategyType() != null) {
            localVarFormParams.put("aboveStrategyType", orderListOcoRequest.getAboveStrategyType());
        }

        if (orderListOcoRequest.getBelowType() != null) {
            localVarFormParams.put("belowType", orderListOcoRequest.getBelowType());
        }

        if (orderListOcoRequest.getBelowClientOrderId() != null) {
            localVarFormParams.put(
                    "belowClientOrderId", orderListOcoRequest.getBelowClientOrderId());
        }

        if (orderListOcoRequest.getBelowIcebergQty() != null) {
            localVarFormParams.put("belowIcebergQty", orderListOcoRequest.getBelowIcebergQty());
        }

        if (orderListOcoRequest.getBelowPrice() != null) {
            localVarFormParams.put(
                    "belowPrice",
                    DecimalFormatter.getFormatter().format(orderListOcoRequest.getBelowPrice()));
        }

        if (orderListOcoRequest.getBelowStopPrice() != null) {
            localVarFormParams.put(
                    "belowStopPrice",
                    DecimalFormatter.getFormatter()
                            .format(orderListOcoRequest.getBelowStopPrice()));
        }

        if (orderListOcoRequest.getBelowTrailingDelta() != null) {
            localVarFormParams.put(
                    "belowTrailingDelta", orderListOcoRequest.getBelowTrailingDelta());
        }

        if (orderListOcoRequest.getBelowTimeInForce() != null) {
            localVarFormParams.put("belowTimeInForce", orderListOcoRequest.getBelowTimeInForce());
        }

        if (orderListOcoRequest.getBelowStrategyId() != null) {
            localVarFormParams.put("belowStrategyId", orderListOcoRequest.getBelowStrategyId());
        }

        if (orderListOcoRequest.getBelowStrategyType() != null) {
            localVarFormParams.put("belowStrategyType", orderListOcoRequest.getBelowStrategyType());
        }

        if (orderListOcoRequest.getNewOrderRespType() != null) {
            localVarFormParams.put("newOrderRespType", orderListOcoRequest.getNewOrderRespType());
        }

        if (orderListOcoRequest.getSelfTradePreventionMode() != null) {
            localVarFormParams.put(
                    "selfTradePreventionMode", orderListOcoRequest.getSelfTradePreventionMode());
        }

        if (orderListOcoRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", orderListOcoRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call orderListOcoValidateBeforeCall(OrderListOcoRequest orderListOcoRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {orderListOcoRequest};
            Method method = this.getClass().getMethod("orderListOco", OrderListOcoRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return orderListOcoCall(orderListOcoRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * New Order list - OCO Send in an one-cancels-the-other (OCO) pair, where activation of one
     * order immediately cancels the other. * An OCO has 2 orders called the **above order** and
     * **below order**. * One of the orders must be a
     * &#x60;LIMIT_MAKER/TAKE_PROFIT/TAKE_PROFIT_LIMIT&#x60; order and the other must be
     * &#x60;STOP_LOSS&#x60; or &#x60;STOP_LOSS_LIMIT&#x60; order. * Price restrictions * If the OCO
     * is on the &#x60;SELL&#x60; side: * &#x60;LIMIT_MAKER/TAKE_PROFIT_LIMIT&#x60;
     * &#x60;price&#x60; &gt; Last Traded Price &gt; &#x60;STOP_LOSS/STOP_LOSS_LIMIT&#x60;
     * &#x60;stopPrice&#x60; * &#x60;TAKE_PROFIT stopPrice&#x60; &gt; Last Traded Price &gt;
     * &#x60;STOP_LOSS/STOP_LOSS_LIMIT stopPrice&#x60; * If the OCO is on the &#x60;BUY&#x60; side:
     * * &#x60;LIMIT_MAKER/TAKE_PROFIT_LIMIT price&#x60; &lt; Last Traded Price &lt;
     * &#x60;stopPrice&#x60; * &#x60;TAKE_PROFIT stopPrice&#x60; &lt; Last Traded Price &lt;
     * &#x60;STOP_LOSS/STOP_LOSS_LIMIT stopPrice&#x60; * OCOs add **2 orders** to the
     * &#x60;EXCHANGE_MAX_ORDERS&#x60; filter and the &#x60;MAX_NUM_ORDERS&#x60; filter. Weight: 1
     * Unfilled Order Count: 2
     *
     * @param orderListOcoRequest (required)
     * @return ApiResponse&lt;OrderListOcoResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> New Order list - OCO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-list---oco-trade">New
     *     Order list - OCO Documentation</a>
     */
    public ApiResponse<OrderListOcoResponse> orderListOco(
            @Valid @NotNull OrderListOcoRequest orderListOcoRequest) throws ApiException {
        okhttp3.Call localVarCall = orderListOcoValidateBeforeCall(orderListOcoRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<OrderListOcoResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for orderListOto
     *
     * @param orderListOtoRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> New Order list - OTO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-list---oto-trade">New
     *     Order list - OTO Documentation</a>
     */
    private okhttp3.Call orderListOtoCall(OrderListOtoRequest orderListOtoRequest)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v3/orderList/oto";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (orderListOtoRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", orderListOtoRequest.getSymbol());
        }

        if (orderListOtoRequest.getListClientOrderId() != null) {
            localVarFormParams.put("listClientOrderId", orderListOtoRequest.getListClientOrderId());
        }

        if (orderListOtoRequest.getNewOrderRespType() != null) {
            localVarFormParams.put("newOrderRespType", orderListOtoRequest.getNewOrderRespType());
        }

        if (orderListOtoRequest.getSelfTradePreventionMode() != null) {
            localVarFormParams.put(
                    "selfTradePreventionMode", orderListOtoRequest.getSelfTradePreventionMode());
        }

        if (orderListOtoRequest.getWorkingType() != null) {
            localVarFormParams.put("workingType", orderListOtoRequest.getWorkingType());
        }

        if (orderListOtoRequest.getWorkingSide() != null) {
            localVarFormParams.put("workingSide", orderListOtoRequest.getWorkingSide());
        }

        if (orderListOtoRequest.getWorkingClientOrderId() != null) {
            localVarFormParams.put(
                    "workingClientOrderId", orderListOtoRequest.getWorkingClientOrderId());
        }

        if (orderListOtoRequest.getWorkingPrice() != null) {
            localVarFormParams.put(
                    "workingPrice",
                    DecimalFormatter.getFormatter().format(orderListOtoRequest.getWorkingPrice()));
        }

        if (orderListOtoRequest.getWorkingQuantity() != null) {
            localVarFormParams.put(
                    "workingQuantity",
                    DecimalFormatter.getFormatter()
                            .format(orderListOtoRequest.getWorkingQuantity()));
        }

        if (orderListOtoRequest.getWorkingIcebergQty() != null) {
            localVarFormParams.put(
                    "workingIcebergQty",
                    DecimalFormatter.getFormatter()
                            .format(orderListOtoRequest.getWorkingIcebergQty()));
        }

        if (orderListOtoRequest.getWorkingTimeInForce() != null) {
            localVarFormParams.put(
                    "workingTimeInForce", orderListOtoRequest.getWorkingTimeInForce());
        }

        if (orderListOtoRequest.getWorkingStrategyId() != null) {
            localVarFormParams.put("workingStrategyId", orderListOtoRequest.getWorkingStrategyId());
        }

        if (orderListOtoRequest.getWorkingStrategyType() != null) {
            localVarFormParams.put(
                    "workingStrategyType", orderListOtoRequest.getWorkingStrategyType());
        }

        if (orderListOtoRequest.getPendingType() != null) {
            localVarFormParams.put("pendingType", orderListOtoRequest.getPendingType());
        }

        if (orderListOtoRequest.getPendingSide() != null) {
            localVarFormParams.put("pendingSide", orderListOtoRequest.getPendingSide());
        }

        if (orderListOtoRequest.getPendingClientOrderId() != null) {
            localVarFormParams.put(
                    "pendingClientOrderId", orderListOtoRequest.getPendingClientOrderId());
        }

        if (orderListOtoRequest.getPendingPrice() != null) {
            localVarFormParams.put(
                    "pendingPrice",
                    DecimalFormatter.getFormatter().format(orderListOtoRequest.getPendingPrice()));
        }

        if (orderListOtoRequest.getPendingStopPrice() != null) {
            localVarFormParams.put(
                    "pendingStopPrice",
                    DecimalFormatter.getFormatter()
                            .format(orderListOtoRequest.getPendingStopPrice()));
        }

        if (orderListOtoRequest.getPendingTrailingDelta() != null) {
            localVarFormParams.put(
                    "pendingTrailingDelta",
                    DecimalFormatter.getFormatter()
                            .format(orderListOtoRequest.getPendingTrailingDelta()));
        }

        if (orderListOtoRequest.getPendingQuantity() != null) {
            localVarFormParams.put(
                    "pendingQuantity",
                    DecimalFormatter.getFormatter()
                            .format(orderListOtoRequest.getPendingQuantity()));
        }

        if (orderListOtoRequest.getPendingIcebergQty() != null) {
            localVarFormParams.put(
                    "pendingIcebergQty",
                    DecimalFormatter.getFormatter()
                            .format(orderListOtoRequest.getPendingIcebergQty()));
        }

        if (orderListOtoRequest.getPendingTimeInForce() != null) {
            localVarFormParams.put(
                    "pendingTimeInForce", orderListOtoRequest.getPendingTimeInForce());
        }

        if (orderListOtoRequest.getPendingStrategyId() != null) {
            localVarFormParams.put("pendingStrategyId", orderListOtoRequest.getPendingStrategyId());
        }

        if (orderListOtoRequest.getPendingStrategyType() != null) {
            localVarFormParams.put(
                    "pendingStrategyType", orderListOtoRequest.getPendingStrategyType());
        }

        if (orderListOtoRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", orderListOtoRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call orderListOtoValidateBeforeCall(OrderListOtoRequest orderListOtoRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {orderListOtoRequest};
            Method method = this.getClass().getMethod("orderListOto", OrderListOtoRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return orderListOtoCall(orderListOtoRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * New Order list - OTO Place an OTO. * An OTO (One-Triggers-the-Other) is an order list
     * comprised of 2 orders. * The first order is called the **working order** and must be
     * &#x60;LIMIT&#x60; or &#x60;LIMIT_MAKER&#x60;. Initially, only the working order goes on the
     * order book. * The second order is called the **pending order**. It can be any order type
     * except for &#x60;MARKET&#x60; orders using parameter &#x60;quoteOrderQty&#x60;. The pending
     * order is only placed on the order book when the working order gets **fully filled**. * If
     * either the working order or the pending order is cancelled individually, the other order in
     * the order list will also be canceled or expired. * When the order list is placed, if the
     * working order gets **immediately fully filled**, the placement response will show the working
     * order as &#x60;FILLED&#x60; but the pending order will still appear as
     * &#x60;PENDING_NEW&#x60;. You need to query the status of the pending order again to see its
     * updated status. * OTOs add **2 orders** to the &#x60;EXCHANGE_MAX_NUM_ORDERS&#x60; filter and
     * &#x60;MAX_NUM_ORDERS&#x60; filter. Weight: 1 Unfilled Order Count: 2
     *
     * @param orderListOtoRequest (required)
     * @return ApiResponse&lt;OrderListOtoResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> New Order list - OTO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-list---oto-trade">New
     *     Order list - OTO Documentation</a>
     */
    public ApiResponse<OrderListOtoResponse> orderListOto(
            @Valid @NotNull OrderListOtoRequest orderListOtoRequest) throws ApiException {
        okhttp3.Call localVarCall = orderListOtoValidateBeforeCall(orderListOtoRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<OrderListOtoResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for orderListOtoco
     *
     * @param orderListOtocoRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> New Order list - OTOCO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-list---otoco-trade">New
     *     Order list - OTOCO Documentation</a>
     */
    private okhttp3.Call orderListOtocoCall(OrderListOtocoRequest orderListOtocoRequest)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v3/orderList/otoco";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (orderListOtocoRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", orderListOtocoRequest.getSymbol());
        }

        if (orderListOtocoRequest.getListClientOrderId() != null) {
            localVarFormParams.put(
                    "listClientOrderId", orderListOtocoRequest.getListClientOrderId());
        }

        if (orderListOtocoRequest.getNewOrderRespType() != null) {
            localVarFormParams.put("newOrderRespType", orderListOtocoRequest.getNewOrderRespType());
        }

        if (orderListOtocoRequest.getSelfTradePreventionMode() != null) {
            localVarFormParams.put(
                    "selfTradePreventionMode", orderListOtocoRequest.getSelfTradePreventionMode());
        }

        if (orderListOtocoRequest.getWorkingType() != null) {
            localVarFormParams.put("workingType", orderListOtocoRequest.getWorkingType());
        }

        if (orderListOtocoRequest.getWorkingSide() != null) {
            localVarFormParams.put("workingSide", orderListOtocoRequest.getWorkingSide());
        }

        if (orderListOtocoRequest.getWorkingClientOrderId() != null) {
            localVarFormParams.put(
                    "workingClientOrderId", orderListOtocoRequest.getWorkingClientOrderId());
        }

        if (orderListOtocoRequest.getWorkingPrice() != null) {
            localVarFormParams.put(
                    "workingPrice",
                    DecimalFormatter.getFormatter()
                            .format(orderListOtocoRequest.getWorkingPrice()));
        }

        if (orderListOtocoRequest.getWorkingQuantity() != null) {
            localVarFormParams.put(
                    "workingQuantity",
                    DecimalFormatter.getFormatter()
                            .format(orderListOtocoRequest.getWorkingQuantity()));
        }

        if (orderListOtocoRequest.getWorkingIcebergQty() != null) {
            localVarFormParams.put(
                    "workingIcebergQty",
                    DecimalFormatter.getFormatter()
                            .format(orderListOtocoRequest.getWorkingIcebergQty()));
        }

        if (orderListOtocoRequest.getWorkingTimeInForce() != null) {
            localVarFormParams.put(
                    "workingTimeInForce", orderListOtocoRequest.getWorkingTimeInForce());
        }

        if (orderListOtocoRequest.getWorkingStrategyId() != null) {
            localVarFormParams.put(
                    "workingStrategyId", orderListOtocoRequest.getWorkingStrategyId());
        }

        if (orderListOtocoRequest.getWorkingStrategyType() != null) {
            localVarFormParams.put(
                    "workingStrategyType", orderListOtocoRequest.getWorkingStrategyType());
        }

        if (orderListOtocoRequest.getPendingSide() != null) {
            localVarFormParams.put("pendingSide", orderListOtocoRequest.getPendingSide());
        }

        if (orderListOtocoRequest.getPendingQuantity() != null) {
            localVarFormParams.put(
                    "pendingQuantity",
                    DecimalFormatter.getFormatter()
                            .format(orderListOtocoRequest.getPendingQuantity()));
        }

        if (orderListOtocoRequest.getPendingAboveType() != null) {
            localVarFormParams.put("pendingAboveType", orderListOtocoRequest.getPendingAboveType());
        }

        if (orderListOtocoRequest.getPendingAboveClientOrderId() != null) {
            localVarFormParams.put(
                    "pendingAboveClientOrderId",
                    orderListOtocoRequest.getPendingAboveClientOrderId());
        }

        if (orderListOtocoRequest.getPendingAbovePrice() != null) {
            localVarFormParams.put(
                    "pendingAbovePrice",
                    DecimalFormatter.getFormatter()
                            .format(orderListOtocoRequest.getPendingAbovePrice()));
        }

        if (orderListOtocoRequest.getPendingAboveStopPrice() != null) {
            localVarFormParams.put(
                    "pendingAboveStopPrice",
                    DecimalFormatter.getFormatter()
                            .format(orderListOtocoRequest.getPendingAboveStopPrice()));
        }

        if (orderListOtocoRequest.getPendingAboveTrailingDelta() != null) {
            localVarFormParams.put(
                    "pendingAboveTrailingDelta",
                    DecimalFormatter.getFormatter()
                            .format(orderListOtocoRequest.getPendingAboveTrailingDelta()));
        }

        if (orderListOtocoRequest.getPendingAboveIcebergQty() != null) {
            localVarFormParams.put(
                    "pendingAboveIcebergQty",
                    DecimalFormatter.getFormatter()
                            .format(orderListOtocoRequest.getPendingAboveIcebergQty()));
        }

        if (orderListOtocoRequest.getPendingAboveTimeInForce() != null) {
            localVarFormParams.put(
                    "pendingAboveTimeInForce", orderListOtocoRequest.getPendingAboveTimeInForce());
        }

        if (orderListOtocoRequest.getPendingAboveStrategyId() != null) {
            localVarFormParams.put(
                    "pendingAboveStrategyId", orderListOtocoRequest.getPendingAboveStrategyId());
        }

        if (orderListOtocoRequest.getPendingAboveStrategyType() != null) {
            localVarFormParams.put(
                    "pendingAboveStrategyType",
                    orderListOtocoRequest.getPendingAboveStrategyType());
        }

        if (orderListOtocoRequest.getPendingBelowType() != null) {
            localVarFormParams.put("pendingBelowType", orderListOtocoRequest.getPendingBelowType());
        }

        if (orderListOtocoRequest.getPendingBelowClientOrderId() != null) {
            localVarFormParams.put(
                    "pendingBelowClientOrderId",
                    orderListOtocoRequest.getPendingBelowClientOrderId());
        }

        if (orderListOtocoRequest.getPendingBelowPrice() != null) {
            localVarFormParams.put(
                    "pendingBelowPrice",
                    DecimalFormatter.getFormatter()
                            .format(orderListOtocoRequest.getPendingBelowPrice()));
        }

        if (orderListOtocoRequest.getPendingBelowStopPrice() != null) {
            localVarFormParams.put(
                    "pendingBelowStopPrice",
                    DecimalFormatter.getFormatter()
                            .format(orderListOtocoRequest.getPendingBelowStopPrice()));
        }

        if (orderListOtocoRequest.getPendingBelowTrailingDelta() != null) {
            localVarFormParams.put(
                    "pendingBelowTrailingDelta",
                    DecimalFormatter.getFormatter()
                            .format(orderListOtocoRequest.getPendingBelowTrailingDelta()));
        }

        if (orderListOtocoRequest.getPendingBelowIcebergQty() != null) {
            localVarFormParams.put(
                    "pendingBelowIcebergQty",
                    DecimalFormatter.getFormatter()
                            .format(orderListOtocoRequest.getPendingBelowIcebergQty()));
        }

        if (orderListOtocoRequest.getPendingBelowTimeInForce() != null) {
            localVarFormParams.put(
                    "pendingBelowTimeInForce", orderListOtocoRequest.getPendingBelowTimeInForce());
        }

        if (orderListOtocoRequest.getPendingBelowStrategyId() != null) {
            localVarFormParams.put(
                    "pendingBelowStrategyId", orderListOtocoRequest.getPendingBelowStrategyId());
        }

        if (orderListOtocoRequest.getPendingBelowStrategyType() != null) {
            localVarFormParams.put(
                    "pendingBelowStrategyType",
                    orderListOtocoRequest.getPendingBelowStrategyType());
        }

        if (orderListOtocoRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", orderListOtocoRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call orderListOtocoValidateBeforeCall(
            OrderListOtocoRequest orderListOtocoRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {orderListOtocoRequest};
            Method method =
                    this.getClass().getMethod("orderListOtoco", OrderListOtocoRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return orderListOtocoCall(orderListOtocoRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * New Order list - OTOCO Place an OTOCO. * An OTOCO (One-Triggers-One-Cancels-the-Other) is an
     * order list comprised of 3 orders. * The first order is called the **working order** and must
     * be &#x60;LIMIT&#x60; or &#x60;LIMIT_MAKER&#x60;. Initially, only the working order goes on
     * the order book. * The behavior of the working order is the same as the
     * [OTO](#new-order-list---oto-trade). * OTOCO has 2 pending orders (pending above and pending
     * below), forming an OCO pair. The pending orders are only placed on the order book when the
     * working order gets **fully filled**. * The rules of the pending above and pending below
     * follow the same rules as the [Order list OCO](#new-order-list---oco-trade). * OTOCOs add **3
     * orders** to the &#x60;EXCHANGE_MAX_NUM_ORDERS&#x60; filter and &#x60;MAX_NUM_ORDERS&#x60;
     * filter. Weight: 1 Unfilled Order Count: 3
     *
     * @param orderListOtocoRequest (required)
     * @return ApiResponse&lt;OrderListOtocoResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> New Order list - OTOCO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-list---otoco-trade">New
     *     Order list - OTOCO Documentation</a>
     */
    public ApiResponse<OrderListOtocoResponse> orderListOtoco(
            @Valid @NotNull OrderListOtocoRequest orderListOtocoRequest) throws ApiException {
        okhttp3.Call localVarCall = orderListOtocoValidateBeforeCall(orderListOtocoRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<OrderListOtocoResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for orderOco
     *
     * @param orderOcoRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> New OCO - Deprecated </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-oco---deprecated-trade">New
     *     OCO - Deprecated Documentation</a>
     */
    private okhttp3.Call orderOcoCall(OrderOcoRequest orderOcoRequest) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v3/order/oco";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (orderOcoRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", orderOcoRequest.getSymbol());
        }

        if (orderOcoRequest.getListClientOrderId() != null) {
            localVarFormParams.put("listClientOrderId", orderOcoRequest.getListClientOrderId());
        }

        if (orderOcoRequest.getSide() != null) {
            localVarFormParams.put("side", orderOcoRequest.getSide());
        }

        if (orderOcoRequest.getQuantity() != null) {
            localVarFormParams.put(
                    "quantity",
                    DecimalFormatter.getFormatter().format(orderOcoRequest.getQuantity()));
        }

        if (orderOcoRequest.getLimitClientOrderId() != null) {
            localVarFormParams.put("limitClientOrderId", orderOcoRequest.getLimitClientOrderId());
        }

        if (orderOcoRequest.getPrice() != null) {
            localVarFormParams.put(
                    "price", DecimalFormatter.getFormatter().format(orderOcoRequest.getPrice()));
        }

        if (orderOcoRequest.getLimitStrategyId() != null) {
            localVarFormParams.put("limitStrategyId", orderOcoRequest.getLimitStrategyId());
        }

        if (orderOcoRequest.getLimitStrategyType() != null) {
            localVarFormParams.put("limitStrategyType", orderOcoRequest.getLimitStrategyType());
        }

        if (orderOcoRequest.getLimitIcebergQty() != null) {
            localVarFormParams.put(
                    "limitIcebergQty",
                    DecimalFormatter.getFormatter().format(orderOcoRequest.getLimitIcebergQty()));
        }

        if (orderOcoRequest.getTrailingDelta() != null) {
            localVarFormParams.put("trailingDelta", orderOcoRequest.getTrailingDelta());
        }

        if (orderOcoRequest.getStopClientOrderId() != null) {
            localVarFormParams.put("stopClientOrderId", orderOcoRequest.getStopClientOrderId());
        }

        if (orderOcoRequest.getStopPrice() != null) {
            localVarFormParams.put(
                    "stopPrice",
                    DecimalFormatter.getFormatter().format(orderOcoRequest.getStopPrice()));
        }

        if (orderOcoRequest.getStopStrategyId() != null) {
            localVarFormParams.put("stopStrategyId", orderOcoRequest.getStopStrategyId());
        }

        if (orderOcoRequest.getStopStrategyType() != null) {
            localVarFormParams.put("stopStrategyType", orderOcoRequest.getStopStrategyType());
        }

        if (orderOcoRequest.getStopLimitPrice() != null) {
            localVarFormParams.put(
                    "stopLimitPrice",
                    DecimalFormatter.getFormatter().format(orderOcoRequest.getStopLimitPrice()));
        }

        if (orderOcoRequest.getStopIcebergQty() != null) {
            localVarFormParams.put(
                    "stopIcebergQty",
                    DecimalFormatter.getFormatter().format(orderOcoRequest.getStopIcebergQty()));
        }

        if (orderOcoRequest.getStopLimitTimeInForce() != null) {
            localVarFormParams.put(
                    "stopLimitTimeInForce", orderOcoRequest.getStopLimitTimeInForce());
        }

        if (orderOcoRequest.getNewOrderRespType() != null) {
            localVarFormParams.put("newOrderRespType", orderOcoRequest.getNewOrderRespType());
        }

        if (orderOcoRequest.getSelfTradePreventionMode() != null) {
            localVarFormParams.put(
                    "selfTradePreventionMode", orderOcoRequest.getSelfTradePreventionMode());
        }

        if (orderOcoRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", orderOcoRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call orderOcoValidateBeforeCall(OrderOcoRequest orderOcoRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {orderOcoRequest};
            Method method = this.getClass().getMethod("orderOco", OrderOcoRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return orderOcoCall(orderOcoRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * New OCO - Deprecated Send in a new OCO. * Price Restrictions: * &#x60;SELL&#x60;: Limit Price
     * &gt; Last Price &gt; Stop Price * &#x60;BUY&#x60;: Limit Price &lt; Last Price &lt; Stop
     * Price * Quantity Restrictions: * Both legs must have the same quantity. * &#x60;ICEBERG&#x60;
     * quantities however do not have to be the same * &#x60;OCO&#x60; adds **2 orders** to the
     * &#x60;EXCHANGE_MAX_ORDERS&#x60; filter and the &#x60;MAX_NUM_ORDERS&#x60; filter. Weight: 1
     * Unfilled Order Count: 2
     *
     * @param orderOcoRequest (required)
     * @return ApiResponse&lt;OrderOcoResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> New OCO - Deprecated </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-oco---deprecated-trade">New
     *     OCO - Deprecated Documentation</a>
     */
    public ApiResponse<OrderOcoResponse> orderOco(@Valid @NotNull OrderOcoRequest orderOcoRequest)
            throws ApiException {
        okhttp3.Call localVarCall = orderOcoValidateBeforeCall(orderOcoRequest);
        java.lang.reflect.Type localVarReturnType = new TypeToken<OrderOcoResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for orderTest
     *
     * @param orderTestRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Test new order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#test-new-order-trade">Test
     *     new order Documentation</a>
     */
    private okhttp3.Call orderTestCall(OrderTestRequest orderTestRequest) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v3/order/test";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (orderTestRequest.getComputeCommissionRates() != null) {
            localVarFormParams.put(
                    "computeCommissionRates", orderTestRequest.getComputeCommissionRates());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call orderTestValidateBeforeCall(OrderTestRequest orderTestRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {orderTestRequest};
            Method method = this.getClass().getMethod("orderTest", OrderTestRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return orderTestCall(orderTestRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Test new order Test new order creation and signature/recvWindow long. Creates and validates a
     * new order but does not send it into the matching engine. Weight: |Condition| Request Weight|
     * |------------ | ------------ | |Without &#x60;computeCommissionRates&#x60;| 1| |With
     * &#x60;computeCommissionRates&#x60;|20|
     *
     * @param orderTestRequest (required)
     * @return ApiResponse&lt;OrderTestResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Test new order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#test-new-order-trade">Test
     *     new order Documentation</a>
     */
    public ApiResponse<OrderTestResponse> orderTest(
            @Valid @NotNull OrderTestRequest orderTestRequest) throws ApiException {
        okhttp3.Call localVarCall = orderTestValidateBeforeCall(orderTestRequest);
        java.lang.reflect.Type localVarReturnType = new TypeToken<OrderTestResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for sorOrder
     *
     * @param sorOrderRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> New order using SOR </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-using-sor-trade">New
     *     order using SOR Documentation</a>
     */
    private okhttp3.Call sorOrderCall(SorOrderRequest sorOrderRequest) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v3/sor/order";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (sorOrderRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", sorOrderRequest.getSymbol());
        }

        if (sorOrderRequest.getSide() != null) {
            localVarFormParams.put("side", sorOrderRequest.getSide());
        }

        if (sorOrderRequest.getType() != null) {
            localVarFormParams.put("type", sorOrderRequest.getType());
        }

        if (sorOrderRequest.getTimeInForce() != null) {
            localVarFormParams.put("timeInForce", sorOrderRequest.getTimeInForce());
        }

        if (sorOrderRequest.getQuantity() != null) {
            localVarFormParams.put(
                    "quantity",
                    DecimalFormatter.getFormatter().format(sorOrderRequest.getQuantity()));
        }

        if (sorOrderRequest.getPrice() != null) {
            localVarFormParams.put(
                    "price", DecimalFormatter.getFormatter().format(sorOrderRequest.getPrice()));
        }

        if (sorOrderRequest.getNewClientOrderId() != null) {
            localVarFormParams.put("newClientOrderId", sorOrderRequest.getNewClientOrderId());
        }

        if (sorOrderRequest.getStrategyId() != null) {
            localVarFormParams.put("strategyId", sorOrderRequest.getStrategyId());
        }

        if (sorOrderRequest.getStrategyType() != null) {
            localVarFormParams.put("strategyType", sorOrderRequest.getStrategyType());
        }

        if (sorOrderRequest.getIcebergQty() != null) {
            localVarFormParams.put(
                    "icebergQty",
                    DecimalFormatter.getFormatter().format(sorOrderRequest.getIcebergQty()));
        }

        if (sorOrderRequest.getNewOrderRespType() != null) {
            localVarFormParams.put("newOrderRespType", sorOrderRequest.getNewOrderRespType());
        }

        if (sorOrderRequest.getSelfTradePreventionMode() != null) {
            localVarFormParams.put(
                    "selfTradePreventionMode", sorOrderRequest.getSelfTradePreventionMode());
        }

        if (sorOrderRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", sorOrderRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call sorOrderValidateBeforeCall(SorOrderRequest sorOrderRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {sorOrderRequest};
            Method method = this.getClass().getMethod("sorOrder", SorOrderRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return sorOrderCall(sorOrderRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * New order using SOR Places an order using smart order routing (SOR). This adds 1 order to the
     * &#x60;EXCHANGE_MAX_ORDERS&#x60; filter and the &#x60;MAX_NUM_ORDERS&#x60; filter. Read [SOR
     * FAQ](faqs/sor_faq.md) to learn more. Weight: 1 Unfilled Order Count: 1
     *
     * @param sorOrderRequest (required)
     * @return ApiResponse&lt;SorOrderResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> New order using SOR </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-using-sor-trade">New
     *     order using SOR Documentation</a>
     */
    public ApiResponse<SorOrderResponse> sorOrder(@Valid @NotNull SorOrderRequest sorOrderRequest)
            throws ApiException {
        okhttp3.Call localVarCall = sorOrderValidateBeforeCall(sorOrderRequest);
        java.lang.reflect.Type localVarReturnType = new TypeToken<SorOrderResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for sorOrderTest
     *
     * @param sorOrderTestRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Test new order using SOR </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#test-new-order-using-sor-trade">Test
     *     new order using SOR Documentation</a>
     */
    private okhttp3.Call sorOrderTestCall(SorOrderTestRequest sorOrderTestRequest)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v3/sor/order/test";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (sorOrderTestRequest.getComputeCommissionRates() != null) {
            localVarFormParams.put(
                    "computeCommissionRates", sorOrderTestRequest.getComputeCommissionRates());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call sorOrderTestValidateBeforeCall(SorOrderTestRequest sorOrderTestRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {sorOrderTestRequest};
            Method method = this.getClass().getMethod("sorOrderTest", SorOrderTestRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return sorOrderTestCall(sorOrderTestRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Test new order using SOR Test new order creation and signature/recvWindow using smart order
     * routing (SOR). Creates and validates a new order but does not send it into the matching
     * engine. Weight: | Condition | Request Weight | | --------- | -------------- | | Without
     * &#x60;computeCommissionRates&#x60; | 1 | | With &#x60;computeCommissionRates&#x60; | 20 |
     *
     * @param sorOrderTestRequest (required)
     * @return ApiResponse&lt;SorOrderTestResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Test new order using SOR </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#test-new-order-using-sor-trade">Test
     *     new order using SOR Documentation</a>
     */
    public ApiResponse<SorOrderTestResponse> sorOrderTest(
            @Valid @NotNull SorOrderTestRequest sorOrderTestRequest) throws ApiException {
        okhttp3.Call localVarCall = sorOrderTestValidateBeforeCall(sorOrderTestRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<SorOrderTestResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }
}
