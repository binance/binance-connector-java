/*
 * Binance Derivatives Trading Options REST API
 * OpenAPI Specification for the Binance Derivatives Trading Options REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_options.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.derivatives_trading_options.rest.model.CheckServerTimeResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.ExchangeInformationResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.HistoricalExerciseRecordsResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.KlineCandlestickDataResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.OldTradesLookupResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.OpenInterestResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.OptionMarkPriceResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.OrderBookResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.RecentBlockTradesListResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.RecentTradesListResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.SymbolPriceTickerResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.Ticker24hrPriceChangeStatisticsResponse;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for MarketDataApi */
public class MarketDataApiTest {

    private MarketDataApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new MarketDataApi(apiClientSpy);
    }

    /**
     * Check Server Time
     *
     * <p>Test connectivity to the Rest API and get the current server time. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void checkServerTimeTest() throws ApiException, CryptoException {
        ApiResponse<CheckServerTimeResponse> response = api.checkServerTime();

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/time", actualRequest.url().encodedPath());
    }

    /**
     * Exchange Information
     *
     * <p>Current exchange trading rules and symbol information Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void exchangeInformationTest() throws ApiException, CryptoException {
        ApiResponse<ExchangeInformationResponse> response = api.exchangeInformation();

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/exchangeInfo", actualRequest.url().encodedPath());
    }

    /**
     * Historical Exercise Records
     *
     * <p>Get historical exercise records. * REALISTIC_VALUE_STRICKEN -&gt; Exercised *
     * EXTRINSIC_VALUE_EXPIRED -&gt; Expired OTM Weight: 3
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void historicalExerciseRecordsTest() throws ApiException, CryptoException {
        String underlying = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        ApiResponse<HistoricalExerciseRecordsResponse> response =
                api.historicalExerciseRecords(underlying, startTime, endTime, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/exerciseHistory", actualRequest.url().encodedPath());
    }

    /**
     * Kline/Candlestick Data
     *
     * <p>Kline/candlestick bars for an option symbol. Klines are uniquely identified by their open
     * time. * If startTime and endTime are not sent, the most recent klines are returned. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void klineCandlestickDataTest() throws ApiException, CryptoException {
        String symbol = "";
        String interval = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        ApiResponse<KlineCandlestickDataResponse> response =
                api.klineCandlestickData(symbol, interval, startTime, endTime, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/klines", actualRequest.url().encodedPath());
    }

    /**
     * Old Trades Lookup (MARKET_DATA)
     *
     * <p>Get older market historical trades. Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void oldTradesLookupTest() throws ApiException, CryptoException {
        String symbol = "";
        Long fromId = 1L;
        Long limit = 100L;
        ApiResponse<OldTradesLookupResponse> response = api.oldTradesLookup(symbol, fromId, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/historicalTrades", actualRequest.url().encodedPath());
    }

    /**
     * Open Interest
     *
     * <p>Get open interest for specific underlying asset on specific expiration date. Weight: 0
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void openInterestTest() throws ApiException, CryptoException {
        String underlyingAsset = "";
        String expiration = "";
        ApiResponse<OpenInterestResponse> response = api.openInterest(underlyingAsset, expiration);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/openInterest", actualRequest.url().encodedPath());
    }

    /**
     * Option Mark Price
     *
     * <p>Option mark price and greek info. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void optionMarkPriceTest() throws ApiException, CryptoException {
        String symbol = "";
        ApiResponse<OptionMarkPriceResponse> response = api.optionMarkPrice(symbol);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/mark", actualRequest.url().encodedPath());
    }

    /**
     * Order Book
     *
     * <p>Check orderbook depth on specific symbol Weight: limit | weight ------------ |
     * ------------ 5, 10, 20, 50 | 2 100 | 5 500 | 10 1000 | 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void orderBookTest() throws ApiException, CryptoException {
        String symbol = "";
        Long limit = 100L;
        ApiResponse<OrderBookResponse> response = api.orderBook(symbol, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/depth", actualRequest.url().encodedPath());
    }

    /**
     * Recent Block Trades List
     *
     * <p>Get recent block trades Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void recentBlockTradesListTest() throws ApiException, CryptoException {
        String symbol = "";
        Long limit = 100L;
        ApiResponse<RecentBlockTradesListResponse> response =
                api.recentBlockTradesList(symbol, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/blockTrades", actualRequest.url().encodedPath());
    }

    /**
     * Recent Trades List
     *
     * <p>Get recent market trades Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void recentTradesListTest() throws ApiException, CryptoException {
        String symbol = "";
        Long limit = 100L;
        ApiResponse<RecentTradesListResponse> response = api.recentTradesList(symbol, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/trades", actualRequest.url().encodedPath());
    }

    /**
     * Symbol Price Ticker
     *
     * <p>Get spot index price for option underlying. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void symbolPriceTickerTest() throws ApiException, CryptoException {
        String underlying = "";
        ApiResponse<SymbolPriceTickerResponse> response = api.symbolPriceTicker(underlying);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/index", actualRequest.url().encodedPath());
    }

    /**
     * Test Connectivity
     *
     * <p>Test connectivity to the Rest API. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void testConnectivityTest() throws ApiException, CryptoException {
        api.testConnectivity();

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy).execute(callArgumentCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/ping", actualRequest.url().encodedPath());
    }

    /**
     * 24hr Ticker Price Change Statistics
     *
     * <p>24 hour rolling window price change statistics. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void ticker24hrPriceChangeStatisticsTest() throws ApiException, CryptoException {
        String symbol = "";
        ApiResponse<Ticker24hrPriceChangeStatisticsResponse> response =
                api.ticker24hrPriceChangeStatistics(symbol);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/ticker", actualRequest.url().encodedPath());
    }
}
