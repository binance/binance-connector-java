/*
 * Binance Derivatives Trading Options REST API
 * OpenAPI Specification for the Binance Derivatives Trading Options REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_options.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.derivatives_trading_options.rest.model.AcceptBlockTradeOrderRequest;
import com.binance.connector.client.derivatives_trading_options.rest.model.AcceptBlockTradeOrderResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.AccountBlockTradeListResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.ExtendBlockTradeOrderRequest;
import com.binance.connector.client.derivatives_trading_options.rest.model.ExtendBlockTradeOrderResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.Legs;
import com.binance.connector.client.derivatives_trading_options.rest.model.NewBlockTradeOrderRequest;
import com.binance.connector.client.derivatives_trading_options.rest.model.NewBlockTradeOrderResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.QueryBlockTradeDetailsResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.QueryBlockTradeOrderResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.Side;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for MarketMakerBlockTradeApi */
public class MarketMakerBlockTradeApiTest {

    private MarketMakerBlockTradeApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new MarketMakerBlockTradeApi(apiClientSpy);
    }

    /**
     * Accept Block Trade Order (TRADE)
     *
     * <p>Accept a block trade order Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void acceptBlockTradeOrderTest() throws ApiException, CryptoException {
        AcceptBlockTradeOrderRequest acceptBlockTradeOrderRequest =
                new AcceptBlockTradeOrderRequest();

        acceptBlockTradeOrderRequest.blockOrderMatchingKey("");

        ApiResponse<AcceptBlockTradeOrderResponse> response =
                api.acceptBlockTradeOrder(acceptBlockTradeOrderRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000blockOrderMatchingKey=", signInputCaptor.getValue());
        assertEquals(
                "d7779041fe175cc7ddb8035e21c7ed57583e4398e9dc5b99610e2e0ca442944a",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/block/order/execute", actualRequest.url().encodedPath());
    }

    /**
     * Account Block Trade List (USER_DATA)
     *
     * <p>Gets block trades for a specific account. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void accountBlockTradeListTest() throws ApiException, CryptoException {
        Long endTime = 1641782889000L;
        Long startTime = 1623319461670L;
        String underlying = "";
        Long recvWindow = 5000L;
        ApiResponse<AccountBlockTradeListResponse> response =
                api.accountBlockTradeList(endTime, startTime, underlying, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "endTime=1641782889000&startTime=1623319461670&underlying=&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "933e8ed3a3cfc481c957b452740b714628caeb1ad91262ed96e251eff4b8bd3f",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/block/user-trades", actualRequest.url().encodedPath());
    }

    /**
     * Cancel Block Trade Order (TRADE)
     *
     * <p>Cancel a block trade order. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelBlockTradeOrderTest() throws ApiException, CryptoException {
        String blockOrderMatchingKey = "";
        Long recvWindow = 5000L;
        api.cancelBlockTradeOrder(blockOrderMatchingKey, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy).execute(callArgumentCaptor.capture());

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "blockOrderMatchingKey=&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "ae708c39578286d9f327c8abc95624dc3cc9d4999587112e264986264a52088a",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/block/order/create", actualRequest.url().encodedPath());
    }

    /**
     * Extend Block Trade Order (TRADE)
     *
     * <p>Extends a block trade expire time by 30 mins from the current time. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void extendBlockTradeOrderTest() throws ApiException, CryptoException {
        ExtendBlockTradeOrderRequest extendBlockTradeOrderRequest =
                new ExtendBlockTradeOrderRequest();

        extendBlockTradeOrderRequest.blockOrderMatchingKey("");

        ApiResponse<ExtendBlockTradeOrderResponse> response =
                api.extendBlockTradeOrder(extendBlockTradeOrderRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000blockOrderMatchingKey=", signInputCaptor.getValue());
        assertEquals(
                "d7779041fe175cc7ddb8035e21c7ed57583e4398e9dc5b99610e2e0ca442944a",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/block/order/create", actualRequest.url().encodedPath());
    }

    /**
     * New Block Trade Order (TRADE)
     *
     * <p>Send in a new block trade order. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void newBlockTradeOrderTest() throws ApiException, CryptoException {
        NewBlockTradeOrderRequest newBlockTradeOrderRequest = new NewBlockTradeOrderRequest();

        newBlockTradeOrderRequest.liquidity("");
        newBlockTradeOrderRequest.legs(new Legs());
        newBlockTradeOrderRequest.symbol("");
        newBlockTradeOrderRequest.side(Side.BUY);
        newBlockTradeOrderRequest.price(1d);
        newBlockTradeOrderRequest.quantity(1d);

        ApiResponse<NewBlockTradeOrderResponse> response =
                api.newBlockTradeOrder(newBlockTradeOrderRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=&side=BUY&quantity=1&price=1&legs=%5B%5D&liquidity=",
                signInputCaptor.getValue());
        assertEquals(
                "67602c4e0a54cf28613b373cc457dccf540698cb3148e276c96f32ac09adf599",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/block/order/create", actualRequest.url().encodedPath());
    }

    /**
     * Query Block Trade Details (USER_DATA)
     *
     * <p>Query block trade details; returns block trade details from counterparty&#39;s
     * perspective. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryBlockTradeDetailsTest() throws ApiException, CryptoException {
        String blockOrderMatchingKey = "";
        Long recvWindow = 5000L;
        ApiResponse<QueryBlockTradeDetailsResponse> response =
                api.queryBlockTradeDetails(blockOrderMatchingKey, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "blockOrderMatchingKey=&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "ae708c39578286d9f327c8abc95624dc3cc9d4999587112e264986264a52088a",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/block/order/execute", actualRequest.url().encodedPath());
    }

    /**
     * Query Block Trade Order (TRADE)
     *
     * <p>Check block trade order status. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryBlockTradeOrderTest() throws ApiException, CryptoException {
        String blockOrderMatchingKey = "";
        Long endTime = 1641782889000L;
        Long startTime = 1623319461670L;
        String underlying = "";
        Long recvWindow = 5000L;
        ApiResponse<QueryBlockTradeOrderResponse> response =
                api.queryBlockTradeOrder(
                        blockOrderMatchingKey, endTime, startTime, underlying, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "blockOrderMatchingKey=&endTime=1641782889000&startTime=1623319461670&underlying=&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "12052ae669c254b370aeed981dae5ab6e617de9427448d3232d92d0506899440",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/block/order/orders", actualRequest.url().encodedPath());
    }
}
