/*
 * Binance Derivatives Trading Options REST API
 * OpenAPI Specification for the Binance Derivatives Trading Options REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_options.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.derivatives_trading_options.rest.model.AutoCancelAllOpenOrdersRequest;
import com.binance.connector.client.derivatives_trading_options.rest.model.AutoCancelAllOpenOrdersResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.GetAutoCancelAllOpenOrdersResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.GetMarketMakerProtectionConfigResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.OptionMarginAccountInformationResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.ResetMarketMakerProtectionConfigRequest;
import com.binance.connector.client.derivatives_trading_options.rest.model.ResetMarketMakerProtectionConfigResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.SetAutoCancelAllOpenOrdersRequest;
import com.binance.connector.client.derivatives_trading_options.rest.model.SetAutoCancelAllOpenOrdersResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.SetMarketMakerProtectionConfigRequest;
import com.binance.connector.client.derivatives_trading_options.rest.model.SetMarketMakerProtectionConfigResponse;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for MarketMakerEndpointsApi */
public class MarketMakerEndpointsApiTest {

    private MarketMakerEndpointsApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new MarketMakerEndpointsApi(apiClientSpy);
    }

    /**
     * Auto-Cancel All Open Orders (Kill-Switch) Heartbeat (TRADE)
     *
     * <p>This endpoint resets the time from which the countdown will begin to the time this
     * messaged is received. It should be called repeatedly as heartbeats. Multiple heartbeats can
     * be updated at once by specifying the underlying symbols as a list (ex. BTCUSDT,ETHUSDT) in
     * the underlyings parameter. * The response will only include underlying symbols where the
     * heartbeat has been successfully updated. Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void autoCancelAllOpenOrdersTest() throws ApiException, CryptoException {
        AutoCancelAllOpenOrdersRequest autoCancelAllOpenOrdersRequest =
                new AutoCancelAllOpenOrdersRequest();

        autoCancelAllOpenOrdersRequest.underlyings("");

        ApiResponse<AutoCancelAllOpenOrdersResponse> response =
                api.autoCancelAllOpenOrders(autoCancelAllOpenOrdersRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000underlyings=", signInputCaptor.getValue());
        assertEquals(
                "b0a783c7757273453a4b860469d3051ab1ebf8dec4a85306ec4cd7dd169a68bd",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/countdownCancelAllHeartBeat", actualRequest.url().encodedPath());
    }

    /**
     * Get Auto-Cancel All Open Orders (Kill-Switch) Config (TRADE)
     *
     * <p>This endpoint returns the auto-cancel parameters for each underlying symbol. Note only
     * active auto-cancel parameters will be returned, if countdownTime is set to 0 (ie.
     * countdownTime has been turned off), the underlying symbol and corresponding countdownTime
     * parameter will not be returned in the response. * countdownTime &#x3D; 0 means the function
     * is disabled. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAutoCancelAllOpenOrdersTest() throws ApiException, CryptoException {
        String underlying = "";
        Long recvWindow = 5000L;
        ApiResponse<GetAutoCancelAllOpenOrdersResponse> response =
                api.getAutoCancelAllOpenOrders(underlying, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "underlying=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "b86106356cee58da83b1db58af2ff785ff31edb20e817cebe1782f91df7ddc12",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/countdownCancelAll", actualRequest.url().encodedPath());
    }

    /**
     * Get Market Maker Protection Config (TRADE)
     *
     * <p>Get config for MMP. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getMarketMakerProtectionConfigTest() throws ApiException, CryptoException {
        String underlying = "";
        Long recvWindow = 5000L;
        ApiResponse<GetMarketMakerProtectionConfigResponse> response =
                api.getMarketMakerProtectionConfig(underlying, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "underlying=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "b86106356cee58da83b1db58af2ff785ff31edb20e817cebe1782f91df7ddc12",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/mmp", actualRequest.url().encodedPath());
    }

    /**
     * Option Margin Account Information (USER_DATA)
     *
     * <p>Get current account information. Weight: 3
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void optionMarginAccountInformationTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<OptionMarginAccountInformationResponse> response =
                api.optionMarginAccountInformation(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/marginAccount", actualRequest.url().encodedPath());
    }

    /**
     * Reset Market Maker Protection Config (TRADE)
     *
     * <p>Reset MMP, start MMP order again. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void resetMarketMakerProtectionConfigTest() throws ApiException, CryptoException {
        ResetMarketMakerProtectionConfigRequest resetMarketMakerProtectionConfigRequest =
                new ResetMarketMakerProtectionConfigRequest();

        ApiResponse<ResetMarketMakerProtectionConfigResponse> response =
                api.resetMarketMakerProtectionConfig(resetMarketMakerProtectionConfigRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "53668e00dc92eb93de0b253c301e9fc0c20042b13db384a0ad94b38688a5a84c",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/mmpReset", actualRequest.url().encodedPath());
    }

    /**
     * Set Auto-Cancel All Open Orders (Kill-Switch) Config (TRADE)
     *
     * <p>This endpoint sets the parameters of the auto-cancel feature which cancels all open orders
     * (both market maker protection and non market maker protection order types) of the underlying
     * symbol at the end of the specified countdown time period if no heartbeat message is sent.
     * After the countdown time period, all open orders will be cancelled and new orders will be
     * rejected with error code -2010 until either a heartbeat message is sent or the auto-cancel
     * feature is turned off by setting countdownTime to 0. * This rest endpoint sets up the
     * parameters to cancel your open orders in case of an outage or disconnection. * Example usage:
     * Call this endpoint with a countdownTime value of 10000 (10 seconds) to turn on the
     * auto-cancel feature. If the corresponding countdownCancelAllHeartBeat endpoint is not called
     * within 10 seconds with the specified underlying symbol, all open orders of the specified
     * symbol will be automatically canceled. If this endpoint is called with an countdownTime of 0,
     * the countdown timer will be stopped. * The system will check all countdowns approximately
     * every 1000 milliseconds, **please note that sufficient redundancy should be considered when
     * using this function**. We do not recommend setting the countdown time to be too precise or
     * too small. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void setAutoCancelAllOpenOrdersTest() throws ApiException, CryptoException {
        SetAutoCancelAllOpenOrdersRequest setAutoCancelAllOpenOrdersRequest =
                new SetAutoCancelAllOpenOrdersRequest();

        setAutoCancelAllOpenOrdersRequest.underlying("");
        setAutoCancelAllOpenOrdersRequest.countdownTime(0L);

        ApiResponse<SetAutoCancelAllOpenOrdersResponse> response =
                api.setAutoCancelAllOpenOrders(setAutoCancelAllOpenOrdersRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000countdownTime=0&underlying=", signInputCaptor.getValue());
        assertEquals(
                "3ea20362d32987f98f76e76f49289f7848b16910aefdb250e574f5dd050aad4a",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/countdownCancelAll", actualRequest.url().encodedPath());
    }

    /**
     * Set Market Maker Protection Config (TRADE)
     *
     * <p>Set config for MMP. Market Maker Protection(MMP) is a set of protection mechanism for
     * option market maker, this mechanism is able to prevent mass trading in short period time.
     * Once market maker&#39;s account branches the threshold, the Market Maker Protection will be
     * triggered. When Market Maker Protection triggers, all the current MMP orders will be
     * canceled, new MMP orders will be rejected. Market maker can use this time to reevaluate
     * market and modify order price. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void setMarketMakerProtectionConfigTest() throws ApiException, CryptoException {
        SetMarketMakerProtectionConfigRequest setMarketMakerProtectionConfigRequest =
                new SetMarketMakerProtectionConfigRequest();

        ApiResponse<SetMarketMakerProtectionConfigResponse> response =
                api.setMarketMakerProtectionConfig(setMarketMakerProtectionConfigRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "53668e00dc92eb93de0b253c301e9fc0c20042b13db384a0ad94b38688a5a84c",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/mmpSet", actualRequest.url().encodedPath());
    }
}
