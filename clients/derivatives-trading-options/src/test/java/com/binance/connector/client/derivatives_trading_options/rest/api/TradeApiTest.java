/*
 * Binance Derivatives Trading Options REST API
 * OpenAPI Specification for the Binance Derivatives Trading Options REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_options.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.derivatives_trading_options.rest.model.AccountTradeListResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.CancelAllOptionOrdersByUnderlyingResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.CancelAllOptionOrdersOnSpecificSymbolResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.CancelMultipleOptionOrdersResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.CancelOptionOrderResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.ClientOrderIds;
import com.binance.connector.client.derivatives_trading_options.rest.model.NewOrderRequest;
import com.binance.connector.client.derivatives_trading_options.rest.model.NewOrderResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.OptionPositionInformationResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.OrderIds;
import com.binance.connector.client.derivatives_trading_options.rest.model.Orders;
import com.binance.connector.client.derivatives_trading_options.rest.model.PlaceMultipleOrdersRequest;
import com.binance.connector.client.derivatives_trading_options.rest.model.PlaceMultipleOrdersResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.QueryCurrentOpenOptionOrdersResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.QueryOptionOrderHistoryResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.QuerySingleOrderResponse;
import com.binance.connector.client.derivatives_trading_options.rest.model.Side;
import com.binance.connector.client.derivatives_trading_options.rest.model.Type;
import com.binance.connector.client.derivatives_trading_options.rest.model.UserExerciseRecordResponse;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for TradeApi */
public class TradeApiTest {

    private TradeApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new TradeApi(apiClientSpy);
    }

    /**
     * Account Trade List (USER_DATA)
     *
     * <p>Get trades for a specific account and symbol. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void accountTradeListTest() throws ApiException, CryptoException {
        String symbol = "";
        Long fromId = 1L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<AccountTradeListResponse> response =
                api.accountTradeList(symbol, fromId, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&fromId=1&startTime=1623319461670&endTime=1641782889000&limit=100&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "e6c675628031b06a2cee642f08dd8c2ef4f300380d1b62eeeb68aa3dd76194f1", actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/userTrades", actualRequest.url().encodedPath());
    }

    /**
     * Cancel All Option Orders By Underlying (TRADE)
     *
     * <p>Cancel all active orders on specified underlying. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelAllOptionOrdersByUnderlyingTest() throws ApiException, CryptoException {
        String underlying = "";
        Long recvWindow = 5000L;
        ApiResponse<CancelAllOptionOrdersByUnderlyingResponse> response =
                api.cancelAllOptionOrdersByUnderlying(underlying, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "underlying=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "b86106356cee58da83b1db58af2ff785ff31edb20e817cebe1782f91df7ddc12",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/allOpenOrdersByUnderlying", actualRequest.url().encodedPath());
    }

    /**
     * Cancel all Option orders on specific symbol (TRADE)
     *
     * <p>Cancel all active order on a symbol. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelAllOptionOrdersOnSpecificSymbolTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<CancelAllOptionOrdersOnSpecificSymbolResponse> response =
                api.cancelAllOptionOrdersOnSpecificSymbol(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/eapi/v1/allOpenOrders", actualRequest.url().encodedPath());
    }

    /**
     * Cancel Multiple Option Orders (TRADE)
     *
     * <p>Cancel multiple orders. * At least one instance of &#x60;orderId&#x60; and
     * &#x60;clientOrderId&#x60; must be sent. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelMultipleOptionOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        OrderIds orderIds = null;
        ClientOrderIds clientOrderIds = null;
        Long recvWindow = 5000L;
        ApiResponse<CancelMultipleOptionOrdersResponse> response =
                api.cancelMultipleOptionOrders(symbol, orderIds, clientOrderIds, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/batchOrders", actualRequest.url().encodedPath());
    }

    /**
     * Cancel Option Order (TRADE)
     *
     * <p>Cancel an active order. * At least one instance of &#x60;orderId&#x60; and
     * &#x60;clientOrderId&#x60; must be sent. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelOptionOrderTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        String clientOrderId = "1";
        Long recvWindow = 5000L;
        ApiResponse<CancelOptionOrderResponse> response =
                api.cancelOptionOrder(symbol, orderId, clientOrderId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&orderId=1&clientOrderId=1&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "22bb4aab5007bdfe2006035e30f7f5fe51b409e0fd3e500e4d31970b67154176", actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/order", actualRequest.url().encodedPath());
    }

    /**
     * New Order (TRADE)
     *
     * <p>Send a new order. Weight: 0
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void newOrderTest() throws ApiException, CryptoException {
        NewOrderRequest newOrderRequest = new NewOrderRequest();
        newOrderRequest.symbol("");
        newOrderRequest.side(Side.BUY);
        newOrderRequest.type(Type.LIMIT);
        newOrderRequest.quantity(1.0d);

        ApiResponse<NewOrderResponse> response = api.newOrder(newOrderRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000symbol=&side=BUY&quantity=1&type=LIMIT", signInputCaptor.getValue());
        assertEquals("bd7c3ca01fc9cf18bcbcb549be33525c3f9d56758986c3b229f2a0784fdf9232", actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/order", actualRequest.url().encodedPath());
    }

    /**
     * Option Position Information (USER_DATA)
     *
     * <p>Get current position information. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void optionPositionInformationTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<OptionPositionInformationResponse> response =
                api.optionPositionInformation(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/position", actualRequest.url().encodedPath());
    }

    /**
     * Place Multiple Orders(TRADE)
     *
     * <p>Send multiple option orders. * Parameter rules are same with New Order * Batch orders are
     * processed concurrently, and the order of matching is not guaranteed. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void placeMultipleOrdersTest() throws ApiException, CryptoException {
        PlaceMultipleOrdersRequest placeMultipleOrdersRequest = new PlaceMultipleOrdersRequest();
        placeMultipleOrdersRequest.orders(new Orders());

        ApiResponse<PlaceMultipleOrdersResponse> response =
                api.placeMultipleOrders(placeMultipleOrdersRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000orders=%5B%5D", signInputCaptor.getValue());
        assertEquals(
                "f273926c44bae2debb7be2afff1b241effae47359ba75471bfd81910d65528e2", actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/batchOrders", actualRequest.url().encodedPath());
    }

    /**
     * Query Current Open Option Orders (USER_DATA)
     *
     * <p>Query current all open orders, status: ACCEPTED PARTIALLY_FILLED Weight: 1 for a single
     * symbol; 40 when the symbol parameter is omitted
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryCurrentOpenOptionOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long recvWindow = 5000L;
        ApiResponse<QueryCurrentOpenOptionOrdersResponse> response =
                api.queryCurrentOpenOptionOrders(symbol, orderId, startTime, endTime, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&orderId=1&startTime=1623319461670&endTime=1641782889000&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "51e9f45d125dacba55909402a133899dd5f0956cd707d8d24ff372c34f5a8155",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/openOrders", actualRequest.url().encodedPath());
    }

    /**
     * Query Option Order History (TRADE)
     *
     * <p>Query all finished orders within 5 days, finished status: CANCELLED FILLED REJECTED.
     * Weight: 3
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryOptionOrderHistoryTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<QueryOptionOrderHistoryResponse> response =
                api.queryOptionOrderHistory(symbol, orderId, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&orderId=1&startTime=1623319461670&endTime=1641782889000&limit=100&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "dc0808314025fc813dcde0328cd6754c982d28888760fc74b17e072087eb4895",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/historyOrders", actualRequest.url().encodedPath());
    }

    /**
     * Query Single Order (TRADE)
     *
     * <p>Check an order status. * These orders will not be found: * order status is
     * &#x60;CANCELED&#x60; or &#x60;REJECTED&#x60;, **AND** * order has NO filled trade, **AND** *
     * created time + 3 days &lt; current time * Either &#x60;orderId&#x60; or &#x60;clientOrderId
     * &#x60; must be sent. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void querySingleOrderTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        String clientOrderId = "1";
        Long recvWindow = 5000L;
        ApiResponse<QuerySingleOrderResponse> response =
                api.querySingleOrder(symbol, orderId, clientOrderId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&orderId=1&clientOrderId=1&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "22bb4aab5007bdfe2006035e30f7f5fe51b409e0fd3e500e4d31970b67154176", actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/order", actualRequest.url().encodedPath());
    }

    /**
     * User Exercise Record (USER_DATA)
     *
     * <p>Get account exercise records. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void userExerciseRecordTest() throws ApiException, CryptoException {
        String symbol = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<UserExerciseRecordResponse> response =
                api.userExerciseRecord(symbol, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&startTime=1623319461670&endTime=1641782889000&limit=100&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "3d9795ecfdb1326d191e1c4777f0f21d3abe1b7efbde9431ba818a057bd1dd7f", actualRequest.url().queryParameter("signature"));
        assertEquals("/eapi/v1/exerciseRecord", actualRequest.url().encodedPath());
    }
}
