/*
 * Binance Derivatives Trading Options WebSocket Market Streams
 * OpenAPI Specification for the Binance Derivatives Trading Options WebSocket Market Streams
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_options.websocket.stream.api;

import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.websocket.adapter.stream.StreamConnectionWrapper;
import com.binance.connector.client.common.websocket.configuration.SessionMode;
import com.binance.connector.client.common.websocket.configuration.WebSocketClientConfiguration;
import com.binance.connector.client.common.websocket.dtos.RequestWrapperDTO;
import com.binance.connector.client.common.websocket.service.StreamBlockingQueueWrapper;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.IndexPriceStreamsRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.IndexPriceStreamsResponse;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.KlineCandlestickStreamsRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.KlineCandlestickStreamsResponse;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.MarkPriceRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.MarkPriceResponse;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.NewSymbolInfoRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.NewSymbolInfoResponse;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.OpenInterestRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.OpenInterestResponse;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.PartialBookDepthStreamsRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.PartialBookDepthStreamsResponse;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.Ticker24HourByUnderlyingAssetAndExpirationDataRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.Ticker24HourByUnderlyingAssetAndExpirationDataResponse;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.Ticker24HourRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.Ticker24HourResponse;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.TradeStreamsRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.TradeStreamsResponse;
import java.io.File;
import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Set;
import java.util.concurrent.CompletableFuture;

import org.eclipse.jetty.websocket.api.RemoteEndpoint;
import org.eclipse.jetty.websocket.api.Session;
import org.eclipse.jetty.websocket.client.WebSocketClient;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;
import org.skyscreamer.jsonassert.JSONAssert;

/** API tests for WebsocketMarketStreamsApi */
public class WebsocketMarketStreamsApiTest {

    private WebsocketMarketStreamsApi api;
    private StreamConnectionWrapper connectionSpy;
    private Session sessionMock;

    @BeforeEach
    public void initApiClient() throws Exception {
        URL resource = WebsocketMarketStreamsApi.class.getResource("/test-ed25519-prv-key.pem");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        File file = new File(resource.toURI());
        signatureConfiguration.setPrivateKey(file.getAbsolutePath());
        WebSocketClientConfiguration clientConfiguration = new WebSocketClientConfiguration();
        // @TODO: run tests for LOGON as well
        clientConfiguration.setAutoLogon(false);
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);
        clientConfiguration.setUrl("wss://localhost:8080");

        WebSocketClient webSocketClient = Mockito.mock(WebSocketClient.class);
        CompletableFuture<Session> sessionCompletableFuture = new CompletableFuture<>();
        Mockito.doReturn(sessionCompletableFuture)
                .when(webSocketClient)
                .connect(Mockito.any(), Mockito.any(), Mockito.any());
        sessionMock = Mockito.mock(Session.class);

        RemoteEndpoint remoteEndpointMock = Mockito.mock(RemoteEndpoint.class);
        Mockito.doReturn(remoteEndpointMock).when(sessionMock).getRemote();

        sessionCompletableFuture.complete(sessionMock);
        StreamConnectionWrapper connectionWrapper =
                new StreamConnectionWrapper(clientConfiguration, webSocketClient);
        connectionSpy = Mockito.spy(connectionWrapper);
        Mockito.doReturn(1736393892000L).when(connectionSpy).getTimestamp();
        connectionSpy.connect();
        WebsocketMarketStreamsApi accountApi = new WebsocketMarketStreamsApi(connectionSpy);
        api = Mockito.spy(accountApi);
        Mockito.doReturn("eaf3292c-64b6-4c04-ad4f-4ca2608b42b4").when(api).getRequestID();
    }

    /**
     * Index Price Streams
     *
     * <p>Underlying(e.g ETHUSDT) index stream. Update Speed: 1000ms
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void indexPriceStreamsTest() throws ApiException, URISyntaxException, IOException {
        IndexPriceStreamsRequest indexPriceStreamsRequest = new IndexPriceStreamsRequest();

        indexPriceStreamsRequest.symbol("btcusdt");

        StreamBlockingQueueWrapper<IndexPriceStreamsResponse> response =
                api.indexPriceStreams(indexPriceStreamsRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, IndexPriceStreamsResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, IndexPriceStreamsResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/symbol@index-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Kline/Candlestick Streams
     *
     * <p>The Kline/Candlestick Stream push updates to the current klines/candlestick every 1000
     * milliseconds (if existing). Update Speed: 1000ms
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void klineCandlestickStreamsTest() throws ApiException, URISyntaxException, IOException {
        KlineCandlestickStreamsRequest klineCandlestickStreamsRequest =
                new KlineCandlestickStreamsRequest();

        klineCandlestickStreamsRequest.symbol("btcusdt");
        klineCandlestickStreamsRequest.interval("1m");

        StreamBlockingQueueWrapper<KlineCandlestickStreamsResponse> response =
                api.klineCandlestickStreams(klineCandlestickStreamsRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, KlineCandlestickStreamsResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, KlineCandlestickStreamsResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/symbol@kline_interval-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Mark Price
     *
     * <p>The mark price for all option symbols on specific underlying asset.
     * E.g.[ETH@markPrice](wss://nbstream.binance.com/eoptions/stream?streams&#x3D;ETH@markPrice)
     * Update Speed: 1000ms
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void markPriceTest() throws ApiException, URISyntaxException, IOException {
        MarkPriceRequest markPriceRequest = new MarkPriceRequest();

        markPriceRequest.underlyingAsset("ETH");

        StreamBlockingQueueWrapper<MarkPriceResponse> response = api.markPrice(markPriceRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, MarkPriceResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, MarkPriceResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/underlyingAsset@markPrice-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * New Symbol Info
     *
     * <p>New symbol listing stream. Update Speed: 50ms
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void newSymbolInfoTest() throws ApiException, URISyntaxException, IOException {
        NewSymbolInfoRequest newSymbolInfoRequest = new NewSymbolInfoRequest();

        StreamBlockingQueueWrapper<NewSymbolInfoResponse> response =
                api.newSymbolInfo(newSymbolInfoRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, NewSymbolInfoResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, NewSymbolInfoResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/option_pair-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Open Interest
     *
     * <p>Option open interest for specific underlying asset on specific expiration date.
     * E.g.[ETH@openInterest@221125](wss://nbstream.binance.com/eoptions/stream?streams&#x3D;ETH@openInterest@221125)
     * Update Speed: 60s
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void openInterestTest() throws ApiException, URISyntaxException, IOException {
        OpenInterestRequest openInterestRequest = new OpenInterestRequest();

        openInterestRequest.underlyingAsset("ETH");
        openInterestRequest.expirationDate("220930");

        StreamBlockingQueueWrapper<OpenInterestResponse> response =
                api.openInterest(openInterestRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, OpenInterestResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, OpenInterestResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/underlyingAsset@openInterest@expirationDate-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Partial Book Depth Streams
     *
     * <p>Top **&lt;levels\\&gt;** bids and asks, Valid levels are **&lt;levels\\&gt;** are 10, 20,
     * 50, 100. Update Speed: 100ms or 1000ms, 500ms(default when update speed isn&#39;t used)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void partialBookDepthStreamsTest() throws ApiException, URISyntaxException, IOException {
        PartialBookDepthStreamsRequest partialBookDepthStreamsRequest =
                new PartialBookDepthStreamsRequest();

        partialBookDepthStreamsRequest.symbol("btcusdt");
        partialBookDepthStreamsRequest.levels(10L);
        partialBookDepthStreamsRequest.updateSpeed("100ms");

        StreamBlockingQueueWrapper<PartialBookDepthStreamsResponse> response =
                api.partialBookDepthStreams(partialBookDepthStreamsRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, PartialBookDepthStreamsResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, PartialBookDepthStreamsResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/symbol@depthlevelsupdateSpeed-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * 24-hour TICKER
     *
     * <p>24hr ticker info for all symbols. Only symbols whose ticker info changed will be sent.
     * Update Speed: 1000ms
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void ticker24HourTest() throws ApiException, URISyntaxException, IOException {
        Ticker24HourRequest ticker24HourRequest = new Ticker24HourRequest();

        ticker24HourRequest.symbol("btcusdt");

        StreamBlockingQueueWrapper<Ticker24HourResponse> response =
                api.ticker24Hour(ticker24HourRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, Ticker24HourResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, Ticker24HourResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/symbol@ticker-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * 24-hour TICKER by underlying asset and expiration data
     *
     * <p>24hr ticker info by underlying asset and expiration date.
     * E.g.[ETH@ticker@220930](wss://nbstream.binance.com/eoptions/stream?streams&#x3D;ETH@ticker@220930)
     * Update Speed: 1000ms
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void ticker24HourByUnderlyingAssetAndExpirationDataTest()
            throws ApiException, URISyntaxException, IOException {
        Ticker24HourByUnderlyingAssetAndExpirationDataRequest
                ticker24HourByUnderlyingAssetAndExpirationDataRequest =
                        new Ticker24HourByUnderlyingAssetAndExpirationDataRequest();

        ticker24HourByUnderlyingAssetAndExpirationDataRequest.underlyingAsset("ETH");
        ticker24HourByUnderlyingAssetAndExpirationDataRequest.expirationDate("220930");

        StreamBlockingQueueWrapper<Ticker24HourByUnderlyingAssetAndExpirationDataResponse>
                response =
                        api.ticker24HourByUnderlyingAssetAndExpirationData(
                                ticker24HourByUnderlyingAssetAndExpirationDataRequest);
        ArgumentCaptor<
                        RequestWrapperDTO<
                                Set<String>,
                                Ticker24HourByUnderlyingAssetAndExpirationDataResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, Ticker24HourByUnderlyingAssetAndExpirationDataResponse>
                requestWrapperDTO = callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/underlyingAsset@ticker@expirationDate-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Trade Streams
     *
     * <p>The Trade Streams push raw trade information for specific symbol or underlying asset.
     * E.g.[ETH@trade](wss://nbstream.binance.com/eoptions/stream?streams&#x3D;ETH@trade) Update
     * Speed: 50ms
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void tradeStreamsTest() throws ApiException, URISyntaxException, IOException {
        TradeStreamsRequest tradeStreamsRequest = new TradeStreamsRequest();

        tradeStreamsRequest.symbol("btcusdt");

        StreamBlockingQueueWrapper<TradeStreamsResponse> response =
                api.tradeStreams(tradeStreamsRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, TradeStreamsResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, TradeStreamsResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/symbol@trade-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }
}
