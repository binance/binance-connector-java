/*
 * Binance Derivatives Trading Options WebSocket Market Streams
 * OpenAPI Specification for the Binance Derivatives Trading Options WebSocket Market Streams
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_options.websocket.stream.api;

import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.SystemUtil;
import com.binance.connector.client.common.exception.ConstraintViolationException;
import com.binance.connector.client.common.websocket.adapter.stream.StreamConnectionInterface;
import com.binance.connector.client.common.websocket.adapter.stream.StreamConnectionPoolWrapper;
import com.binance.connector.client.common.websocket.adapter.stream.StreamConnectionWrapper;
import com.binance.connector.client.common.websocket.configuration.WebSocketClientConfiguration;
import com.binance.connector.client.common.websocket.dtos.RequestWrapperDTO;
import com.binance.connector.client.common.websocket.service.StreamBlockingQueue;
import com.binance.connector.client.common.websocket.service.StreamBlockingQueueWrapper;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.JSON;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.DiffBookDepthStreamsRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.DiffBookDepthStreamsResponse;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.IndividualSymbolBookTickerStreamsRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.IndividualSymbolBookTickerStreamsResponse;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.PartialBookDepthStreamsRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.PartialBookDepthStreamsResponse;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.Ticker24HourRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.Ticker24HourResponse;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.TradeStreamsRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.TradeStreamsResponse;
import com.google.gson.reflect.TypeToken;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.constraints.*;
import java.util.Collections;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator;

public class PublicApi {
    private static final String USER_AGENT =
            String.format(
                    "binance-derivatives-trading-options/6.0.0 (Java/%s; %s; %s)",
                    SystemUtil.getJavaVersion(), SystemUtil.getOs(), SystemUtil.getArch());

    private StreamConnectionInterface connection;

    public PublicApi() {}

    public PublicApi(WebSocketClientConfiguration configuration) {
        this(
                configuration.getUsePool()
                        ? new StreamConnectionPoolWrapper(configuration, JSON.getGson())
                        : new StreamConnectionWrapper(configuration, JSON.getGson()));
    }

    public PublicApi(StreamConnectionInterface connection) {
        connection.setUserAgent(USER_AGENT);
        if (!connection.isConnected()) {
            connection.connect();
        }
        this.connection = connection;
    }

    /**
     * Diff Book Depth Streams Bids and asks, pushed every 500 milliseconds, 100 milliseconds (if
     * existing) Update Speed: 100ms or 500ms
     *
     * @param diffBookDepthStreamsRequest (required)
     * @return DiffBookDepthStreamsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Diff Book Depth Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/options-trading/websocket-market-streams/Diff-Book-Depth-Streams">Diff
     *     Book Depth Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<DiffBookDepthStreamsResponse> diffBookDepthStreams(
            DiffBookDepthStreamsRequest diffBookDepthStreamsRequest) throws ApiException {
        StreamBlockingQueue<String> queue = diffBookDepthStreamsRaw(diffBookDepthStreamsRequest);

        TypeToken<DiffBookDepthStreamsResponse> typeToken =
                new TypeToken<DiffBookDepthStreamsResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> diffBookDepthStreamsRaw(
            DiffBookDepthStreamsRequest diffBookDepthStreamsRequest) throws ApiException {
        diffBookDepthStreamsValidateBeforeCall(diffBookDepthStreamsRequest);

        String methodName =
                "/<symbol>@depth@<updateSpeed>"
                        .substring(1)
                        .replace(
                                "<id>",
                                diffBookDepthStreamsRequest.getId() != null
                                        ? diffBookDepthStreamsRequest.getId().toString()
                                        : "")
                        .replace(
                                "<symbol>",
                                diffBookDepthStreamsRequest.getSymbol() != null
                                        ? diffBookDepthStreamsRequest.getSymbol().toString()
                                        : "")
                        .replace(
                                "<updateSpeed>",
                                diffBookDepthStreamsRequest.getUpdateSpeed() != null
                                        ? diffBookDepthStreamsRequest.getUpdateSpeed().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void diffBookDepthStreamsValidateBeforeCall(
            DiffBookDepthStreamsRequest diffBookDepthStreamsRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<DiffBookDepthStreamsRequest>> violations =
                    validator.validate(diffBookDepthStreamsRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Individual Symbol Book Ticker Streams Pushes any update to the best bid or ask&#39;s price or
     * quantity in real-time for a specified symbol. Update Speed: Real-Time
     *
     * @param individualSymbolBookTickerStreamsRequest (required)
     * @return IndividualSymbolBookTickerStreamsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Individual Symbol Book Ticker Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/options-trading/websocket-market-streams/Individual-Symbol-Book-Ticker-Streams">Individual
     *     Symbol Book Ticker Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<IndividualSymbolBookTickerStreamsResponse>
            individualSymbolBookTickerStreams(
                    IndividualSymbolBookTickerStreamsRequest
                            individualSymbolBookTickerStreamsRequest)
                    throws ApiException {
        StreamBlockingQueue<String> queue =
                individualSymbolBookTickerStreamsRaw(individualSymbolBookTickerStreamsRequest);

        TypeToken<IndividualSymbolBookTickerStreamsResponse> typeToken =
                new TypeToken<IndividualSymbolBookTickerStreamsResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> individualSymbolBookTickerStreamsRaw(
            IndividualSymbolBookTickerStreamsRequest individualSymbolBookTickerStreamsRequest)
            throws ApiException {
        individualSymbolBookTickerStreamsValidateBeforeCall(
                individualSymbolBookTickerStreamsRequest);

        String methodName =
                "/<symbol>@bookTicker"
                        .substring(1)
                        .replace(
                                "<id>",
                                individualSymbolBookTickerStreamsRequest.getId() != null
                                        ? individualSymbolBookTickerStreamsRequest
                                                .getId()
                                                .toString()
                                        : "")
                        .replace(
                                "<symbol>",
                                individualSymbolBookTickerStreamsRequest.getSymbol() != null
                                        ? individualSymbolBookTickerStreamsRequest
                                                .getSymbol()
                                                .toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void individualSymbolBookTickerStreamsValidateBeforeCall(
            IndividualSymbolBookTickerStreamsRequest individualSymbolBookTickerStreamsRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<IndividualSymbolBookTickerStreamsRequest>> violations =
                    validator.validate(individualSymbolBookTickerStreamsRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Partial Book Depth Streams Top **&lt;levels\\&gt;** bids and asks, Valid levels are
     * **&lt;levels\\&gt;** are 5, 10, 20. Update Speed: 100ms or 500ms
     *
     * @param partialBookDepthStreamsRequest (required)
     * @return PartialBookDepthStreamsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Partial Book Depth Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/options-trading/websocket-market-streams/Partial-Book-Depth-Streams">Partial
     *     Book Depth Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<PartialBookDepthStreamsResponse> partialBookDepthStreams(
            PartialBookDepthStreamsRequest partialBookDepthStreamsRequest) throws ApiException {
        StreamBlockingQueue<String> queue =
                partialBookDepthStreamsRaw(partialBookDepthStreamsRequest);

        TypeToken<PartialBookDepthStreamsResponse> typeToken =
                new TypeToken<PartialBookDepthStreamsResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> partialBookDepthStreamsRaw(
            PartialBookDepthStreamsRequest partialBookDepthStreamsRequest) throws ApiException {
        partialBookDepthStreamsValidateBeforeCall(partialBookDepthStreamsRequest);

        String methodName =
                "/<symbol>@depth<level>@<updateSpeed>"
                        .substring(1)
                        .replace(
                                "<id>",
                                partialBookDepthStreamsRequest.getId() != null
                                        ? partialBookDepthStreamsRequest.getId().toString()
                                        : "")
                        .replace(
                                "<symbol>",
                                partialBookDepthStreamsRequest.getSymbol() != null
                                        ? partialBookDepthStreamsRequest.getSymbol().toString()
                                        : "")
                        .replace(
                                "<level>",
                                partialBookDepthStreamsRequest.getLevel() != null
                                        ? partialBookDepthStreamsRequest.getLevel().toString()
                                        : "")
                        .replace(
                                "<updateSpeed>",
                                partialBookDepthStreamsRequest.getUpdateSpeed() != null
                                        ? partialBookDepthStreamsRequest.getUpdateSpeed().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void partialBookDepthStreamsValidateBeforeCall(
            PartialBookDepthStreamsRequest partialBookDepthStreamsRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<PartialBookDepthStreamsRequest>> violations =
                    validator.validate(partialBookDepthStreamsRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * 24-hour TICKER 24hr ticker info for all symbols. Only symbols whose ticker info changed will
     * be sent. Update Speed: 1000ms
     *
     * @param ticker24HourRequest (required)
     * @return Ticker24HourResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> 24-hour TICKER </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/options-trading/websocket-market-streams/24-hour-TICKER">24-hour
     *     TICKER Documentation</a>
     */
    public StreamBlockingQueueWrapper<Ticker24HourResponse> ticker24Hour(
            Ticker24HourRequest ticker24HourRequest) throws ApiException {
        StreamBlockingQueue<String> queue = ticker24HourRaw(ticker24HourRequest);

        TypeToken<Ticker24HourResponse> typeToken = new TypeToken<Ticker24HourResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> ticker24HourRaw(Ticker24HourRequest ticker24HourRequest)
            throws ApiException {
        ticker24HourValidateBeforeCall(ticker24HourRequest);

        String methodName =
                "/<symbol>@optionTicker"
                        .substring(1)
                        .replace(
                                "<id>",
                                ticker24HourRequest.getId() != null
                                        ? ticker24HourRequest.getId().toString()
                                        : "")
                        .replace(
                                "<symbol>",
                                ticker24HourRequest.getSymbol() != null
                                        ? ticker24HourRequest.getSymbol().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void ticker24HourValidateBeforeCall(Ticker24HourRequest ticker24HourRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<Ticker24HourRequest>> violations =
                    validator.validate(ticker24HourRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Trade Streams The Trade Streams push raw trade information for specific symbol or underlying
     * asset.
     * E.g.[btcusdt@optionTrade](wss://fstream.binance.com/public/stream?streams&#x3D;btcusdt@optionTrade)
     * Update Speed: 50ms
     *
     * @param tradeStreamsRequest (required)
     * @return TradeStreamsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Trade Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/options-trading/websocket-market-streams/Trade-Streams">Trade
     *     Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<TradeStreamsResponse> tradeStreams(
            TradeStreamsRequest tradeStreamsRequest) throws ApiException {
        StreamBlockingQueue<String> queue = tradeStreamsRaw(tradeStreamsRequest);

        TypeToken<TradeStreamsResponse> typeToken = new TypeToken<TradeStreamsResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> tradeStreamsRaw(TradeStreamsRequest tradeStreamsRequest)
            throws ApiException {
        tradeStreamsValidateBeforeCall(tradeStreamsRequest);

        String methodName =
                "/<symbol>@optionTrade"
                        .substring(1)
                        .replace(
                                "<id>",
                                tradeStreamsRequest.getId() != null
                                        ? tradeStreamsRequest.getId().toString()
                                        : "")
                        .replace(
                                "<symbol>",
                                tradeStreamsRequest.getSymbol() != null
                                        ? tradeStreamsRequest.getSymbol().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void tradeStreamsValidateBeforeCall(TradeStreamsRequest tradeStreamsRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<TradeStreamsRequest>> violations =
                    validator.validate(tradeStreamsRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    public String getRequestID() {
        Random rand = new Random();
        return Integer.toString(Math.abs(rand.nextInt()));
    }
}
