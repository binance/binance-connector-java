/*
 * Binance Derivatives Trading Options WebSocket Market Streams
 * OpenAPI Specification for the Binance Derivatives Trading Options WebSocket Market Streams
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_options.websocket.stream.api;

import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.SystemUtil;
import com.binance.connector.client.common.exception.ConstraintViolationException;
import com.binance.connector.client.common.websocket.adapter.stream.StreamConnectionInterface;
import com.binance.connector.client.common.websocket.adapter.stream.StreamConnectionPoolWrapper;
import com.binance.connector.client.common.websocket.adapter.stream.StreamConnectionWrapper;
import com.binance.connector.client.common.websocket.configuration.WebSocketClientConfiguration;
import com.binance.connector.client.common.websocket.dtos.RequestWrapperDTO;
import com.binance.connector.client.common.websocket.service.StreamBlockingQueue;
import com.binance.connector.client.common.websocket.service.StreamBlockingQueueWrapper;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.JSON;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.IndexPriceStreamsRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.IndexPriceStreamsResponse;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.KlineCandlestickStreamsRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.KlineCandlestickStreamsResponse;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.MarkPriceRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.MarkPriceResponse;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.NewSymbolInfoRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.NewSymbolInfoResponse;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.OpenInterestRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.OpenInterestResponse;
import com.google.gson.reflect.TypeToken;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.constraints.*;
import java.util.Collections;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator;

public class MarketApi {
    private static final String USER_AGENT =
            String.format(
                    "binance-derivatives-trading-options/6.0.0 (Java/%s; %s; %s)",
                    SystemUtil.getJavaVersion(), SystemUtil.getOs(), SystemUtil.getArch());

    private StreamConnectionInterface connection;

    public MarketApi() {}

    public MarketApi(WebSocketClientConfiguration configuration) {
        this(
                configuration.getUsePool()
                        ? new StreamConnectionPoolWrapper(configuration, JSON.getGson())
                        : new StreamConnectionWrapper(configuration, JSON.getGson()));
    }

    public MarketApi(StreamConnectionInterface connection) {
        connection.setUserAgent(USER_AGENT);
        if (!connection.isConnected()) {
            connection.connect();
        }
        this.connection = connection;
    }

    /**
     * Index Price Streams Underlying(e.g ETHUSDT) index stream. Update Speed: 1000ms
     *
     * @param indexPriceStreamsRequest (required)
     * @return IndexPriceStreamsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Index Price Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/options-trading/websocket-market-streams/Index-Price-Streams">Index
     *     Price Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<IndexPriceStreamsResponse> indexPriceStreams(
            IndexPriceStreamsRequest indexPriceStreamsRequest) throws ApiException {
        StreamBlockingQueue<String> queue = indexPriceStreamsRaw(indexPriceStreamsRequest);

        TypeToken<IndexPriceStreamsResponse> typeToken =
                new TypeToken<IndexPriceStreamsResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> indexPriceStreamsRaw(
            IndexPriceStreamsRequest indexPriceStreamsRequest) throws ApiException {
        indexPriceStreamsValidateBeforeCall(indexPriceStreamsRequest);

        String methodName =
                "/!index@arr"
                        .substring(1)
                        .replace(
                                "<id>",
                                indexPriceStreamsRequest.getId() != null
                                        ? indexPriceStreamsRequest.getId().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void indexPriceStreamsValidateBeforeCall(
            IndexPriceStreamsRequest indexPriceStreamsRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<IndexPriceStreamsRequest>> violations =
                    validator.validate(indexPriceStreamsRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Kline/Candlestick Streams The Kline/Candlestick Stream push updates to the current
     * klines/candlestick every 1000 milliseconds (if existing). Update Speed: 1000ms
     *
     * @param klineCandlestickStreamsRequest (required)
     * @return KlineCandlestickStreamsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Kline/Candlestick Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/options-trading/websocket-market-streams/Kline-Candlestick-Streams">Kline/Candlestick
     *     Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<KlineCandlestickStreamsResponse> klineCandlestickStreams(
            KlineCandlestickStreamsRequest klineCandlestickStreamsRequest) throws ApiException {
        StreamBlockingQueue<String> queue =
                klineCandlestickStreamsRaw(klineCandlestickStreamsRequest);

        TypeToken<KlineCandlestickStreamsResponse> typeToken =
                new TypeToken<KlineCandlestickStreamsResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> klineCandlestickStreamsRaw(
            KlineCandlestickStreamsRequest klineCandlestickStreamsRequest) throws ApiException {
        klineCandlestickStreamsValidateBeforeCall(klineCandlestickStreamsRequest);

        String methodName =
                "/<symbol>@kline_<interval>"
                        .substring(1)
                        .replace(
                                "<id>",
                                klineCandlestickStreamsRequest.getId() != null
                                        ? klineCandlestickStreamsRequest.getId().toString()
                                        : "")
                        .replace(
                                "<symbol>",
                                klineCandlestickStreamsRequest.getSymbol() != null
                                        ? klineCandlestickStreamsRequest.getSymbol().toString()
                                        : "")
                        .replace(
                                "<interval>",
                                klineCandlestickStreamsRequest.getInterval() != null
                                        ? klineCandlestickStreamsRequest.getInterval().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void klineCandlestickStreamsValidateBeforeCall(
            KlineCandlestickStreamsRequest klineCandlestickStreamsRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<KlineCandlestickStreamsRequest>> violations =
                    validator.validate(klineCandlestickStreamsRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Mark Price The mark price for all option symbols on specific underlying asset.
     * E.g.[btcusdt@optionMarkPrice](wss://fstream.binance.com/market/stream?streams&#x3D;btcusdt@optionMarkPrice)
     * Update Speed: 1000ms
     *
     * @param markPriceRequest (required)
     * @return MarkPriceResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Mark Price </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/options-trading/websocket-market-streams/Mark-Price">Mark
     *     Price Documentation</a>
     */
    public StreamBlockingQueueWrapper<MarkPriceResponse> markPrice(
            MarkPriceRequest markPriceRequest) throws ApiException {
        StreamBlockingQueue<String> queue = markPriceRaw(markPriceRequest);

        TypeToken<MarkPriceResponse> typeToken = new TypeToken<MarkPriceResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> markPriceRaw(MarkPriceRequest markPriceRequest)
            throws ApiException {
        markPriceValidateBeforeCall(markPriceRequest);

        String methodName =
                "/<underlying>@optionMarkPrice"
                        .substring(1)
                        .replace(
                                "<id>",
                                markPriceRequest.getId() != null
                                        ? markPriceRequest.getId().toString()
                                        : "")
                        .replace(
                                "<underlying>",
                                markPriceRequest.getUnderlying() != null
                                        ? markPriceRequest.getUnderlying().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void markPriceValidateBeforeCall(MarkPriceRequest markPriceRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<MarkPriceRequest>> violations =
                    validator.validate(markPriceRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * New Symbol Info New symbol listing stream. Update Speed: 50ms
     *
     * @param newSymbolInfoRequest (required)
     * @return NewSymbolInfoResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> New Symbol Info </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/options-trading/websocket-market-streams/New-Symbol-Info">New
     *     Symbol Info Documentation</a>
     */
    public StreamBlockingQueueWrapper<NewSymbolInfoResponse> newSymbolInfo(
            NewSymbolInfoRequest newSymbolInfoRequest) throws ApiException {
        StreamBlockingQueue<String> queue = newSymbolInfoRaw(newSymbolInfoRequest);

        TypeToken<NewSymbolInfoResponse> typeToken = new TypeToken<NewSymbolInfoResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> newSymbolInfoRaw(NewSymbolInfoRequest newSymbolInfoRequest)
            throws ApiException {
        newSymbolInfoValidateBeforeCall(newSymbolInfoRequest);

        String methodName =
                "/!optionSymbol"
                        .substring(1)
                        .replace(
                                "<id>",
                                newSymbolInfoRequest.getId() != null
                                        ? newSymbolInfoRequest.getId().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void newSymbolInfoValidateBeforeCall(NewSymbolInfoRequest newSymbolInfoRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<NewSymbolInfoRequest>> violations =
                    validator.validate(newSymbolInfoRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Open Interest Option open interest for specific underlying asset on specific expiration date.
     * E.g.[ethusdt@openInterest@221125](wss://fstream.binance.com/market/stream?streams&#x3D;ethusdt@openInterest@221125)
     * Update Speed: 60s
     *
     * @param openInterestRequest (required)
     * @return OpenInterestResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Open Interest </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/options-trading/websocket-market-streams/Open-Interest">Open
     *     Interest Documentation</a>
     */
    public StreamBlockingQueueWrapper<OpenInterestResponse> openInterest(
            OpenInterestRequest openInterestRequest) throws ApiException {
        StreamBlockingQueue<String> queue = openInterestRaw(openInterestRequest);

        TypeToken<OpenInterestResponse> typeToken = new TypeToken<OpenInterestResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> openInterestRaw(OpenInterestRequest openInterestRequest)
            throws ApiException {
        openInterestValidateBeforeCall(openInterestRequest);

        String methodName =
                "/underlying@optionOpenInterest@<expirationDate>"
                        .substring(1)
                        .replace(
                                "<id>",
                                openInterestRequest.getId() != null
                                        ? openInterestRequest.getId().toString()
                                        : "")
                        .replace(
                                "<expirationDate>",
                                openInterestRequest.getExpirationDate() != null
                                        ? openInterestRequest.getExpirationDate().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void openInterestValidateBeforeCall(OpenInterestRequest openInterestRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<OpenInterestRequest>> violations =
                    validator.validate(openInterestRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    public String getRequestID() {
        Random rand = new Random();
        return Integer.toString(Math.abs(rand.nextInt()));
    }
}
