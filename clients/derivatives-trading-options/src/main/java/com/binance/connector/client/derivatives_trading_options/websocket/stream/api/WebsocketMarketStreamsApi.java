/*
 * Binance Derivatives Trading Options WebSocket Market Streams
 * OpenAPI Specification for the Binance Derivatives Trading Options WebSocket Market Streams
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_options.websocket.stream.api;

import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.exception.ConstraintViolationException;
import com.binance.connector.client.common.websocket.adapter.stream.StreamConnectionInterface;
import com.binance.connector.client.common.websocket.dtos.RequestWrapperDTO;
import com.binance.connector.client.common.websocket.service.StreamBlockingQueue;
import com.binance.connector.client.common.websocket.service.StreamBlockingQueueWrapper;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.IndexPriceStreamsRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.IndexPriceStreamsResponse;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.KlineCandlestickStreamsRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.KlineCandlestickStreamsResponse;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.MarkPriceRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.MarkPriceResponse;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.NewSymbolInfoRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.NewSymbolInfoResponse;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.OpenInterestRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.OpenInterestResponse;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.PartialBookDepthStreamsRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.PartialBookDepthStreamsResponse;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.Ticker24HourByUnderlyingAssetAndExpirationDataRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.Ticker24HourByUnderlyingAssetAndExpirationDataResponse;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.Ticker24HourRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.Ticker24HourResponse;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.TradeStreamsRequest;
import com.binance.connector.client.derivatives_trading_options.websocket.stream.model.TradeStreamsResponse;
import com.google.gson.reflect.TypeToken;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.constraints.*;
import java.util.Collections;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator;

public class WebsocketMarketStreamsApi {
    private StreamConnectionInterface connection;

    public WebsocketMarketStreamsApi() {}

    public WebsocketMarketStreamsApi(StreamConnectionInterface connection) {
        this.connection = connection;
    }

    /**
     * Index Price Streams Underlying(e.g ETHUSDT) index stream. Update Speed: 1000ms
     *
     * @param indexPriceStreamsRequest (required)
     * @return IndexPriceStreamsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Index Price Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/option/websocket-market-streams/Index-Price-Streams">Index
     *     Price Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<IndexPriceStreamsResponse> indexPriceStreams(
            IndexPriceStreamsRequest indexPriceStreamsRequest) throws ApiException {
        StreamBlockingQueue<String> queue = indexPriceStreamsRaw(indexPriceStreamsRequest);

        TypeToken<IndexPriceStreamsResponse> typeToken =
                new TypeToken<IndexPriceStreamsResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> indexPriceStreamsRaw(
            IndexPriceStreamsRequest indexPriceStreamsRequest) throws ApiException {
        indexPriceStreamsValidateBeforeCall(indexPriceStreamsRequest);

        String methodName =
                "/<symbol>@index"
                        .substring(1)
                        .replace(
                                "<id>",
                                indexPriceStreamsRequest.getId() != null
                                        ? indexPriceStreamsRequest.getId().toString()
                                        : "")
                        .replace(
                                "<symbol>",
                                indexPriceStreamsRequest.getSymbol() != null
                                        ? indexPriceStreamsRequest.getSymbol().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void indexPriceStreamsValidateBeforeCall(
            IndexPriceStreamsRequest indexPriceStreamsRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<IndexPriceStreamsRequest>> violations =
                    validator.validate(indexPriceStreamsRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Kline/Candlestick Streams The Kline/Candlestick Stream push updates to the current
     * klines/candlestick every 1000 milliseconds (if existing). Update Speed: 1000ms
     *
     * @param klineCandlestickStreamsRequest (required)
     * @return KlineCandlestickStreamsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Kline/Candlestick Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/option/websocket-market-streams/Kline-Candlestick-Streams">Kline/Candlestick
     *     Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<KlineCandlestickStreamsResponse> klineCandlestickStreams(
            KlineCandlestickStreamsRequest klineCandlestickStreamsRequest) throws ApiException {
        StreamBlockingQueue<String> queue =
                klineCandlestickStreamsRaw(klineCandlestickStreamsRequest);

        TypeToken<KlineCandlestickStreamsResponse> typeToken =
                new TypeToken<KlineCandlestickStreamsResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> klineCandlestickStreamsRaw(
            KlineCandlestickStreamsRequest klineCandlestickStreamsRequest) throws ApiException {
        klineCandlestickStreamsValidateBeforeCall(klineCandlestickStreamsRequest);

        String methodName =
                "/<symbol>@kline_<interval>"
                        .substring(1)
                        .replace(
                                "<id>",
                                klineCandlestickStreamsRequest.getId() != null
                                        ? klineCandlestickStreamsRequest.getId().toString()
                                        : "")
                        .replace(
                                "<symbol>",
                                klineCandlestickStreamsRequest.getSymbol() != null
                                        ? klineCandlestickStreamsRequest.getSymbol().toString()
                                        : "")
                        .replace(
                                "<interval>",
                                klineCandlestickStreamsRequest.getInterval() != null
                                        ? klineCandlestickStreamsRequest.getInterval().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void klineCandlestickStreamsValidateBeforeCall(
            KlineCandlestickStreamsRequest klineCandlestickStreamsRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<KlineCandlestickStreamsRequest>> violations =
                    validator.validate(klineCandlestickStreamsRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Mark Price The mark price for all option symbols on specific underlying asset.
     * E.g.[ETH@markPrice](wss://nbstream.binance.com/eoptions/stream?streams&#x3D;ETH@markPrice)
     * Update Speed: 1000ms
     *
     * @param markPriceRequest (required)
     * @return MarkPriceResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Mark Price </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/option/websocket-market-streams/Mark-Price">Mark
     *     Price Documentation</a>
     */
    public StreamBlockingQueueWrapper<MarkPriceResponse> markPrice(
            MarkPriceRequest markPriceRequest) throws ApiException {
        StreamBlockingQueue<String> queue = markPriceRaw(markPriceRequest);

        TypeToken<MarkPriceResponse> typeToken = new TypeToken<MarkPriceResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> markPriceRaw(MarkPriceRequest markPriceRequest)
            throws ApiException {
        markPriceValidateBeforeCall(markPriceRequest);

        String methodName =
                "/<underlyingAsset>@markPrice"
                        .substring(1)
                        .replace(
                                "<id>",
                                markPriceRequest.getId() != null
                                        ? markPriceRequest.getId().toString()
                                        : "")
                        .replace(
                                "<underlyingAsset>",
                                markPriceRequest.getUnderlyingAsset() != null
                                        ? markPriceRequest.getUnderlyingAsset().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void markPriceValidateBeforeCall(MarkPriceRequest markPriceRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<MarkPriceRequest>> violations =
                    validator.validate(markPriceRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * New Symbol Info New symbol listing stream. Update Speed: 50ms
     *
     * @param newSymbolInfoRequest (required)
     * @return NewSymbolInfoResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> New Symbol Info </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/option/websocket-market-streams/New-Symbol-Info">New
     *     Symbol Info Documentation</a>
     */
    public StreamBlockingQueueWrapper<NewSymbolInfoResponse> newSymbolInfo(
            NewSymbolInfoRequest newSymbolInfoRequest) throws ApiException {
        StreamBlockingQueue<String> queue = newSymbolInfoRaw(newSymbolInfoRequest);

        TypeToken<NewSymbolInfoResponse> typeToken = new TypeToken<NewSymbolInfoResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> newSymbolInfoRaw(NewSymbolInfoRequest newSymbolInfoRequest)
            throws ApiException {
        newSymbolInfoValidateBeforeCall(newSymbolInfoRequest);

        String methodName =
                "/option_pair"
                        .substring(1)
                        .replace(
                                "<id>",
                                newSymbolInfoRequest.getId() != null
                                        ? newSymbolInfoRequest.getId().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void newSymbolInfoValidateBeforeCall(NewSymbolInfoRequest newSymbolInfoRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<NewSymbolInfoRequest>> violations =
                    validator.validate(newSymbolInfoRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Open Interest Option open interest for specific underlying asset on specific expiration date.
     * E.g.[ETH@openInterest@221125](wss://nbstream.binance.com/eoptions/stream?streams&#x3D;ETH@openInterest@221125)
     * Update Speed: 60s
     *
     * @param openInterestRequest (required)
     * @return OpenInterestResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Open Interest </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/option/websocket-market-streams/Open-Interest">Open
     *     Interest Documentation</a>
     */
    public StreamBlockingQueueWrapper<OpenInterestResponse> openInterest(
            OpenInterestRequest openInterestRequest) throws ApiException {
        StreamBlockingQueue<String> queue = openInterestRaw(openInterestRequest);

        TypeToken<OpenInterestResponse> typeToken = new TypeToken<OpenInterestResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> openInterestRaw(OpenInterestRequest openInterestRequest)
            throws ApiException {
        openInterestValidateBeforeCall(openInterestRequest);

        String methodName =
                "/<underlyingAsset>@openInterest@<expirationDate>"
                        .substring(1)
                        .replace(
                                "<id>",
                                openInterestRequest.getId() != null
                                        ? openInterestRequest.getId().toString()
                                        : "")
                        .replace(
                                "<underlyingAsset>",
                                openInterestRequest.getUnderlyingAsset() != null
                                        ? openInterestRequest.getUnderlyingAsset().toString()
                                        : "")
                        .replace(
                                "<expirationDate>",
                                openInterestRequest.getExpirationDate() != null
                                        ? openInterestRequest.getExpirationDate().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void openInterestValidateBeforeCall(OpenInterestRequest openInterestRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<OpenInterestRequest>> violations =
                    validator.validate(openInterestRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Partial Book Depth Streams Top **&lt;levels\\&gt;** bids and asks, Valid levels are
     * **&lt;levels\\&gt;** are 10, 20, 50, 100. Update Speed: 100ms or 1000ms, 500ms(default when
     * update speed isn&#39;t used)
     *
     * @param partialBookDepthStreamsRequest (required)
     * @return PartialBookDepthStreamsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Partial Book Depth Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/option/websocket-market-streams/Partial-Book-Depth-Streams">Partial
     *     Book Depth Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<PartialBookDepthStreamsResponse> partialBookDepthStreams(
            PartialBookDepthStreamsRequest partialBookDepthStreamsRequest) throws ApiException {
        StreamBlockingQueue<String> queue =
                partialBookDepthStreamsRaw(partialBookDepthStreamsRequest);

        TypeToken<PartialBookDepthStreamsResponse> typeToken =
                new TypeToken<PartialBookDepthStreamsResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> partialBookDepthStreamsRaw(
            PartialBookDepthStreamsRequest partialBookDepthStreamsRequest) throws ApiException {
        partialBookDepthStreamsValidateBeforeCall(partialBookDepthStreamsRequest);

        String methodName =
                "/<symbol>@depth<levels>@<updateSpeed>"
                        .substring(1)
                        .replace(
                                "<id>",
                                partialBookDepthStreamsRequest.getId() != null
                                        ? partialBookDepthStreamsRequest.getId().toString()
                                        : "")
                        .replace(
                                "<symbol>",
                                partialBookDepthStreamsRequest.getSymbol() != null
                                        ? partialBookDepthStreamsRequest.getSymbol().toString()
                                        : "")
                        .replace(
                                "<levels>",
                                partialBookDepthStreamsRequest.getLevels() != null
                                        ? partialBookDepthStreamsRequest.getLevels().toString()
                                        : "")
                        .replace(
                                "<updateSpeed>",
                                partialBookDepthStreamsRequest.getUpdateSpeed() != null
                                        ? partialBookDepthStreamsRequest.getUpdateSpeed().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void partialBookDepthStreamsValidateBeforeCall(
            PartialBookDepthStreamsRequest partialBookDepthStreamsRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<PartialBookDepthStreamsRequest>> violations =
                    validator.validate(partialBookDepthStreamsRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * 24-hour TICKER 24hr ticker info for all symbols. Only symbols whose ticker info changed will
     * be sent. Update Speed: 1000ms
     *
     * @param ticker24HourRequest (required)
     * @return Ticker24HourResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> 24-hour TICKER </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/option/websocket-market-streams/24-hour-TICKER">24-hour
     *     TICKER Documentation</a>
     */
    public StreamBlockingQueueWrapper<Ticker24HourResponse> ticker24Hour(
            Ticker24HourRequest ticker24HourRequest) throws ApiException {
        StreamBlockingQueue<String> queue = ticker24HourRaw(ticker24HourRequest);

        TypeToken<Ticker24HourResponse> typeToken = new TypeToken<Ticker24HourResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> ticker24HourRaw(Ticker24HourRequest ticker24HourRequest)
            throws ApiException {
        ticker24HourValidateBeforeCall(ticker24HourRequest);

        String methodName =
                "/<symbol>@ticker"
                        .substring(1)
                        .replace(
                                "<id>",
                                ticker24HourRequest.getId() != null
                                        ? ticker24HourRequest.getId().toString()
                                        : "")
                        .replace(
                                "<symbol>",
                                ticker24HourRequest.getSymbol() != null
                                        ? ticker24HourRequest.getSymbol().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void ticker24HourValidateBeforeCall(Ticker24HourRequest ticker24HourRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<Ticker24HourRequest>> violations =
                    validator.validate(ticker24HourRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * 24-hour TICKER by underlying asset and expiration data 24hr ticker info by underlying asset
     * and expiration date.
     * E.g.[ETH@ticker@220930](wss://nbstream.binance.com/eoptions/stream?streams&#x3D;ETH@ticker@220930)
     * Update Speed: 1000ms
     *
     * @param ticker24HourByUnderlyingAssetAndExpirationDataRequest (required)
     * @return Ticker24HourByUnderlyingAssetAndExpirationDataResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> 24-hour TICKER by underlying asset and expiration data </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/option/websocket-market-streams/24-hour-TICKER-by-underlying-asset-and-expiration-data">24-hour
     *     TICKER by underlying asset and expiration data Documentation</a>
     */
    public StreamBlockingQueueWrapper<Ticker24HourByUnderlyingAssetAndExpirationDataResponse>
            ticker24HourByUnderlyingAssetAndExpirationData(
                    Ticker24HourByUnderlyingAssetAndExpirationDataRequest
                            ticker24HourByUnderlyingAssetAndExpirationDataRequest)
                    throws ApiException {
        StreamBlockingQueue<String> queue =
                ticker24HourByUnderlyingAssetAndExpirationDataRaw(
                        ticker24HourByUnderlyingAssetAndExpirationDataRequest);

        TypeToken<Ticker24HourByUnderlyingAssetAndExpirationDataResponse> typeToken =
                new TypeToken<Ticker24HourByUnderlyingAssetAndExpirationDataResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> ticker24HourByUnderlyingAssetAndExpirationDataRaw(
            Ticker24HourByUnderlyingAssetAndExpirationDataRequest
                    ticker24HourByUnderlyingAssetAndExpirationDataRequest)
            throws ApiException {
        ticker24HourByUnderlyingAssetAndExpirationDataValidateBeforeCall(
                ticker24HourByUnderlyingAssetAndExpirationDataRequest);

        String methodName =
                "/<underlyingAsset>@ticker@<expirationDate>"
                        .substring(1)
                        .replace(
                                "<id>",
                                ticker24HourByUnderlyingAssetAndExpirationDataRequest.getId()
                                                != null
                                        ? ticker24HourByUnderlyingAssetAndExpirationDataRequest
                                                .getId()
                                                .toString()
                                        : "")
                        .replace(
                                "<underlyingAsset>",
                                ticker24HourByUnderlyingAssetAndExpirationDataRequest
                                                        .getUnderlyingAsset()
                                                != null
                                        ? ticker24HourByUnderlyingAssetAndExpirationDataRequest
                                                .getUnderlyingAsset()
                                                .toString()
                                        : "")
                        .replace(
                                "<expirationDate>",
                                ticker24HourByUnderlyingAssetAndExpirationDataRequest
                                                        .getExpirationDate()
                                                != null
                                        ? ticker24HourByUnderlyingAssetAndExpirationDataRequest
                                                .getExpirationDate()
                                                .toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void ticker24HourByUnderlyingAssetAndExpirationDataValidateBeforeCall(
            Ticker24HourByUnderlyingAssetAndExpirationDataRequest
                    ticker24HourByUnderlyingAssetAndExpirationDataRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<Ticker24HourByUnderlyingAssetAndExpirationDataRequest>>
                    violations =
                            validator.validate(
                                    ticker24HourByUnderlyingAssetAndExpirationDataRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Trade Streams The Trade Streams push raw trade information for specific symbol or underlying
     * asset. E.g.[ETH@trade](wss://nbstream.binance.com/eoptions/stream?streams&#x3D;ETH@trade)
     * Update Speed: 50ms
     *
     * @param tradeStreamsRequest (required)
     * @return TradeStreamsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Trade Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/option/websocket-market-streams/Trade-Streams">Trade
     *     Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<TradeStreamsResponse> tradeStreams(
            TradeStreamsRequest tradeStreamsRequest) throws ApiException {
        StreamBlockingQueue<String> queue = tradeStreamsRaw(tradeStreamsRequest);

        TypeToken<TradeStreamsResponse> typeToken = new TypeToken<TradeStreamsResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> tradeStreamsRaw(TradeStreamsRequest tradeStreamsRequest)
            throws ApiException {
        tradeStreamsValidateBeforeCall(tradeStreamsRequest);

        String methodName =
                "/<symbol>@trade"
                        .substring(1)
                        .replace(
                                "<id>",
                                tradeStreamsRequest.getId() != null
                                        ? tradeStreamsRequest.getId().toString()
                                        : "")
                        .replace(
                                "<symbol>",
                                tradeStreamsRequest.getSymbol() != null
                                        ? tradeStreamsRequest.getSymbol().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void tradeStreamsValidateBeforeCall(TradeStreamsRequest tradeStreamsRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<TradeStreamsRequest>> violations =
                    validator.validate(tradeStreamsRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    public String getRequestID() {
        return UUID.randomUUID().toString();
    }
}
