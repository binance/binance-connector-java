/*
 * Binance Derivatives Trading Portfolio Margin Pro REST API
 * OpenAPI Specification for the Binance Derivatives Trading Portfolio Margin Pro REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_portfolio_margin_pro.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.derivatives_trading_portfolio_margin_pro.rest.model.BnbTransferRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin_pro.rest.model.BnbTransferResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin_pro.rest.model.ChangeAutoRepayFuturesStatusRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin_pro.rest.model.ChangeAutoRepayFuturesStatusResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin_pro.rest.model.FundAutoCollectionRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin_pro.rest.model.FundAutoCollectionResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin_pro.rest.model.FundCollectionByAssetRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin_pro.rest.model.FundCollectionByAssetResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin_pro.rest.model.GetAutoRepayFuturesStatusResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin_pro.rest.model.GetPortfolioMarginProAccountBalanceResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin_pro.rest.model.GetPortfolioMarginProAccountInfoResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin_pro.rest.model.GetPortfolioMarginProSpanAccountInfoResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin_pro.rest.model.MintBfusdForPortfolioMarginRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin_pro.rest.model.MintBfusdForPortfolioMarginResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin_pro.rest.model.PortfolioMarginProBankruptcyLoanRepayRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin_pro.rest.model.PortfolioMarginProBankruptcyLoanRepayResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin_pro.rest.model.QueryPortfolioMarginProBankruptcyLoanAmountResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin_pro.rest.model.QueryPortfolioMarginProBankruptcyLoanRepayHistoryResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin_pro.rest.model.QueryPortfolioMarginProNegativeBalanceInterestHistoryResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin_pro.rest.model.RedeemBfusdForPortfolioMarginRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin_pro.rest.model.RedeemBfusdForPortfolioMarginResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin_pro.rest.model.RepayFuturesNegativeBalanceRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin_pro.rest.model.RepayFuturesNegativeBalanceResponse;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for AccountApi */
public class AccountApiTest {

    private AccountApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new AccountApi(apiClientSpy);
    }

    /**
     * BNB transfer(USER_DATA)
     *
     * <p>BNB transfer can be between Margin Account and USDM Account * You can only use this
     * function 2 times per 10 minutes in a rolling manner Weight: 1500
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void bnbTransferTest() throws ApiException, CryptoException {
        BnbTransferRequest bnbTransferRequest = new BnbTransferRequest();

        bnbTransferRequest.amount(1d);
        bnbTransferRequest.transferSide("");

        ApiResponse<BnbTransferResponse> response = api.bnbTransfer(bnbTransferRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000amount=1&transferSide=", signInputCaptor.getValue());
        assertEquals(
                "e16833932c5efb8dd0192481215116c9f1d39b4d46a89360c91c516dfc2487c5",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/portfolio/bnb-transfer", actualRequest.url().encodedPath());
    }

    /**
     * Change Auto-repay-futures Status(TRADE)
     *
     * <p>Change Auto-repay-futures Status Weight: 1500
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void changeAutoRepayFuturesStatusTest() throws ApiException, CryptoException {
        ChangeAutoRepayFuturesStatusRequest changeAutoRepayFuturesStatusRequest =
                new ChangeAutoRepayFuturesStatusRequest();

        changeAutoRepayFuturesStatusRequest.autoRepay("");

        ApiResponse<ChangeAutoRepayFuturesStatusResponse> response =
                api.changeAutoRepayFuturesStatus(changeAutoRepayFuturesStatusRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000autoRepay=", signInputCaptor.getValue());
        assertEquals(
                "89b69711fce80ffb1748b7a96c12374faa2b2afeb21a900f9a8ca0163615964e",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/portfolio/repay-futures-switch", actualRequest.url().encodedPath());
    }

    /**
     * Fund Auto-collection(USER_DATA)
     *
     * <p>Transfers all assets from Futures Account to Margin account * The BNB would not be
     * collected from UM-PM account to the Portfolio Margin account. * You can only use this
     * function 500 times per hour in a rolling manner. Weight: 1500
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void fundAutoCollectionTest() throws ApiException, CryptoException {
        FundAutoCollectionRequest fundAutoCollectionRequest = new FundAutoCollectionRequest();

        ApiResponse<FundAutoCollectionResponse> response =
                api.fundAutoCollection(fundAutoCollectionRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "53668e00dc92eb93de0b253c301e9fc0c20042b13db384a0ad94b38688a5a84c",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/portfolio/auto-collection", actualRequest.url().encodedPath());
    }

    /**
     * Fund Collection by Asset(USER_DATA)
     *
     * <p>Transfers specific asset from Futures Account to Margin account * The BNB transfer is not
     * be supported Weight: 60
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void fundCollectionByAssetTest() throws ApiException, CryptoException {
        FundCollectionByAssetRequest fundCollectionByAssetRequest =
                new FundCollectionByAssetRequest();

        fundCollectionByAssetRequest.asset("");

        ApiResponse<FundCollectionByAssetResponse> response =
                api.fundCollectionByAsset(fundCollectionByAssetRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000asset=", signInputCaptor.getValue());
        assertEquals(
                "733c2733b75fbea096af9abd7a6e22ac4cce318248e66e514087362c82db2bf1",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/portfolio/asset-collection", actualRequest.url().encodedPath());
    }

    /**
     * Get Auto-repay-futures Status(USER_DATA)
     *
     * <p>Query Auto-repay-futures Status Weight: 30
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAutoRepayFuturesStatusTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<GetAutoRepayFuturesStatusResponse> response =
                api.getAutoRepayFuturesStatus(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/portfolio/repay-futures-switch", actualRequest.url().encodedPath());
    }

    /**
     * Get Portfolio Margin Pro Account Balance(USER_DATA)
     *
     * <p>Query Portfolio Margin Pro account balance Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getPortfolioMarginProAccountBalanceTest() throws ApiException, CryptoException {
        String asset = "";
        Long recvWindow = 5000L;
        ApiResponse<GetPortfolioMarginProAccountBalanceResponse> response =
                api.getPortfolioMarginProAccountBalance(asset, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("asset=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "a8610b861691761550acea81c71e6fe676ac39bd2020c66ff1115710eaf265a4",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/portfolio/balance", actualRequest.url().encodedPath());
    }

    /**
     * Get Portfolio Margin Pro Account Info(USER_DATA)
     *
     * <p>Get Portfolio Margin Pro Account Info Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getPortfolioMarginProAccountInfoTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<GetPortfolioMarginProAccountInfoResponse> response =
                api.getPortfolioMarginProAccountInfo(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/portfolio/account", actualRequest.url().encodedPath());
    }

    /**
     * Get Portfolio Margin Pro SPAN Account Info(USER_DATA)
     *
     * <p>Get Portfolio Margin Pro SPAN Account Info (For Portfolio Margin Pro SPAN users only)
     * Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getPortfolioMarginProSpanAccountInfoTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<GetPortfolioMarginProSpanAccountInfoResponse> response =
                api.getPortfolioMarginProSpanAccountInfo(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v2/portfolio/account", actualRequest.url().encodedPath());
    }

    /**
     * Mint BFUSD for Portfolio Margin(TRADE)
     *
     * <p>Mint BFUSD for all types of Portfolio Margin account Weight: 1500
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void mintBfusdForPortfolioMarginTest() throws ApiException, CryptoException {
        MintBfusdForPortfolioMarginRequest mintBfusdForPortfolioMarginRequest =
                new MintBfusdForPortfolioMarginRequest();

        mintBfusdForPortfolioMarginRequest.fromAsset("");
        mintBfusdForPortfolioMarginRequest.targetAsset("");
        mintBfusdForPortfolioMarginRequest.amount(1d);

        ApiResponse<MintBfusdForPortfolioMarginResponse> response =
                api.mintBfusdForPortfolioMargin(mintBfusdForPortfolioMarginRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000amount=1&targetAsset=&fromAsset=",
                signInputCaptor.getValue());
        assertEquals(
                "d714bfb2f91e65ebbaad39e62d090ec5733259dbebd895824c737a3a2585eff5",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/portfolio/mint", actualRequest.url().encodedPath());
    }

    /**
     * Portfolio Margin Pro Bankruptcy Loan Repay
     *
     * <p>Repay Portfolio Margin Pro Bankruptcy Loan Weight: 3000
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void portfolioMarginProBankruptcyLoanRepayTest() throws ApiException, CryptoException {
        PortfolioMarginProBankruptcyLoanRepayRequest portfolioMarginProBankruptcyLoanRepayRequest =
                new PortfolioMarginProBankruptcyLoanRepayRequest();

        ApiResponse<PortfolioMarginProBankruptcyLoanRepayResponse> response =
                api.portfolioMarginProBankruptcyLoanRepay(
                        portfolioMarginProBankruptcyLoanRepayRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/portfolio/repay", actualRequest.url().encodedPath());
    }

    /**
     * Query Portfolio Margin Pro Bankruptcy Loan Amount(USER_DATA)
     *
     * <p>Query Portfolio Margin Pro Bankruptcy Loan Amount * If thereâ€™s no classic portfolio margin
     * bankruptcy loan, the amount would be 0 Weight: 500
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryPortfolioMarginProBankruptcyLoanAmountTest()
            throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<QueryPortfolioMarginProBankruptcyLoanAmountResponse> response =
                api.queryPortfolioMarginProBankruptcyLoanAmount(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/portfolio/pmLoan", actualRequest.url().encodedPath());
    }

    /**
     * Query Portfolio Margin Pro Bankruptcy Loan Repay History(USER_DATA)
     *
     * <p>Query repay history of pmloan for portfolio margin pro. * &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; cannot be longer than 360 days * If &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; not sent, return records of the last 30 days by default. * If
     * &#x60;startTime&#x60;is sent and &#x60;endTime&#x60; is not sent, return records of
     * [startTime, startTime+30d]. * If &#x60;startTime&#x60; is not sent and &#x60;endTime&#x60; is
     * sent, return records of [endTime-30d, endTime]. Weight: 500
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryPortfolioMarginProBankruptcyLoanRepayHistoryTest()
            throws ApiException, CryptoException {
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long current = 1L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<QueryPortfolioMarginProBankruptcyLoanRepayHistoryResponse> response =
                api.queryPortfolioMarginProBankruptcyLoanRepayHistory(
                        startTime, endTime, current, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "startTime=1623319461670&endTime=1641782889000&current=1&size=10&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "2ecc0415a3bdb2963e8030cdf6cf00de6f49d21b71ff939dda42e5756eb8ba66",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/portfolio/pmLoan-history", actualRequest.url().encodedPath());
    }

    /**
     * Query Portfolio Margin Pro Negative Balance Interest History(USER_DATA)
     *
     * <p>Query interest history of negative balance for portfolio margin. Weight: 50
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryPortfolioMarginProNegativeBalanceInterestHistoryTest()
            throws ApiException, CryptoException {
        String asset = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<QueryPortfolioMarginProNegativeBalanceInterestHistoryResponse> response =
                api.queryPortfolioMarginProNegativeBalanceInterestHistory(
                        asset, startTime, endTime, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "asset=&startTime=1623319461670&endTime=1641782889000&size=10&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "08f5e5a6f9b5d64dcf3e4057c1196835facab312d474221a75a08bcfee1c2c0e",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/portfolio/interest-history", actualRequest.url().encodedPath());
    }

    /**
     * Redeem BFUSD for Portfolio Margin(TRADE)
     *
     * <p>Redeem BFUSD for all types of Portfolio Margin account Weight: 1500
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void redeemBfusdForPortfolioMarginTest() throws ApiException, CryptoException {
        RedeemBfusdForPortfolioMarginRequest redeemBfusdForPortfolioMarginRequest =
                new RedeemBfusdForPortfolioMarginRequest();

        redeemBfusdForPortfolioMarginRequest.fromAsset("");
        redeemBfusdForPortfolioMarginRequest.targetAsset("");
        redeemBfusdForPortfolioMarginRequest.amount(1d);

        ApiResponse<RedeemBfusdForPortfolioMarginResponse> response =
                api.redeemBfusdForPortfolioMargin(redeemBfusdForPortfolioMarginRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000amount=1&targetAsset=&fromAsset=",
                signInputCaptor.getValue());
        assertEquals(
                "d714bfb2f91e65ebbaad39e62d090ec5733259dbebd895824c737a3a2585eff5",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/portfolio/redeem", actualRequest.url().encodedPath());
    }

    /**
     * Repay futures Negative Balance(USER_DATA)
     *
     * <p>Repay futures Negative Balance Weight: 1500
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void repayFuturesNegativeBalanceTest() throws ApiException, CryptoException {
        RepayFuturesNegativeBalanceRequest repayFuturesNegativeBalanceRequest =
                new RepayFuturesNegativeBalanceRequest();

        ApiResponse<RepayFuturesNegativeBalanceResponse> response =
                api.repayFuturesNegativeBalance(repayFuturesNegativeBalanceRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "53668e00dc92eb93de0b253c301e9fc0c20042b13db384a0ad94b38688a5a84c",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/portfolio/repay-futures-negative-balance",
                actualRequest.url().encodedPath());
    }
}
