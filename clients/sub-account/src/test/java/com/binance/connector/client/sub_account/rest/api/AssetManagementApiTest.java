/*
 * Binance Sub Account REST API
 * OpenAPI Specification for the Binance Sub Account REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.sub_account.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.sub_account.rest.model.FuturesTransferForSubAccountRequest;
import com.binance.connector.client.sub_account.rest.model.FuturesTransferForSubAccountResponse;
import com.binance.connector.client.sub_account.rest.model.GetDetailOnSubAccountsFuturesAccountResponse;
import com.binance.connector.client.sub_account.rest.model.GetDetailOnSubAccountsFuturesAccountV2Response;
import com.binance.connector.client.sub_account.rest.model.GetDetailOnSubAccountsMarginAccountResponse;
import com.binance.connector.client.sub_account.rest.model.GetMovePositionHistoryForSubAccountResponse;
import com.binance.connector.client.sub_account.rest.model.GetSubAccountDepositAddressResponse;
import com.binance.connector.client.sub_account.rest.model.GetSubAccountDepositHistoryResponse;
import com.binance.connector.client.sub_account.rest.model.GetSummaryOfSubAccountsFuturesAccountResponse;
import com.binance.connector.client.sub_account.rest.model.GetSummaryOfSubAccountsFuturesAccountV2Response;
import com.binance.connector.client.sub_account.rest.model.GetSummaryOfSubAccountsMarginAccountResponse;
import com.binance.connector.client.sub_account.rest.model.MarginTransferForSubAccountRequest;
import com.binance.connector.client.sub_account.rest.model.MarginTransferForSubAccountResponse;
import com.binance.connector.client.sub_account.rest.model.MovePositionForSubAccountRequest;
import com.binance.connector.client.sub_account.rest.model.MovePositionForSubAccountResponse;
import com.binance.connector.client.sub_account.rest.model.OrderArgs;
import com.binance.connector.client.sub_account.rest.model.QuerySubAccountAssetsAssetManagementResponse;
import com.binance.connector.client.sub_account.rest.model.QuerySubAccountAssetsResponse;
import com.binance.connector.client.sub_account.rest.model.QuerySubAccountFuturesAssetTransferHistoryResponse;
import com.binance.connector.client.sub_account.rest.model.QuerySubAccountSpotAssetTransferHistoryResponse;
import com.binance.connector.client.sub_account.rest.model.QuerySubAccountSpotAssetsSummaryResponse;
import com.binance.connector.client.sub_account.rest.model.QueryUniversalTransferHistoryResponse;
import com.binance.connector.client.sub_account.rest.model.SubAccountFuturesAssetTransferRequest;
import com.binance.connector.client.sub_account.rest.model.SubAccountFuturesAssetTransferResponse;
import com.binance.connector.client.sub_account.rest.model.SubAccountTransferHistoryResponse;
import com.binance.connector.client.sub_account.rest.model.TransferToMasterRequest;
import com.binance.connector.client.sub_account.rest.model.TransferToMasterResponse;
import com.binance.connector.client.sub_account.rest.model.TransferToSubAccountOfSameMasterRequest;
import com.binance.connector.client.sub_account.rest.model.TransferToSubAccountOfSameMasterResponse;
import com.binance.connector.client.sub_account.rest.model.UniversalTransferRequest;
import com.binance.connector.client.sub_account.rest.model.UniversalTransferResponse;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for AssetManagementApi */
public class AssetManagementApiTest {

    private AssetManagementApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new AssetManagementApi(apiClientSpy);
    }

    /**
     * Futures Transfer for Sub-account(For Master Account)
     *
     * <p>Futures Transfer for Sub-account * You need to open Enable Spot &amp; Margin Trading
     * permission for the API Key which requests this endpoint. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void futuresTransferForSubAccountTest() throws ApiException, CryptoException {
        FuturesTransferForSubAccountRequest futuresTransferForSubAccountRequest =
                new FuturesTransferForSubAccountRequest();

        futuresTransferForSubAccountRequest.email("sub-account-email@email.com");
        futuresTransferForSubAccountRequest.asset("");
        futuresTransferForSubAccountRequest.amount(1d);
        futuresTransferForSubAccountRequest.type(0L);

        ApiResponse<FuturesTransferForSubAccountResponse> response =
                api.futuresTransferForSubAccount(futuresTransferForSubAccountRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000amount=1&asset=&type=0&email=sub-account-email%40email.com",
                signInputCaptor.getValue());
        assertEquals(
                "bf6b436ab70f514d79e64c39ea94336c5d3f4a29f2b5f1208fc22df45e232930",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/sub-account/futures/transfer", actualRequest.url().encodedPath());
    }

    /**
     * Get Detail on Sub-account&#39;s Futures Account(For Master Account)
     *
     * <p>Get Detail on Sub-account&#39;s Futures Account Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getDetailOnSubAccountsFuturesAccountTest() throws ApiException, CryptoException {
        String email = "sub-account-email@email.com";
        Long recvWindow = 5000L;
        ApiResponse<GetDetailOnSubAccountsFuturesAccountResponse> response =
                api.getDetailOnSubAccountsFuturesAccount(email, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "email=sub-account-email%40email.com&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "bbb3a67207210f851b76211eae9566a7b03cd2d37dde4e5b73d48265f7b9197e",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/sub-account/futures/account", actualRequest.url().encodedPath());
    }

    /**
     * Get Detail on Sub-account&#39;s Futures Account V2(For Master Account)
     *
     * <p>Get Detail on Sub-account&#39;s Futures Account Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getDetailOnSubAccountsFuturesAccountV2Test() throws ApiException, CryptoException {
        String email = "sub-account-email@email.com";
        Long futuresType = 0L;
        Long recvWindow = 5000L;
        ApiResponse<GetDetailOnSubAccountsFuturesAccountV2Response> response =
                api.getDetailOnSubAccountsFuturesAccountV2(email, futuresType, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "email=sub-account-email%40email.com&futuresType=0&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "cc664677d48539d81fe257dafb4f793b0036ed86f73c1bca867f692c34b6b490",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v2/sub-account/futures/account", actualRequest.url().encodedPath());
    }

    /**
     * Get Detail on Sub-account&#39;s Margin Account(For Master Account)
     *
     * <p>Get Detail on Sub-account&#39;s Margin Account Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getDetailOnSubAccountsMarginAccountTest() throws ApiException, CryptoException {
        String email = "sub-account-email@email.com";
        Long recvWindow = 5000L;
        ApiResponse<GetDetailOnSubAccountsMarginAccountResponse> response =
                api.getDetailOnSubAccountsMarginAccount(email, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "email=sub-account-email%40email.com&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "bbb3a67207210f851b76211eae9566a7b03cd2d37dde4e5b73d48265f7b9197e",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/sub-account/margin/account", actualRequest.url().encodedPath());
    }

    /**
     * Get Move Position History for Sub-account (For Master Account)
     *
     * <p>Query move position history * If &#x60;startTime&#x60; and &#x60;endTime&#x60; not sent,
     * return records of the last 90 days by default with 1000 maximum limits * If
     * &#x60;startTime&#x60; is sent and &#x60;endTime&#x60; is not sent, return records of
     * [max(startTime, now-90d), now]. * If &#x60;startTime&#x60; is not sent and
     * &#x60;endTime&#x60; is sent, return records of [max(now,endTime-90d), endTime]. Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getMovePositionHistoryForSubAccountTest() throws ApiException, CryptoException {
        String symbol = "";
        Long page = 0L;
        Long row = 0L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long recvWindow = 5000L;
        ApiResponse<GetMovePositionHistoryForSubAccountResponse> response =
                api.getMovePositionHistoryForSubAccount(
                        symbol, page, row, startTime, endTime, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&startTime=1623319461670&endTime=1641782889000&page=0&row=0&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "18c81a868b2ecf052663446d54492c03815e35deaea39da08a0ba175cb304fa9",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/sub-account/futures/move-position", actualRequest.url().encodedPath());
    }

    /**
     * Get Sub-account Deposit Address(For Master Account)
     *
     * <p>Fetch sub-account deposit address * &#x60;amount&#x60; needs to be sent if using LIGHTNING
     * network Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getSubAccountDepositAddressTest() throws ApiException, CryptoException {
        String email = "sub-account-email@email.com";
        String coin = "";
        String network = "";
        Double amount = 1d;
        Long recvWindow = 5000L;
        ApiResponse<GetSubAccountDepositAddressResponse> response =
                api.getSubAccountDepositAddress(email, coin, network, amount, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "email=sub-account-email%40email.com&coin=&network=&amount=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "8775619e5f1bf1f99041b1f456c76870f8582b64031236aeb73211e3ad0476e0",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/capital/deposit/subAddress", actualRequest.url().encodedPath());
    }

    /**
     * Get Sub-account Deposit History(For Master Account)
     *
     * <p>Fetch sub-account deposit history Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getSubAccountDepositHistoryTest() throws ApiException, CryptoException {
        String email = "sub-account-email@email.com";
        String coin = "";
        Long status = 0L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 1L;
        Long offset = 0L;
        Long recvWindow = 5000L;
        String txId = "1";
        ApiResponse<GetSubAccountDepositHistoryResponse> response =
                api.getSubAccountDepositHistory(
                        email, coin, status, startTime, endTime, limit, offset, recvWindow, txId);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "email=sub-account-email%40email.com&coin=&status=0&startTime=1623319461670&endTime=1641782889000&limit=1&offset=0&recvWindow=5000&txId=1&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "102448e6732e78a00d0cbe9a0530ccb1d103db100236b95997288da33bcc321f",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/capital/deposit/subHisrec", actualRequest.url().encodedPath());
    }

    /**
     * Get Summary of Sub-account&#39;s Futures Account(For Master Account)
     *
     * <p>Get Summary of Sub-account&#39;s Futures Account Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getSummaryOfSubAccountsFuturesAccountTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<GetSummaryOfSubAccountsFuturesAccountResponse> response =
                api.getSummaryOfSubAccountsFuturesAccount(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/sub-account/futures/accountSummary", actualRequest.url().encodedPath());
    }

    /**
     * Get Summary of Sub-account&#39;s Futures Account V2(For Master Account)
     *
     * <p>Get Summary of Sub-account&#39;s Futures Account Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getSummaryOfSubAccountsFuturesAccountV2Test() throws ApiException, CryptoException {
        Long futuresType = 0L;
        Long page = 1L;
        Long limit = 1L;
        Long recvWindow = 5000L;
        ApiResponse<GetSummaryOfSubAccountsFuturesAccountV2Response> response =
                api.getSummaryOfSubAccountsFuturesAccountV2(futuresType, page, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "futuresType=0&page=1&limit=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "91064625cccb59ffc151c9ecf310ad9bab5b73b86da253f2fb2139647c3a43d1",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v2/sub-account/futures/accountSummary", actualRequest.url().encodedPath());
    }

    /**
     * Get Summary of Sub-account&#39;s Margin Account(For Master Account)
     *
     * <p>Get Summary of Sub-account&#39;s Margin Account Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getSummaryOfSubAccountsMarginAccountTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<GetSummaryOfSubAccountsMarginAccountResponse> response =
                api.getSummaryOfSubAccountsMarginAccount(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/sub-account/margin/accountSummary", actualRequest.url().encodedPath());
    }

    /**
     * Margin Transfer for Sub-account(For Master Account)
     *
     * <p>Margin Transfer for Sub-account * You need to open Enable Spot &amp; Margin Trading
     * permission for the API Key which requests this endpoint. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void marginTransferForSubAccountTest() throws ApiException, CryptoException {
        MarginTransferForSubAccountRequest marginTransferForSubAccountRequest =
                new MarginTransferForSubAccountRequest();

        marginTransferForSubAccountRequest.email("sub-account-email@email.com");
        marginTransferForSubAccountRequest.asset("");
        marginTransferForSubAccountRequest.amount(1d);
        marginTransferForSubAccountRequest.type(0L);

        ApiResponse<MarginTransferForSubAccountResponse> response =
                api.marginTransferForSubAccount(marginTransferForSubAccountRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000amount=1&asset=&type=0&email=sub-account-email%40email.com",
                signInputCaptor.getValue());
        assertEquals(
                "bf6b436ab70f514d79e64c39ea94336c5d3f4a29f2b5f1208fc22df45e232930",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/sub-account/margin/transfer", actualRequest.url().encodedPath());
    }

    /**
     * Move Position for Sub-account (For Master Account)
     *
     * <p>Move position between sub-master, master-sub, or sub-sub accounts when necessary * You
     * need to Enable Trading permission for the API Key which requests this endpoint. * This
     * function only support VIP level 7-9. * Only master account can use the function * Quantity
     * should be positive number only * The function support normal account, PM PRO and PM PRO SPAN.
     * * Only support for from account has positions * For all orders in the same orderArgs request,
     * if any symbol’s total close position quantity is bigger than the symbol’s current position
     * quantity, all batch orders in the same list will fail simultaneously. * Only support cross
     * margin mode * The price for move position is MarkPrice only. * Not support for MSA. * Not
     * support for the symbol under Reduce-Only. Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void movePositionForSubAccountTest() throws ApiException, CryptoException {
        MovePositionForSubAccountRequest movePositionForSubAccountRequest =
                new MovePositionForSubAccountRequest();

        movePositionForSubAccountRequest.fromUserEmail("");
        movePositionForSubAccountRequest.toUserEmail("");
        movePositionForSubAccountRequest.productType("");
        movePositionForSubAccountRequest.orderArgs(new OrderArgs());

        ApiResponse<MovePositionForSubAccountResponse> response =
                api.movePositionForSubAccount(movePositionForSubAccountRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000toUserEmail=&fromUserEmail=&orderArgs=%5B%5D&productType=",
                signInputCaptor.getValue());
        assertEquals(
                "41a35ce40a2e93c910c5f84b1e22985e11da6cf58ae1f75e82d2f00fd6f00ead",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/sub-account/futures/move-position", actualRequest.url().encodedPath());
    }

    /**
     * Query Sub-account Assets(For Master Account)
     *
     * <p>Fetch sub-account assets Weight: 60
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void querySubAccountAssetsTest() throws ApiException, CryptoException {
        String email = "sub-account-email@email.com";
        Long recvWindow = 5000L;
        ApiResponse<QuerySubAccountAssetsResponse> response =
                api.querySubAccountAssets(email, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "email=sub-account-email%40email.com&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "bbb3a67207210f851b76211eae9566a7b03cd2d37dde4e5b73d48265f7b9197e",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v3/sub-account/assets", actualRequest.url().encodedPath());
    }

    /**
     * Query Sub-account Assets (For Master Account)(USER_DATA)
     *
     * <p>Fetch sub-account assets Weight: 60
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void querySubAccountAssetsAssetManagementTest() throws ApiException, CryptoException {
        String email = "sub-account-email@email.com";
        Long recvWindow = 5000L;
        ApiResponse<QuerySubAccountAssetsAssetManagementResponse> response =
                api.querySubAccountAssetsAssetManagement(email, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "email=sub-account-email%40email.com&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "bbb3a67207210f851b76211eae9566a7b03cd2d37dde4e5b73d48265f7b9197e",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v4/sub-account/assets", actualRequest.url().encodedPath());
    }

    /**
     * Query Sub-account Futures Asset Transfer History(For Master Account)
     *
     * <p>Query Sub-account Futures Asset Transfer History Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void querySubAccountFuturesAssetTransferHistoryTest()
            throws ApiException, CryptoException {
        String email = "sub-account-email@email.com";
        Long futuresType = 0L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long page = 1L;
        Long limit = 1L;
        Long recvWindow = 5000L;
        ApiResponse<QuerySubAccountFuturesAssetTransferHistoryResponse> response =
                api.querySubAccountFuturesAssetTransferHistory(
                        email, futuresType, startTime, endTime, page, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "email=sub-account-email%40email.com&futuresType=0&startTime=1623319461670&endTime=1641782889000&page=1&limit=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "c4d0e5c4714d29882f1af3ebcc672cfc31cc002bb0830b62109f5aa90e739f99",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/sub-account/futures/internalTransfer", actualRequest.url().encodedPath());
    }

    /**
     * Query Sub-account Spot Asset Transfer History(For Master Account)
     *
     * <p>Query Sub-account Spot Asset Transfer History * fromEmail and toEmail cannot be sent at
     * the same time. * Return fromEmail equal master account email by default. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void querySubAccountSpotAssetTransferHistoryTest() throws ApiException, CryptoException {
        String fromEmail = "";
        String toEmail = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long page = 1L;
        Long limit = 1L;
        Long recvWindow = 5000L;
        ApiResponse<QuerySubAccountSpotAssetTransferHistoryResponse> response =
                api.querySubAccountSpotAssetTransferHistory(
                        fromEmail, toEmail, startTime, endTime, page, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "fromEmail=&toEmail=&startTime=1623319461670&endTime=1641782889000&page=1&limit=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "5a40d1d45de6e9395280b83d016f73de6f73ff423e20c0fcb787a1bc354e420d",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/sub-account/sub/transfer/history", actualRequest.url().encodedPath());
    }

    /**
     * Query Sub-account Spot Assets Summary(For Master Account)
     *
     * <p>Get BTC valued asset summary of subaccounts. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void querySubAccountSpotAssetsSummaryTest() throws ApiException, CryptoException {
        String email = "";
        Long page = 1L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<QuerySubAccountSpotAssetsSummaryResponse> response =
                api.querySubAccountSpotAssetsSummary(email, page, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "email=&page=1&size=10&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "30a3e7836aa5dd96d832dd8e3c856015220d2b5a47b1fa45aad6b3529dd17798",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/sub-account/spotSummary", actualRequest.url().encodedPath());
    }

    /**
     * Query Universal Transfer History(For Master Account)
     *
     * <p>Query Universal Transfer History * fromEmail and toEmail cannot be sent at the same time.
     * * Return fromEmail equal master account email by default. * The query time period must be
     * less than 7 days. * If startTime and endTime not sent, return records of the last 7 days by
     * default. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryUniversalTransferHistoryTest() throws ApiException, CryptoException {
        String fromEmail = "";
        String toEmail = "";
        String clientTranId = "1";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long page = 1L;
        Long limit = 1L;
        Long recvWindow = 5000L;
        ApiResponse<QueryUniversalTransferHistoryResponse> response =
                api.queryUniversalTransferHistory(
                        fromEmail,
                        toEmail,
                        clientTranId,
                        startTime,
                        endTime,
                        page,
                        limit,
                        recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "fromEmail=&toEmail=&clientTranId=1&startTime=1623319461670&endTime=1641782889000&page=1&limit=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "ac017b8d58998a26258f4669f08515619a652c0fdf9090a42bc95c0afa358cd6",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/sub-account/universalTransfer", actualRequest.url().encodedPath());
    }

    /**
     * Sub-account Futures Asset Transfer(For Master Account)
     *
     * <p>Sub-account Futures Asset Transfer * Master account can transfer max 2000 times a minute *
     * There must be sufficient margin balance in futures wallet to execute transferring. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void subAccountFuturesAssetTransferTest() throws ApiException, CryptoException {
        SubAccountFuturesAssetTransferRequest subAccountFuturesAssetTransferRequest =
                new SubAccountFuturesAssetTransferRequest();

        subAccountFuturesAssetTransferRequest.fromEmail("");
        subAccountFuturesAssetTransferRequest.toEmail("");
        subAccountFuturesAssetTransferRequest.futuresType(0L);
        subAccountFuturesAssetTransferRequest.asset("");
        subAccountFuturesAssetTransferRequest.amount(1d);

        ApiResponse<SubAccountFuturesAssetTransferResponse> response =
                api.subAccountFuturesAssetTransfer(subAccountFuturesAssetTransferRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000futuresType=0&amount=1&asset=&toEmail=&fromEmail=",
                signInputCaptor.getValue());
        assertEquals(
                "a51c95722d0cbc7ff57e9310070dd556eda7eb06c2f2475c12de4c0349c9656c",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/sub-account/futures/internalTransfer", actualRequest.url().encodedPath());
    }

    /**
     * Sub-account Transfer History(For Sub-account)
     *
     * <p>Sub-account Transfer History * If type is not sent, the records of type 2: transfer out
     * will be returned by default. * If startTime and endTime are not sent, the recent 30-day data
     * will be returned. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void subAccountTransferHistoryTest() throws ApiException, CryptoException {
        String asset = "";
        Long type = 0L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 1L;
        Boolean returnFailHistory = false;
        Long recvWindow = 5000L;
        ApiResponse<SubAccountTransferHistoryResponse> response =
                api.subAccountTransferHistory(
                        asset, type, startTime, endTime, limit, returnFailHistory, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "asset=&type=0&startTime=1623319461670&endTime=1641782889000&limit=1&returnFailHistory=false&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "f8ec137c5ce8cc18e82982dd1f3ade0cc6487f4878f4c39fe921a213d2be01e8",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/sub-account/transfer/subUserHistory", actualRequest.url().encodedPath());
    }

    /**
     * Transfer to Master(For Sub-account)
     *
     * <p>Transfer to Master * You need to open Enable Spot &amp; Margin Trading permission for the
     * API Key which requests this endpoint. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void transferToMasterTest() throws ApiException, CryptoException {
        TransferToMasterRequest transferToMasterRequest = new TransferToMasterRequest();

        transferToMasterRequest.asset("");
        transferToMasterRequest.amount(1d);

        ApiResponse<TransferToMasterResponse> response =
                api.transferToMaster(transferToMasterRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000amount=1&asset=", signInputCaptor.getValue());
        assertEquals(
                "bdf4ac8bca8190f70887c6f51a3651b89a8e693487de037a66a7d489ebcde7a4",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/sub-account/transfer/subToMaster", actualRequest.url().encodedPath());
    }

    /**
     * Transfer to Sub-account of Same Master(For Sub-account)
     *
     * <p>Transfer to Sub-account of Same Master * You need to open Enable Spot &amp; Margin Trading
     * permission for the API Key which requests this endpoint. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void transferToSubAccountOfSameMasterTest() throws ApiException, CryptoException {
        TransferToSubAccountOfSameMasterRequest transferToSubAccountOfSameMasterRequest =
                new TransferToSubAccountOfSameMasterRequest();

        transferToSubAccountOfSameMasterRequest.toEmail("");
        transferToSubAccountOfSameMasterRequest.asset("");
        transferToSubAccountOfSameMasterRequest.amount(1d);

        ApiResponse<TransferToSubAccountOfSameMasterResponse> response =
                api.transferToSubAccountOfSameMaster(transferToSubAccountOfSameMasterRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000amount=1&asset=&toEmail=", signInputCaptor.getValue());
        assertEquals(
                "227adce1b6fa8cd89964bd4feedcc86fc42fea35068da084d94698405ba251b8",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/sub-account/transfer/subToSub", actualRequest.url().encodedPath());
    }

    /**
     * Universal Transfer(For Master Account)
     *
     * <p>Universal Transfer * You need to enable \&quot;internal transfer\&quot; option for the api
     * key which requests this endpoint. * Transfer from master account by default if fromEmail is
     * not sent. * Transfer to master account by default if toEmail is not sent. * At least either
     * fromEmail or toEmail need to be sent when the fromAccountType and the toAccountType are the
     * same. * Supported transfer scenarios: * &#x60;SPOT&#x60; transfer to &#x60;SPOT&#x60;,
     * &#x60;USDT_FUTURE&#x60;, &#x60;COIN_FUTURE&#x60; (regardless of master or sub) *
     * &#x60;SPOT&#x60;, &#x60;USDT_FUTURE&#x60;, &#x60;COIN_FUTURE&#x60; transfer to
     * &#x60;SPOT&#x60; (regardless of master or sub) * Master account &#x60;SPOT&#x60; transfer to
     * sub-account &#x60;MARGIN(Cross)&#x60;, &#x60;ISOLATED_MARGIN&#x60; * Sub-account
     * &#x60;MARGIN(Cross)&#x60;, &#x60;ISOLATED_MARGIN&#x60; transfer to master account
     * &#x60;SPOT&#x60; * Sub-account &#x60;MARGIN(Cross)&#x60; transfer to Sub-account
     * &#x60;MARGIN(Cross)&#x60; Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void universalTransferTest() throws ApiException, CryptoException {
        UniversalTransferRequest universalTransferRequest = new UniversalTransferRequest();

        universalTransferRequest.fromAccountType("");
        universalTransferRequest.toAccountType("");
        universalTransferRequest.asset("");
        universalTransferRequest.amount(1d);

        ApiResponse<UniversalTransferResponse> response =
                api.universalTransfer(universalTransferRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000fromAccountType=&amount=1&toAccountType=&asset=",
                signInputCaptor.getValue());
        assertEquals(
                "b299285ec20b4728448d2443690e3837d61e4112f0d26f981519c52d26e32928",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/sub-account/universalTransfer", actualRequest.url().encodedPath());
    }
}
