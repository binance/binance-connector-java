/*
 * Binance Sub Account REST API
 * OpenAPI Specification for the Binance Sub Account REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.sub_account.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.sub_account.rest.model.CreateAVirtualSubAccountRequest;
import com.binance.connector.client.sub_account.rest.model.CreateAVirtualSubAccountResponse;
import com.binance.connector.client.sub_account.rest.model.EnableFuturesForSubAccountRequest;
import com.binance.connector.client.sub_account.rest.model.EnableFuturesForSubAccountResponse;
import com.binance.connector.client.sub_account.rest.model.EnableLeverageTokenForSubAccountRequest;
import com.binance.connector.client.sub_account.rest.model.EnableLeverageTokenForSubAccountResponse;
import com.binance.connector.client.sub_account.rest.model.EnableMarginForSubAccountRequest;
import com.binance.connector.client.sub_account.rest.model.EnableMarginForSubAccountResponse;
import com.binance.connector.client.sub_account.rest.model.EnableOptionsForSubAccountRequest;
import com.binance.connector.client.sub_account.rest.model.EnableOptionsForSubAccountResponse;
import com.binance.connector.client.sub_account.rest.model.GetFuturesPositionRiskOfSubAccountResponse;
import com.binance.connector.client.sub_account.rest.model.GetFuturesPositionRiskOfSubAccountV2Response;
import com.binance.connector.client.sub_account.rest.model.GetSubAccountsStatusOnMarginOrFuturesResponse;
import com.binance.connector.client.sub_account.rest.model.QuerySubAccountListResponse;
import com.binance.connector.client.sub_account.rest.model.QuerySubAccountTransactionStatisticsResponse;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for AccountManagementApi */
public class AccountManagementApiTest {

    private AccountManagementApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new AccountManagementApi(apiClientSpy);
    }

    /**
     * Create a Virtual Sub-account(For Master Account)
     *
     * <p>Create a Virtual Sub-account * This request will generate a virtual sub account under your
     * master account. * You need to enable \&quot;trade\&quot; option for the API Key which
     * requests this endpoint. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createAVirtualSubAccountTest() throws ApiException, CryptoException {
        CreateAVirtualSubAccountRequest createAVirtualSubAccountRequest =
                new CreateAVirtualSubAccountRequest();

        createAVirtualSubAccountRequest.subAccountString("");

        ApiResponse<CreateAVirtualSubAccountResponse> response =
                api.createAVirtualSubAccount(createAVirtualSubAccountRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("17957384d6df5c7c6e52eefb50fa8aab7e6c71cb463c5010af594789262b22f5", actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/sub-account/virtualSubAccount", actualRequest.url().encodedPath());
    }

    /**
     * Enable Futures for Sub-account(For Master Account)
     *
     * <p>Enable Futures for Sub-account for Master Account Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void enableFuturesForSubAccountTest() throws ApiException, CryptoException {
        EnableFuturesForSubAccountRequest enableFuturesForSubAccountRequest =
                new EnableFuturesForSubAccountRequest();

        enableFuturesForSubAccountRequest.email("sub-account-email@email.com");

        ApiResponse<EnableFuturesForSubAccountResponse> response =
                api.enableFuturesForSubAccount(enableFuturesForSubAccountRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("f67b06b499d40c01558e887eeacedf34d4c15093e3369cc524fd961d26d2a511", actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/sub-account/futures/enable", actualRequest.url().encodedPath());
    }

    /**
     * Enable Leverage Token for Sub-account(For Master Account)
     *
     * <p>Enable Leverage Token for Sub-account Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void enableLeverageTokenForSubAccountTest() throws ApiException, CryptoException {
        EnableLeverageTokenForSubAccountRequest enableLeverageTokenForSubAccountRequest =
                new EnableLeverageTokenForSubAccountRequest();

        enableLeverageTokenForSubAccountRequest.email("sub-account-email@email.com");
        enableLeverageTokenForSubAccountRequest.enableBlvt(true);

        ApiResponse<EnableLeverageTokenForSubAccountResponse> response =
                api.enableLeverageTokenForSubAccount(enableLeverageTokenForSubAccountRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("5637c5d98dd70674f12e4b6ae5f4f7f3a6c15655aff997d057d7e9b4ceadf77c", actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/sub-account/blvt/enable", actualRequest.url().encodedPath());
    }

    /**
     * Enable Margin for Sub-account(For Master Account)
     *
     * <p>Enable Margin for Sub-account Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void enableMarginForSubAccountTest() throws ApiException, CryptoException {
        EnableMarginForSubAccountRequest enableMarginForSubAccountRequest =
                new EnableMarginForSubAccountRequest();

        enableMarginForSubAccountRequest.email("sub-account-email@email.com");

        ApiResponse<EnableMarginForSubAccountResponse> response =
                api.enableMarginForSubAccount(enableMarginForSubAccountRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("f67b06b499d40c01558e887eeacedf34d4c15093e3369cc524fd961d26d2a511", actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/sub-account/margin/enable", actualRequest.url().encodedPath());
    }

    /**
     * Enable Options for Sub-account(For Master Account)(USER_DATA)
     *
     * <p>Enable Options for Sub-account (For Master Account). Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void enableOptionsForSubAccountTest() throws ApiException, CryptoException {
        EnableOptionsForSubAccountRequest enableOptionsForSubAccountRequest =
                new EnableOptionsForSubAccountRequest();

        enableOptionsForSubAccountRequest.email("sub-account-email@email.com");

        ApiResponse<EnableOptionsForSubAccountResponse> response =
                api.enableOptionsForSubAccount(enableOptionsForSubAccountRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000email=sub-account-email%40email.com",
                signInputCaptor.getValue());
        assertEquals(
                "f67b06b499d40c01558e887eeacedf34d4c15093e3369cc524fd961d26d2a511",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/sub-account/eoptions/enable", actualRequest.url().encodedPath());
    }

    /**
     * Get Futures Position-Risk of Sub-account(For Master Account)
     *
     * <p>Get Futures Position-Risk of Sub-account Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFuturesPositionRiskOfSubAccountTest() throws ApiException, CryptoException {
        String email = "sub-account-email@email.com";
        Long recvWindow = 5000L;
        ApiResponse<GetFuturesPositionRiskOfSubAccountResponse> response =
                api.getFuturesPositionRiskOfSubAccount(email, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("3627893cb3382cf179e0cfae2f3930dac37e198f7481c0d1f4be6bc7a77e805e", actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/sub-account/futures/positionRisk", actualRequest.url().encodedPath());
    }

    /**
     * Get Futures Position-Risk of Sub-account V2(For Master Account)
     *
     * <p>Get Futures Position-Risk of Sub-account V2 Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFuturesPositionRiskOfSubAccountV2Test() throws ApiException, CryptoException {
        String email = "sub-account-email@email.com";
        Long futuresType = 0L;
        Long recvWindow = 5000L;
        ApiResponse<GetFuturesPositionRiskOfSubAccountV2Response> response =
                api.getFuturesPositionRiskOfSubAccountV2(email, futuresType, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("f83d909c67d7b9183d31693172d49339f470b3a9cab79782ff7c368c5001676c", actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v2/sub-account/futures/positionRisk", actualRequest.url().encodedPath());
    }

    /**
     * Get Sub-account&#39;s Status on Margin Or Futures(For Master Account)
     *
     * <p>Get Sub-account&#39;s Status on Margin Or Futures * If no email sent, all
     * sub-accounts&#39; information will be returned. Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getSubAccountsStatusOnMarginOrFuturesTest() throws ApiException, CryptoException {
        String email = "";
        Long recvWindow = 5000L;
        ApiResponse<GetSubAccountsStatusOnMarginOrFuturesResponse> response =
                api.getSubAccountsStatusOnMarginOrFutures(email, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("ca098fe86ad4ca7fbb1763dbb32c5c8f0611c1ee3dd0334fa79e767a306b3ab9", actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/sub-account/status", actualRequest.url().encodedPath());
    }

    /**
     * Query Sub-account List(For Master Account)
     *
     * <p>Query Sub-account List Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void querySubAccountListTest() throws ApiException, CryptoException {
        String email = "";
        String isFreeze = "";
        Long page = 1L;
        Long limit = 1L;
        Long recvWindow = 5000L;
        ApiResponse<QuerySubAccountListResponse> response =
                api.querySubAccountList(email, isFreeze, page, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("563b2264a7851ddf9f32d76d6be3966d159a697f45e7ebbafe60f7d561e426c6", actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/sub-account/list", actualRequest.url().encodedPath());
    }

    /**
     * Query Sub-account Transaction Statistics(For Master Account)(USER_DATA)
     *
     * <p>Query Sub-account Transaction statistics (For Master Account). Weight: 60
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void querySubAccountTransactionStatisticsTest() throws ApiException, CryptoException {
        String email = "sub-account-email@email.com";
        Long recvWindow = 5000L;
        ApiResponse<QuerySubAccountTransactionStatisticsResponse> response =
                api.querySubAccountTransactionStatistics(email, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "email=sub-account-email@email.com&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "3627893cb3382cf179e0cfae2f3930dac37e198f7481c0d1f4be6bc7a77e805e",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/sub-account/transaction-statistics", actualRequest.url().encodedPath());
    }
}
