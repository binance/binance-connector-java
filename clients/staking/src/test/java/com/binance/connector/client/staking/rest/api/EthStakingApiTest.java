/*
 * Binance Staking REST API
 * OpenAPI Specification for the Binance Staking REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.staking.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.staking.rest.model.EthStakingAccountResponse;
import com.binance.connector.client.staking.rest.model.GetCurrentEthStakingQuotaResponse;
import com.binance.connector.client.staking.rest.model.GetEthRedemptionHistoryResponse;
import com.binance.connector.client.staking.rest.model.GetEthStakingHistoryResponse;
import com.binance.connector.client.staking.rest.model.GetWbethRateHistoryResponse;
import com.binance.connector.client.staking.rest.model.GetWbethRewardsHistoryResponse;
import com.binance.connector.client.staking.rest.model.GetWbethUnwrapHistoryResponse;
import com.binance.connector.client.staking.rest.model.GetWbethWrapHistoryResponse;
import com.binance.connector.client.staking.rest.model.RedeemEthRequest;
import com.binance.connector.client.staking.rest.model.RedeemEthResponse;
import com.binance.connector.client.staking.rest.model.SubscribeEthStakingRequest;
import com.binance.connector.client.staking.rest.model.SubscribeEthStakingResponse;
import com.binance.connector.client.staking.rest.model.WrapBethRequest;
import com.binance.connector.client.staking.rest.model.WrapBethResponse;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for EthStakingApi */
public class EthStakingApiTest {

    private EthStakingApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new EthStakingApi(apiClientSpy);
    }

    /**
     * ETH Staking account(USER_DATA)
     *
     * <p>ETH Staking account Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void ethStakingAccountTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<EthStakingAccountResponse> response = api.ethStakingAccount(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v2/eth-staking/account", actualRequest.url().encodedPath());
    }

    /**
     * Get current ETH staking quota(USER_DATA)
     *
     * <p>Get current ETH staking quota Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getCurrentEthStakingQuotaTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<GetCurrentEthStakingQuotaResponse> response =
                api.getCurrentEthStakingQuota(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/eth-staking/eth/quota", actualRequest.url().encodedPath());
    }

    /**
     * Get ETH redemption history(USER_DATA)
     *
     * <p>Get ETH redemption history * The time between &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; cannot be longer than 3 months. * If &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; are both not sent, then the last 30 days&#39; data will be returned. * If
     * &#x60;startTime&#x60; is sent but &#x60;endTime&#x60; is not sent, the next 30 days&#39; data
     * beginning from &#x60;startTime&#x60; will be returned. * If &#x60;endTime&#x60; is sent but
     * &#x60;startTime&#x60; is not sent, the 30 days&#39; data before &#x60;endTime&#x60; will be
     * returned. Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getEthRedemptionHistoryTest() throws ApiException, CryptoException {
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long current = 1L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<GetEthRedemptionHistoryResponse> response =
                api.getEthRedemptionHistory(startTime, endTime, current, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "startTime=1623319461670&endTime=1641782889000&current=1&size=10&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "2ecc0415a3bdb2963e8030cdf6cf00de6f49d21b71ff939dda42e5756eb8ba66",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/eth-staking/eth/history/redemptionHistory",
                actualRequest.url().encodedPath());
    }

    /**
     * Get ETH staking history(USER_DATA)
     *
     * <p>Get ETH staking history * The time between &#x60;startTime&#x60; and &#x60;endTime&#x60;
     * cannot be longer than 3 months. * If &#x60;startTime&#x60; and &#x60;endTime&#x60; are both
     * not sent, then the last 30 days&#39; data will be returned. * If &#x60;startTime&#x60; is
     * sent but &#x60;endTime&#x60; is not sent, the next 30 days&#39; data beginning from
     * &#x60;startTime&#x60; will be returned. * If &#x60;endTime&#x60; is sent but
     * &#x60;startTime&#x60; is not sent, the 30 days&#39; data before &#x60;endTime&#x60; will be
     * returned. Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getEthStakingHistoryTest() throws ApiException, CryptoException {
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long current = 1L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<GetEthStakingHistoryResponse> response =
                api.getEthStakingHistory(startTime, endTime, current, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "startTime=1623319461670&endTime=1641782889000&current=1&size=10&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "2ecc0415a3bdb2963e8030cdf6cf00de6f49d21b71ff939dda42e5756eb8ba66",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/eth-staking/eth/history/stakingHistory",
                actualRequest.url().encodedPath());
    }

    /**
     * Get WBETH Rate History(USER_DATA)
     *
     * <p>Get WBETH Rate History * The time between &#x60;startTime&#x60; and &#x60;endTime&#x60;
     * cannot be longer than 3 months. * If &#x60;startTime&#x60; and &#x60;endTime&#x60; are both
     * not sent, then the last 30 days&#39; data will be returned. * If &#x60;startTime&#x60; is
     * sent but &#x60;endTime&#x60; is not sent, the next 30 days&#39; data beginning from
     * &#x60;startTime&#x60; will be returned. * If &#x60;endTime&#x60; is sent but
     * &#x60;startTime&#x60; is not sent, the 30 days&#39; data before &#x60;endTime&#x60; will be
     * returned. Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getWbethRateHistoryTest() throws ApiException, CryptoException {
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long current = 1L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<GetWbethRateHistoryResponse> response =
                api.getWbethRateHistory(startTime, endTime, current, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "startTime=1623319461670&endTime=1641782889000&current=1&size=10&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "2ecc0415a3bdb2963e8030cdf6cf00de6f49d21b71ff939dda42e5756eb8ba66",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/eth-staking/eth/history/rateHistory", actualRequest.url().encodedPath());
    }

    /**
     * Get WBETH rewards history(USER_DATA)
     *
     * <p>Get WBETH rewards history * The time between &#x60;startTime&#x60; and &#x60;endTime&#x60;
     * cannot be longer than 3 months. * If &#x60;startTime&#x60; and &#x60;endTime&#x60; are both
     * not sent, then the last 30 days&#39; data will be returned. * If &#x60;startTime&#x60; is
     * sent but &#x60;endTime&#x60; is not sent, the next 30 days&#39; data beginning from
     * &#x60;startTime&#x60; will be returned. * If &#x60;endTime&#x60; is sent but
     * &#x60;startTime&#x60; is not sent, the 30 days&#39; data before &#x60;endTime&#x60; will be
     * returned. Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getWbethRewardsHistoryTest() throws ApiException, CryptoException {
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long current = 1L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<GetWbethRewardsHistoryResponse> response =
                api.getWbethRewardsHistory(startTime, endTime, current, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "startTime=1623319461670&endTime=1641782889000&current=1&size=10&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "2ecc0415a3bdb2963e8030cdf6cf00de6f49d21b71ff939dda42e5756eb8ba66",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/eth-staking/eth/history/wbethRewardsHistory",
                actualRequest.url().encodedPath());
    }

    /**
     * Get WBETH unwrap history(USER_DATA)
     *
     * <p>Get WBETH unwrap history * The time between &#x60;startTime&#x60; and &#x60;endTime&#x60;
     * cannot be longer than 3 months. * If &#x60;startTime&#x60; and &#x60;endTime&#x60; are both
     * not sent, then the last 30 days&#39; data will be returned. * If &#x60;startTime&#x60; is
     * sent but &#x60;endTime&#x60; is not sent, the next 30 days&#39; data beginning from
     * &#x60;startTime&#x60; will be returned. * If &#x60;endTime&#x60; is sent but
     * &#x60;startTime&#x60; is not sent, the 30 days&#39; data before &#x60;endTime&#x60; will be
     * returned. Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getWbethUnwrapHistoryTest() throws ApiException, CryptoException {
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long current = 1L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<GetWbethUnwrapHistoryResponse> response =
                api.getWbethUnwrapHistory(startTime, endTime, current, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "startTime=1623319461670&endTime=1641782889000&current=1&size=10&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "2ecc0415a3bdb2963e8030cdf6cf00de6f49d21b71ff939dda42e5756eb8ba66",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/eth-staking/wbeth/history/unwrapHistory",
                actualRequest.url().encodedPath());
    }

    /**
     * Get WBETH wrap history(USER_DATA)
     *
     * <p>Get WBETH wrap history * The time between &#x60;startTime&#x60; and &#x60;endTime&#x60;
     * cannot be longer than 3 months. * If &#x60;startTime&#x60; and &#x60;endTime&#x60; are both
     * not sent, then the last 30 days&#39; data will be returned. * If &#x60;startTime&#x60; is
     * sent but &#x60;endTime&#x60; is not sent, the next 30 days&#39; data beginning from
     * &#x60;startTime&#x60; will be returned. * If &#x60;endTime&#x60; is sent but
     * &#x60;startTime&#x60; is not sent, the 30 days&#39; data before &#x60;endTime&#x60; will be
     * returned. Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getWbethWrapHistoryTest() throws ApiException, CryptoException {
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long current = 1L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<GetWbethWrapHistoryResponse> response =
                api.getWbethWrapHistory(startTime, endTime, current, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "startTime=1623319461670&endTime=1641782889000&current=1&size=10&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "2ecc0415a3bdb2963e8030cdf6cf00de6f49d21b71ff939dda42e5756eb8ba66",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/eth-staking/wbeth/history/wrapHistory",
                actualRequest.url().encodedPath());
    }

    /**
     * Redeem ETH(TRADE)
     *
     * <p>Redeem WBETH or BETH and get ETH * You need to open Enable Spot &amp; Margin Trading
     * permission for the API Key which requests this endpoint. Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void redeemEthTest() throws ApiException, CryptoException {
        RedeemEthRequest redeemEthRequest = new RedeemEthRequest();

        redeemEthRequest.amount(1d);

        ApiResponse<RedeemEthResponse> response = api.redeemEth(redeemEthRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000amount=1", signInputCaptor.getValue());
        assertEquals(
                "50d24733794b928836575c346769be26ee1fb5ffbf73f36933cd22c50116f74e",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/eth-staking/eth/redeem", actualRequest.url().encodedPath());
    }

    /**
     * Subscribe ETH Staking(TRADE)
     *
     * <p>Subscribe ETH Staking * You need to open Enable Spot &amp; Margin Trading permission for
     * the API Key which requests this endpoint. Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void subscribeEthStakingTest() throws ApiException, CryptoException {
        SubscribeEthStakingRequest subscribeEthStakingRequest = new SubscribeEthStakingRequest();

        subscribeEthStakingRequest.amount(1d);

        ApiResponse<SubscribeEthStakingResponse> response =
                api.subscribeEthStaking(subscribeEthStakingRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000amount=1", signInputCaptor.getValue());
        assertEquals(
                "50d24733794b928836575c346769be26ee1fb5ffbf73f36933cd22c50116f74e",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v2/eth-staking/eth/stake", actualRequest.url().encodedPath());
    }

    /**
     * Wrap BETH(TRADE)
     *
     * <p>Wrap BETH * You need to open Enable Spot &amp; Margin Trading permission for the API Key
     * which requests this endpoint. Weight: 150
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void wrapBethTest() throws ApiException, CryptoException {
        WrapBethRequest wrapBethRequest = new WrapBethRequest();

        wrapBethRequest.amount(1d);

        ApiResponse<WrapBethResponse> response = api.wrapBeth(wrapBethRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000amount=1", signInputCaptor.getValue());
        assertEquals(
                "50d24733794b928836575c346769be26ee1fb5ffbf73f36933cd22c50116f74e",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/eth-staking/wbeth/wrap", actualRequest.url().encodedPath());
    }
}
