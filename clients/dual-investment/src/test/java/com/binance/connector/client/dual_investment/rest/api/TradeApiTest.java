/*
 * Binance Dual Investment REST API
 * OpenAPI Specification for the Binance Dual Investment REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.dual_investment.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.dual_investment.rest.model.ChangeAutoCompoundStatusRequest;
import com.binance.connector.client.dual_investment.rest.model.ChangeAutoCompoundStatusResponse;
import com.binance.connector.client.dual_investment.rest.model.CheckDualInvestmentAccountsResponse;
import com.binance.connector.client.dual_investment.rest.model.GetDualInvestmentPositionsResponse;
import com.binance.connector.client.dual_investment.rest.model.SubscribeDualInvestmentProductsRequest;
import com.binance.connector.client.dual_investment.rest.model.SubscribeDualInvestmentProductsResponse;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for TradeApi */
public class TradeApiTest {

    private TradeApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new TradeApi(apiClientSpy);
    }

    /**
     * Change Auto-Compound status(USER_DATA)
     *
     * <p>Change Auto-Compound status Weight: 1(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void changeAutoCompoundStatusTest() throws ApiException, CryptoException {
        ChangeAutoCompoundStatusRequest changeAutoCompoundStatusRequest =
                new ChangeAutoCompoundStatusRequest();

        changeAutoCompoundStatusRequest.positionId("1");

        ApiResponse<ChangeAutoCompoundStatusResponse> response =
                api.changeAutoCompoundStatus(changeAutoCompoundStatusRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000positionId=1", signInputCaptor.getValue());
        assertEquals(
                "05345189012e725ecf394a569c76b468c3a9d6377f5b644a1b90e1551920ce91",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/dci/product/auto_compound/edit-status",
                actualRequest.url().encodedPath());
    }

    /**
     * Check Dual Investment accounts(USER_DATA)
     *
     * <p>Check Dual Investment accounts Weight: 1(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void checkDualInvestmentAccountsTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<CheckDualInvestmentAccountsResponse> response =
                api.checkDualInvestmentAccounts(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/dci/product/accounts", actualRequest.url().encodedPath());
    }

    /**
     * Get Dual Investment positions(USER_DATA)
     *
     * <p>Get Dual Investment positions (batch) Weight: 1(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getDualInvestmentPositionsTest() throws ApiException, CryptoException {
        String status = "";
        Long pageSize = 10L;
        Long pageIndex = 1L;
        Long recvWindow = 5000L;
        ApiResponse<GetDualInvestmentPositionsResponse> response =
                api.getDualInvestmentPositions(status, pageSize, pageIndex, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "status=&pageSize=10&pageIndex=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "8d4826ce79b5dc7d026d0e57a40f1e16a368e00c38fe09afd78f785093d092d7",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/dci/product/positions", actualRequest.url().encodedPath());
    }

    /**
     * Subscribe Dual Investment products(USER_DATA)
     *
     * <p>Subscribe Dual Investment products * Products are not available. // this means APR changes
     * to lower value, or orders are not unavailable. * Failed. This means System or network errors.
     * Weight: 1(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void subscribeDualInvestmentProductsTest() throws ApiException, CryptoException {
        SubscribeDualInvestmentProductsRequest subscribeDualInvestmentProductsRequest =
                new SubscribeDualInvestmentProductsRequest();

        subscribeDualInvestmentProductsRequest.id("");
        subscribeDualInvestmentProductsRequest.orderId("1");
        subscribeDualInvestmentProductsRequest.depositAmount(1d);
        subscribeDualInvestmentProductsRequest.autoCompoundPlan("NONE");

        ApiResponse<SubscribeDualInvestmentProductsResponse> response =
                api.subscribeDualInvestmentProducts(subscribeDualInvestmentProductsRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000depositAmount=1&autoCompoundPlan=NONE&orderId=1&id=",
                signInputCaptor.getValue());
        assertEquals(
                "c33f9d1dd0044db4e3dce19f93fcb81487a9c92151363981c666833756aab241",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/dci/product/subscribe", actualRequest.url().encodedPath());
    }
}
