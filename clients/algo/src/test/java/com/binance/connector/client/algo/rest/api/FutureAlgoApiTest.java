/*
 * Binance Algo REST API
 * OpenAPI Specification for the Binance Algo REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.algo.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.algo.rest.model.CancelAlgoOrderFutureAlgoResponse;
import com.binance.connector.client.algo.rest.model.QueryCurrentAlgoOpenOrdersFutureAlgoResponse;
import com.binance.connector.client.algo.rest.model.QueryHistoricalAlgoOrdersFutureAlgoResponse;
import com.binance.connector.client.algo.rest.model.QuerySubOrdersFutureAlgoResponse;
import com.binance.connector.client.algo.rest.model.TimeWeightedAveragePriceFutureAlgoRequest;
import com.binance.connector.client.algo.rest.model.TimeWeightedAveragePriceFutureAlgoResponse;
import com.binance.connector.client.algo.rest.model.VolumeParticipationFutureAlgoRequest;
import com.binance.connector.client.algo.rest.model.VolumeParticipationFutureAlgoResponse;
import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for FutureAlgoApi */
public class FutureAlgoApiTest {

    private FutureAlgoApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new FutureAlgoApi(apiClientSpy);
    }

    /**
     * Cancel Algo Order(TRADE)
     *
     * <p>Cancel an active order. * You need to enable &#x60;Futures Trading Permission&#x60; for
     * the api key which requests this endpoint. * Base URL: https://api.binance.com Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelAlgoOrderFutureAlgoTest() throws ApiException, CryptoException {
        Long algoId = 1L;
        Long recvWindow = 5000L;
        ApiResponse<CancelAlgoOrderFutureAlgoResponse> response =
                api.cancelAlgoOrderFutureAlgo(algoId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "algoId=1&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "4dcc675276dcc7a5eddf3f11f98e221dc22b447b227be14ec73a51c61602f2a5",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/algo/futures/order", actualRequest.url().encodedPath());
    }

    /**
     * Query Current Algo Open Orders(USER_DATA)
     *
     * <p>Query Current Algo Open Orders * You need to enable &#x60;Futures Trading Permission&#x60;
     * for the api key which requests this endpoint. * Base URL: https://api.binance.com Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryCurrentAlgoOpenOrdersFutureAlgoTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<QueryCurrentAlgoOpenOrdersFutureAlgoResponse> response =
                api.queryCurrentAlgoOpenOrdersFutureAlgo(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/algo/futures/openOrders", actualRequest.url().encodedPath());
    }

    /**
     * Query Historical Algo Orders(USER_DATA)
     *
     * <p>Query Historical Algo Order * You need to enable &#x60;Futures Trading Permission&#x60;
     * for the api key which requests this endpoint. * Base URL: https://api.binance.com Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryHistoricalAlgoOrdersFutureAlgoTest() throws ApiException, CryptoException {
        String symbol = "BTCUSDT";
        String side = "BUY";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long page = 1L;
        Long pageSize = 100L;
        Long recvWindow = 5000L;
        ApiResponse<QueryHistoricalAlgoOrdersFutureAlgoResponse> response =
                api.queryHistoricalAlgoOrdersFutureAlgo(
                        symbol, side, startTime, endTime, page, pageSize, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=BTCUSDT&side=BUY&startTime=1623319461670&endTime=1641782889000&page=1&pageSize=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "0e8d5de4dda9f55852d3ecc886e0ca289d66e4696a2fc21f553d9348242a14f1",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/algo/futures/historicalOrders", actualRequest.url().encodedPath());
    }

    /**
     * Query Sub Orders(USER_DATA)
     *
     * <p>Get respective sub orders for a specified algoId * You need to enable &#x60;Futures
     * Trading Permission&#x60; for the api key which requests this endpoint. * Base URL:
     * https://api.binance.com Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void querySubOrdersFutureAlgoTest() throws ApiException, CryptoException {
        Long algoId = 1L;
        Long page = 1L;
        Long pageSize = 100L;
        Long recvWindow = 5000L;
        ApiResponse<QuerySubOrdersFutureAlgoResponse> response =
                api.querySubOrdersFutureAlgo(algoId, page, pageSize, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "algoId=1&page=1&pageSize=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "a862a7c54c6a5c1f71b2563d1d86c61f8763cb9514dc20641231cc60f7ac0445",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/algo/futures/subOrders", actualRequest.url().encodedPath());
    }

    /**
     * Time-Weighted Average Price(Twap) New Order(TRADE)
     *
     * <p>Send in a Twap new order. Only support on USDⓈ-M Contracts. * Total Algo open orders max
     * allowed: &#x60;30&#x60; orders. * Leverage of symbols and position mode will be the same as
     * your futures account settings. You can set up through the trading page or fapi. * Receiving
     * &#x60;\&quot;success\&quot;: true&#x60; does not mean that your order will be executed.
     * Please use the query order endpoints（&#x60;GET sapi/v1/algo/futures/openOrders&#x60; or
     * &#x60;GET sapi/v1/algo/futures/historicalOrders&#x60;） to check the order status. For
     * example: Your futures balance is insufficient, or open position with reduce only or position
     * side is inconsistent with your own setting. In these cases you will receive
     * &#x60;\&quot;success\&quot;: true&#x60;, but the order status will be &#x60;expired&#x60;
     * after we check it. * &#x60;quantity&#x60; * 60 / &#x60;duration&#x60; should be larger than
     * minQty * &#x60;duration&#x60; cannot be less than 5 mins or more than 24 hours. * For
     * delivery contracts, TWAP end time should be one hour earlier than the delivery time of the
     * symbol. * You need to enable &#x60;Futures Trading Permission&#x60; for the api key which
     * requests this endpoint. * Base URL: https://api.binance.com Weight: 3000
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void timeWeightedAveragePriceFutureAlgoTest() throws ApiException, CryptoException {
        TimeWeightedAveragePriceFutureAlgoRequest timeWeightedAveragePriceFutureAlgoRequest =
                new TimeWeightedAveragePriceFutureAlgoRequest();

        timeWeightedAveragePriceFutureAlgoRequest.symbol("BTCUSDT");
        timeWeightedAveragePriceFutureAlgoRequest.side("BUY");
        timeWeightedAveragePriceFutureAlgoRequest.quantity(1d);
        timeWeightedAveragePriceFutureAlgoRequest.duration(5000L);

        ApiResponse<TimeWeightedAveragePriceFutureAlgoResponse> response =
                api.timeWeightedAveragePriceFutureAlgo(timeWeightedAveragePriceFutureAlgoRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000duration=5000&symbol=BTCUSDT&side=BUY&quantity=1",
                signInputCaptor.getValue());
        assertEquals(
                "cedadcc9e9190f0546a7247d2b7b627c8814e5e1f47b616211656ed04130a1a6",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/algo/futures/newOrderTwap", actualRequest.url().encodedPath());
    }

    /**
     * Volume Participation(VP) New Order (TRADE)
     *
     * <p>Send in a VP new order. Only support on USDⓈ-M Contracts. * Total Algo open orders max
     * allowed: &#x60;10&#x60; orders. * Leverage of symbols and position mode will be the same as
     * your futures account settings. You can set up through the trading page or fapi. * Receiving
     * &#x60;\&quot;success\&quot;: true&#x60; does not mean that your order will be executed.
     * Please use the query order endpoints（&#x60;GET sapi/v1/algo/futures/openOrders&#x60; or
     * &#x60;GET sapi/v1/algo/futures/historicalOrders&#x60;） to check the order status. For
     * example: Your futures balance is insufficient, or open position with reduce only or position
     * side is inconsistent with your own setting. In these cases you will receive
     * &#x60;\&quot;success\&quot;: true&#x60;, but the order status will be &#x60;expired&#x60;
     * after we check it. * You need to enable &#x60;Futures Trading Permission&#x60; for the api
     * key which requests this endpoint. * Base URL: https://api.binance.com Weight: 300
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void volumeParticipationFutureAlgoTest() throws ApiException, CryptoException {
        VolumeParticipationFutureAlgoRequest volumeParticipationFutureAlgoRequest =
                new VolumeParticipationFutureAlgoRequest();

        volumeParticipationFutureAlgoRequest.symbol("BTCUSDT");
        volumeParticipationFutureAlgoRequest.side("BUY");
        volumeParticipationFutureAlgoRequest.quantity(1d);
        volumeParticipationFutureAlgoRequest.urgency("LOW");

        ApiResponse<VolumeParticipationFutureAlgoResponse> response =
                api.volumeParticipationFutureAlgo(volumeParticipationFutureAlgoRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=BTCUSDT&side=BUY&quantity=1&urgency=LOW",
                signInputCaptor.getValue());
        assertEquals(
                "9e2d0455a2944d1f036cd1f966b9b5c9db75725ee79e38c7f94e49cf6b30e586",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/algo/futures/newOrderVp", actualRequest.url().encodedPath());
    }
}
