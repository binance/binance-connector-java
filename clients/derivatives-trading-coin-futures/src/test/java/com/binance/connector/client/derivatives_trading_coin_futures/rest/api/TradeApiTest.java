/*
 * Binance Derivatives Trading COIN Futures REST API
 * OpenAPI Specification for the Binance Derivatives Trading COIN Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_coin_futures.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.AccountTradeListResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.AllOrdersResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.AutoCancelAllOpenOrdersRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.AutoCloseType;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.BatchOrders;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.CancelAllOpenOrdersResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.CancelMultipleOrdersResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.CancelOrderResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ChangeInitialLeverageRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ChangeInitialLeverageResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ChangeMarginTypeRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ChangeMarginTypeResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ChangePositionModeRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ChangePositionModeResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.CurrentAllOpenOrdersResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.GetOrderModifyHistoryResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.GetPositionMarginChangeHistoryResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.MarginType;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ModifyIsolatedPositionMarginRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ModifyIsolatedPositionMarginResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ModifyMultipleOrdersRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ModifyMultipleOrdersResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ModifyOrderRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ModifyOrderResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.NewOrderRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.NewOrderResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.OrderIdList;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.OrigClientOrderIdList;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.PositionAdlQuantileEstimationResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.PositionInformationResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.QueryCurrentOpenOrderResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.QueryOrderResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.Side;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.Type;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.UsersForceOrdersResponse;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for TradeApi */
public class TradeApiTest {

    private TradeApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new TradeApi(apiClientSpy);
    }

    /**
     * Account Trade List (USER_DATA)
     *
     * <p>Get trades for a specific account and symbol. * Either symbol or pair must be sent *
     * Symbol and pair cannot be sent together * Pair and fromId cannot be sent together * OrderId
     * can only be sent together with symbol * If a pair is sent,tickers for all symbols of the pair
     * will be returned * The parameter &#x60;fromId&#x60; cannot be sent with &#x60;startTime&#x60;
     * or &#x60;endTime&#x60; * If startTime and endTime are both not sent, then the last 7
     * days&#39; data will be returned. * The time between startTime and endTime cannot be longer
     * than 7 days. Weight: 20 with symbolï¼Œ40 with pair
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void accountTradeListTest() throws ApiException, CryptoException {
        String symbol = "";
        String pair = "";
        Long orderId = 1L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long fromId = 1L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<AccountTradeListResponse> response =
                api.accountTradeList(
                        symbol, pair, orderId, startTime, endTime, fromId, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&pair=&orderId=1&startTime=1623319461670&endTime=1641782889000&fromId=1&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "d16037edade5d29ad6c4479dc0bd6a637556f7d86498043183450ee0058b70de",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/userTrades", actualRequest.url().encodedPath());
    }

    /**
     * All Orders (USER_DATA)
     *
     * <p>Get all account orders; active, canceled, or filled. * These orders will not be found: *
     * order status is CANCELED or EXPIRED AND order has NO filled trade AND created time + 3 days
     * &lt; current time * order create time + 90 days &lt; current time * Either &#x60;symbol&#x60;
     * or &#x60;pair&#x60; must be sent. * &#x60;pair&#x60; can&#39;t be sent with
     * &#x60;orderId&#x60; * If &#x60;orderId&#x60; is set, it will get orders &gt;&#x3D; that
     * &#x60;orderId&#x60;. Otherwise most recent orders are returned. * If orderId is set, it will
     * get orders &gt;&#x3D; that orderId. Otherwise most recent orders are returned. * The query
     * time period must be less then 7 days( default as the recent 7 days). Weight: 20 with symbol,
     * 40 with pair
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void allOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        String pair = "";
        Long orderId = 1L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<AllOrdersResponse> response =
                api.allOrders(symbol, pair, orderId, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&pair=&orderId=1&startTime=1623319461670&endTime=1641782889000&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "9445a77882a6628612b980279cee60afc4cf7c4a1263b48ec49bf8021cdf5300",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/allOrders", actualRequest.url().encodedPath());
    }

    /**
     * Auto-Cancel All Open Orders (TRADE)
     *
     * <p>Cancel all open orders of the specified symbol at the end of the specified countdown. This
     * rest endpoint means to ensure your open orders are canceled in case of an outage. The
     * endpoint should be called repeatedly as heartbeats so that the existing countdown time can be
     * canceled and repalced by a new one. The system will check all countdowns **approximately
     * every 10 milliseconds**, so please note that sufficient redundancy should be considered when
     * using this function. We do not recommend setting the countdown time to be too precise or too
     * small. * Example usage: Call this endpoint at 30s intervals with an countdownTime of 120000
     * (120s). If this endpoint is not called within 120 seconds, all your orders of the specified
     * symbol will be automatically canceled. If this endpoint is called with an countdownTime of 0,
     * the countdown timer will be stopped. Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void autoCancelAllOpenOrdersTest() throws ApiException, CryptoException {
        AutoCancelAllOpenOrdersRequest autoCancelAllOpenOrdersRequest =
                new AutoCancelAllOpenOrdersRequest();

        autoCancelAllOpenOrdersRequest.symbol("");
        autoCancelAllOpenOrdersRequest.countdownTime(0L);

        api.autoCancelAllOpenOrders(autoCancelAllOpenOrdersRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy).execute(callArgumentCaptor.capture());

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000symbol=&countdownTime=0", signInputCaptor.getValue());
        assertEquals(
                "42826e2320d45fba6a83c5a5da223ab9f7e622a05303b8d5507c99448d3a0a88",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/countdownCancelAll", actualRequest.url().encodedPath());
    }

    /**
     * Cancel All Open Orders(TRADE)
     *
     * <p>Cancel All Open Orders Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelAllOpenOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<CancelAllOpenOrdersResponse> response =
                api.cancelAllOpenOrders(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/allOpenOrders", actualRequest.url().encodedPath());
    }

    /**
     * Cancel Multiple Orders(TRADE)
     *
     * <p>Cancel Multiple Orders * Either &#x60;orderIdList&#x60; or &#x60;origClientOrderIdList
     * &#x60; must be sent. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelMultipleOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        OrderIdList orderIdList = null;
        OrigClientOrderIdList origClientOrderIdList = null;
        Long recvWindow = 5000L;
        ApiResponse<CancelMultipleOrdersResponse> response =
                api.cancelMultipleOrders(symbol, orderIdList, origClientOrderIdList, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/batchOrders", actualRequest.url().encodedPath());
    }

    /**
     * Cancel Order (TRADE)
     *
     * <p>Cancel an active order. * Either &#x60;orderId&#x60; or &#x60;origClientOrderId&#x60; must
     * be sent. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelOrderTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        String origClientOrderId = "1";
        Long recvWindow = 5000L;
        ApiResponse<CancelOrderResponse> response =
                api.cancelOrder(symbol, orderId, origClientOrderId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&orderId=1&origClientOrderId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "cbec82483be2ad044b893ffb2e6bc0d55370e378eaea0b4b61d95893bd9cc458",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/order", actualRequest.url().encodedPath());
    }

    /**
     * Change Initial Leverage (TRADE)
     *
     * <p>Change user&#39;s initial leverage in the specific symbol market. For Hedge Mode, LONG and
     * SHORT positions of one symbol use the same initial leverage and share a total notional value.
     * Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void changeInitialLeverageTest() throws ApiException, CryptoException {
        ChangeInitialLeverageRequest changeInitialLeverageRequest =
                new ChangeInitialLeverageRequest();

        changeInitialLeverageRequest.symbol("");
        changeInitialLeverageRequest.leverage(0L);

        ApiResponse<ChangeInitialLeverageResponse> response =
                api.changeInitialLeverage(changeInitialLeverageRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000symbol=&leverage=0", signInputCaptor.getValue());
        assertEquals(
                "31c40eeb1a5a52384cff8a195c1c312e32b26a672ad8fb71dc96256a61c4101c",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/leverage", actualRequest.url().encodedPath());
    }

    /**
     * Change Margin Type (TRADE)
     *
     * <p>Change user&#39;s margin type in the specific symbol market.For Hedge Mode, LONG and SHORT
     * positions of one symbol use the same margin type. With ISOLATED margin type, margins of the
     * LONG and SHORT positions are isolated from each other. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void changeMarginTypeTest() throws ApiException, CryptoException {
        ChangeMarginTypeRequest changeMarginTypeRequest = new ChangeMarginTypeRequest();

        changeMarginTypeRequest.symbol("");
        changeMarginTypeRequest.marginType(MarginType.ISOLATED);

        ApiResponse<ChangeMarginTypeResponse> response =
                api.changeMarginType(changeMarginTypeRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=&marginType=ISOLATED", signInputCaptor.getValue());
        assertEquals(
                "7cedb25e13ff6f8ca5b22d48cb06eaaa3b2a8c7d1f13a1aeb891f6a8125f5399",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/marginType", actualRequest.url().encodedPath());
    }

    /**
     * Change Position Mode(TRADE)
     *
     * <p>Change user&#39;s position mode (Hedge Mode or One-way Mode ) on ***EVERY symbol***
     * Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void changePositionModeTest() throws ApiException, CryptoException {
        ChangePositionModeRequest changePositionModeRequest = new ChangePositionModeRequest();

        changePositionModeRequest.dualSidePosition("");

        ApiResponse<ChangePositionModeResponse> response =
                api.changePositionMode(changePositionModeRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000dualSidePosition=", signInputCaptor.getValue());
        assertEquals(
                "234d62c8a0356474ae6889f6aee70005b8ded595c0d02364bc91a55e250c6017",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/positionSide/dual", actualRequest.url().encodedPath());
    }

    /**
     * Current All Open Orders (USER_DATA)
     *
     * <p>Get all open orders on a symbol. **Careful** when accessing this with no symbol. Weight: 1
     * for a single symbol, 40 for mutltiple symbols
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void currentAllOpenOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        String pair = "";
        Long recvWindow = 5000L;
        ApiResponse<CurrentAllOpenOrdersResponse> response =
                api.currentAllOpenOrders(symbol, pair, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&pair=&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "11b129369c0f8682cf70f667a8b90c4c55856d335dceef536e582ac7a1be7481",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/openOrders", actualRequest.url().encodedPath());
    }

    /**
     * Get Order Modify History (USER_DATA)
     *
     * <p>Get order modification history * Either &#x60;orderId&#x60; or
     * &#x60;origClientOrderId&#x60; must be sent, and the &#x60;orderId&#x60; will prevail if both
     * are sent. * Order modify history longer than 3 month is not avaliable Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getOrderModifyHistoryTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        String origClientOrderId = "1";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<GetOrderModifyHistoryResponse> response =
                api.getOrderModifyHistory(
                        symbol, orderId, origClientOrderId, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&orderId=1&origClientOrderId=1&startTime=1623319461670&endTime=1641782889000&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "8dfcc843fc05f631a3b12c4a0080f9d1f2283472ee0032b3e7e7fd46d855bcde",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/orderAmendment", actualRequest.url().encodedPath());
    }

    /**
     * Get Position Margin Change History(TRADE)
     *
     * <p>Get position margin change history Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getPositionMarginChangeHistoryTest() throws ApiException, CryptoException {
        String symbol = "";
        Type type = Type.LIMIT;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<GetPositionMarginChangeHistoryResponse> response =
                api.getPositionMarginChangeHistory(
                        symbol, type, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&type=LIMIT&startTime=1623319461670&endTime=1641782889000&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "28df29b15a98006243407bf3bf886a72f9747c27314862a75b89f0916e58f097",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/positionMargin/history", actualRequest.url().encodedPath());
    }

    /**
     * Modify Isolated Position Margin(TRADE)
     *
     * <p>Modify Isolated Position Margin * Only for isolated symbol Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void modifyIsolatedPositionMarginTest() throws ApiException, CryptoException {
        ModifyIsolatedPositionMarginRequest modifyIsolatedPositionMarginRequest =
                new ModifyIsolatedPositionMarginRequest();

        modifyIsolatedPositionMarginRequest.symbol("");
        modifyIsolatedPositionMarginRequest.amount(1d);
        modifyIsolatedPositionMarginRequest.type(Type.LIMIT);

        ApiResponse<ModifyIsolatedPositionMarginResponse> response =
                api.modifyIsolatedPositionMargin(modifyIsolatedPositionMarginRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=&amount=1&type=LIMIT", signInputCaptor.getValue());
        assertEquals(
                "d9e1ad5e7010758571908dd9048a5786754522e1130e711222767b96a0c811a3",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/positionMargin", actualRequest.url().encodedPath());
    }

    /**
     * Modify Multiple Orders(TRADE)
     *
     * <p>Modify Multiple Orders * Parameter rules are same with &#x60;Modify Order&#x60; * Batch
     * modify orders are processed concurrently, and the order of matching is not guaranteed. * The
     * order of returned contents for batch modify orders is the same as the order of the order
     * list. * One order can only be modfied for less than 10000 times Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void modifyMultipleOrdersTest() throws ApiException, CryptoException {
        ModifyMultipleOrdersRequest modifyMultipleOrdersRequest = new ModifyMultipleOrdersRequest();

        modifyMultipleOrdersRequest.batchOrders(new BatchOrders());

        ApiResponse<ModifyMultipleOrdersResponse> response =
                api.modifyMultipleOrders(modifyMultipleOrdersRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000batchOrders=%5B%5D", signInputCaptor.getValue());
        assertEquals(
                "84453de090bb6a9299c2928d3b767e0cd7298a2b7e7a004b22943b9d5990663b",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/batchOrders", actualRequest.url().encodedPath());
    }

    /**
     * Modify Order (TRADE)
     *
     * <p>Order modify function, currently only LIMIT order modification is supported, modified
     * orders will be reordered in the match queue * Either &#x60;orderId&#x60; or
     * &#x60;origClientOrderId&#x60; must be sent, and the &#x60;orderId&#x60; will prevail if both
     * are sent. * Either &#x60;quantity&#x60; or &#x60;price&#x60; must be sent. * When the new
     * &#x60;quantity&#x60; or &#x60;price&#x60; doesn&#39;t satisfy PRICE_FILTER / PERCENT_FILTER /
     * LOT_SIZE, amendment will be rejected and the order will stay as it is. * However the order
     * will be cancelled by the amendment in the following situations: * when the order is in
     * partially filled status and the new &#x60;quantity&#x60; &lt;&#x3D; &#x60;executedQty&#x60; *
     * When the order is &#x60;GTX&#x60; and the new price will cause it to be executed immediately
     * * One order can only be modfied for less than 10000 times * Modify order will set
     * &#x60;selfTradePreventionMode&#x60; to &#x60;NONE&#x60; Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void modifyOrderTest() throws ApiException, CryptoException {
        ModifyOrderRequest modifyOrderRequest = new ModifyOrderRequest();

        modifyOrderRequest.symbol("");
        modifyOrderRequest.side(Side.BUY);

        ApiResponse<ModifyOrderResponse> response = api.modifyOrder(modifyOrderRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000symbol=&side=BUY", signInputCaptor.getValue());
        assertEquals(
                "d0429bdd1b59c94a6a32c97f44503c5f0f681774a2353dd458de67bb1c64bea5",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/order", actualRequest.url().encodedPath());
    }

    /**
     * New Order (TRADE)
     *
     * <p>Send in a new order. * Order with type &#x60;STOP&#x60;, parameter &#x60;timeInForce&#x60;
     * can be sent ( default &#x60;GTC&#x60;). * Order with type &#x60;TAKE_PROFIT&#x60;, parameter
     * &#x60;timeInForce&#x60; can be sent ( default &#x60;GTC&#x60;). * Condition orders will be
     * triggered when: * If parameter&#x60;priceProtect&#x60;is sent as true: * when price reaches
     * the &#x60;stopPrice&#x60; ï¼Œthe difference rate between \&quot;MARK_PRICE\&quot; and
     * \&quot;CONTRACT_PRICE\&quot; cannot be larger than the \&quot;triggerProtect\&quot; of the
     * symbol * \&quot;triggerProtect\&quot; of a symbol can be got from &#x60;GET
     * /dapi/v1/exchangeInfo&#x60; * &#x60;STOP&#x60;, &#x60;STOP_MARKET&#x60;: * BUY: latest price
     * (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &gt;&#x3D; &#x60;stopPrice&#x60; *
     * SELL: latest price (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &lt;&#x3D;
     * &#x60;stopPrice&#x60; * &#x60;TAKE_PROFIT&#x60;, &#x60;TAKE_PROFIT_MARKET&#x60;: * BUY:
     * latest price (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &lt;&#x3D;
     * &#x60;stopPrice&#x60; * SELL: latest price (\&quot;MARK_PRICE\&quot; or
     * \&quot;CONTRACT_PRICE\&quot;) &gt;&#x3D; &#x60;stopPrice&#x60; *
     * &#x60;TRAILING_STOP_MARKET&#x60;: * BUY: the lowest price after order placed &#x60;&lt;&#x3D;
     * &#x60;activationPrice&#x60;, and the latest price &gt;&#x60;&#x3D; the lowest price * (1 +
     * &#x60;callbackRate&#x60;) * SELL: the highest price after order placed &gt;&#x3D;
     * &#x60;activationPrice&#x60;, and the latest price &lt;&#x3D; the highest price * (1 -
     * &#x60;callbackRate&#x60;) * For &#x60;TRAILING_STOP_MARKET&#x60;, if you got such error code.
     * &#x60;&#x60;{\&quot;code\&quot;: -2021, \&quot;msg\&quot;: \&quot;Order would immediately
     * trigger.\&quot;}&#x60;&#x60; means that the parameters you send do not meet the following
     * requirements: * BUY: &#x60;activationPrice&#x60; should be smaller than latest price. * SELL:
     * &#x60;activationPrice&#x60; should be larger than latest price. * If &#x60;newOrderRespType
     * &#x60; is sent as &#x60;RESULT&#x60; : * &#x60;MARKET&#x60; order: the final FILLED result of
     * the order will be return directly. * &#x60;LIMIT&#x60; order with special
     * &#x60;timeInForce&#x60;: the final status result of the order(FILLED or EXPIRED) will be
     * returned directly. * &#x60;STOP_MARKET&#x60;, &#x60;TAKE_PROFIT_MARKET&#x60; with
     * &#x60;closePosition&#x60;&#x3D;&#x60;true&#x60;: * Follow the same rules for condition
     * orders. * If triggered,**close all** current long position( if &#x60;SELL&#x60;) or current
     * short position( if &#x60;BUY&#x60;). * Cannot be used with &#x60;quantity&#x60; parameter *
     * Cannot be used with &#x60;reduceOnly&#x60; parameter * In Hedge Mode,cannot be used with
     * &#x60;BUY&#x60; orders in &#x60;LONG&#x60; position side. and cannot be used with
     * &#x60;SELL&#x60; orders in &#x60;SHORT&#x60; position side *
     * &#x60;selfTradePreventionMode&#x60; is only effective when &#x60;timeInForce&#x60; set to
     * &#x60;IOC&#x60; or &#x60;GTC&#x60;. Weight: 1 on 1min order rate
     * limit(X-MBX-ORDER-COUNT-1M)\\ 0 on IP rate limit(x-mbx-used-weight-1m)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void newOrderTest() throws ApiException, CryptoException {
        NewOrderRequest newOrderRequest = new NewOrderRequest();

        newOrderRequest.symbol("");
        newOrderRequest.side(Side.BUY);
        newOrderRequest.type(Type.LIMIT);

        ApiResponse<NewOrderResponse> response = api.newOrder(newOrderRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=&side=BUY&type=LIMIT", signInputCaptor.getValue());
        assertEquals(
                "b88c38300689d53932ba198ab2b30c30c872482dcaedbb4bede2f40535ba160a",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/order", actualRequest.url().encodedPath());
    }

    /**
     * Position ADL Quantile Estimation(USER_DATA)
     *
     * <p>Query position ADL quantile estimation * Values update every 30s. * Values 0, 1, 2, 3, 4
     * shows the queue position and possibility of ADL from low to high. * For positions of the
     * symbol are in One-way Mode or isolated margined in Hedge Mode, \&quot;LONG\&quot;,
     * \&quot;SHORT\&quot;, and \&quot;BOTH\&quot; will be returned to show the positions&#39; adl
     * quantiles of different position sides. * If the positions of the symbol are crossed margined
     * in Hedge Mode: * \&quot;HEDGE\&quot; as a sign will be returned instead of
     * \&quot;BOTH\&quot;; * A same value caculated on unrealized pnls on long and short sides&#39;
     * positions will be shown for \&quot;LONG\&quot; and \&quot;SHORT\&quot; when there are
     * positions in both of long and short sides. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void positionAdlQuantileEstimationTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<PositionAdlQuantileEstimationResponse> response =
                api.positionAdlQuantileEstimation(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/adlQuantile", actualRequest.url().encodedPath());
    }

    /**
     * Position Information(USER_DATA)
     *
     * <p>Get current account information. * If neither &#x60;marginAsset&#x60; nor &#x60;pair&#x60;
     * is sent, positions of all symbols with &#x60;TRADING&#x60; status will be returned. * for
     * One-way Mode user, the response will only show the \&quot;BOTH\&quot; positions * for Hedge
     * Mode user, the response will show \&quot;BOTH\&quot;, \&quot;LONG\&quot;, and
     * \&quot;SHORT\&quot; positions. Please use with user data stream &#x60;ACCOUNT_UPDATE&#x60; to
     * meet your timeliness and accuracy needs. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void positionInformationTest() throws ApiException, CryptoException {
        String marginAsset = "";
        String pair = "";
        Long recvWindow = 5000L;
        ApiResponse<PositionInformationResponse> response =
                api.positionInformation(marginAsset, pair, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "marginAsset=&pair=&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "7c340d46d6a73bb7697e05d5340862028b59650df2e5526d761180495c98e012",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/positionRisk", actualRequest.url().encodedPath());
    }

    /**
     * Query Current Open Order(USER_DATA)
     *
     * <p>Query Current Open Order * Either&#x60;orderId&#x60; or &#x60;origClientOrderId&#x60; must
     * be sent * If the queried order has been filled or cancelled, the error message \&quot;Order
     * does not exist\&quot; will be returned. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryCurrentOpenOrderTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        String origClientOrderId = "1";
        Long recvWindow = 5000L;
        ApiResponse<QueryCurrentOpenOrderResponse> response =
                api.queryCurrentOpenOrder(symbol, orderId, origClientOrderId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&orderId=1&origClientOrderId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "cbec82483be2ad044b893ffb2e6bc0d55370e378eaea0b4b61d95893bd9cc458",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/openOrder", actualRequest.url().encodedPath());
    }

    /**
     * Query Order (USER_DATA)
     *
     * <p>Check an order&#39;s status. * These orders will not be found: * order status is CANCELED
     * or EXPIRED AND order has NO filled trade AND created time + 3 days &lt; current time * order
     * create time + 90 days &lt; current time * Either &#x60;orderId&#x60; or
     * &#x60;origClientOrderId&#x60; must be sent. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryOrderTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        String origClientOrderId = "1";
        Long recvWindow = 5000L;
        ApiResponse<QueryOrderResponse> response =
                api.queryOrder(symbol, orderId, origClientOrderId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&orderId=1&origClientOrderId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "cbec82483be2ad044b893ffb2e6bc0d55370e378eaea0b4b61d95893bd9cc458",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/order", actualRequest.url().encodedPath());
    }

    /**
     * User&#39;s Force Orders(USER_DATA)
     *
     * <p>User&#39;s Force Orders * If \&quot;autoCloseType\&quot; is not sent, orders with both of
     * the types will be returned * If \&quot;startTime\&quot; is not sent, data within 200 days
     * before \&quot;endTime\&quot; can be queried Weight: 20 with symbol, 50 without symbol
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void usersForceOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        AutoCloseType autoCloseType = AutoCloseType.LIQUIDATION;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<UsersForceOrdersResponse> response =
                api.usersForceOrders(symbol, autoCloseType, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&autoCloseType=LIQUIDATION&startTime=1623319461670&endTime=1641782889000&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "a8fbc61c925506a4d0328c80dbe4bd786245accbfc50aef2a14a769d18bde9d9",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/forceOrders", actualRequest.url().encodedPath());
    }
}
