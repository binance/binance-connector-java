/*
 * Binance Derivatives Trading COIN Futures WebSocket Market Streams
 * OpenAPI Specification for the Binance Derivatives Trading COIN Futures WebSocket Market Streams
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.api;

import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.websocket.adapter.stream.StreamConnectionWrapper;
import com.binance.connector.client.common.websocket.configuration.SessionMode;
import com.binance.connector.client.common.websocket.configuration.WebSocketClientConfiguration;
import com.binance.connector.client.common.websocket.dtos.RequestWrapperDTO;
import com.binance.connector.client.common.websocket.service.StreamBlockingQueueWrapper;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.AggregateTradeStreamsRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.AggregateTradeStreamsResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.AllBookTickersStreamRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.AllBookTickersStreamResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.AllMarketLiquidationOrderStreamsRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.AllMarketLiquidationOrderStreamsResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.AllMarketMiniTickersStreamRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.AllMarketMiniTickersStreamResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.AllMarketTickersStreamsRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.AllMarketTickersStreamsResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.ContinuousContractKlineCandlestickStreamsRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.ContinuousContractKlineCandlestickStreamsResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.ContractInfoStreamRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.ContractInfoStreamResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.DiffBookDepthStreamsRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.DiffBookDepthStreamsResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.IndexKlineCandlestickStreamsRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.IndexKlineCandlestickStreamsResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.IndexPriceStreamRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.IndexPriceStreamResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.IndividualSymbolBookTickerStreamsRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.IndividualSymbolBookTickerStreamsResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.IndividualSymbolMiniTickerStreamRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.IndividualSymbolMiniTickerStreamResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.IndividualSymbolTickerStreamsRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.IndividualSymbolTickerStreamsResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.KlineCandlestickStreamsRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.KlineCandlestickStreamsResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.LiquidationOrderStreamsRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.LiquidationOrderStreamsResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.MarkPriceKlineCandlestickStreamsRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.MarkPriceKlineCandlestickStreamsResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.MarkPriceOfAllSymbolsOfAPairRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.MarkPriceOfAllSymbolsOfAPairResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.MarkPriceStreamRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.MarkPriceStreamResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.PartialBookDepthStreamsRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.stream.model.PartialBookDepthStreamsResponse;
import java.io.File;
import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Set;
import java.util.concurrent.CompletableFuture;

import org.eclipse.jetty.websocket.api.RemoteEndpoint;
import org.eclipse.jetty.websocket.api.Session;
import org.eclipse.jetty.websocket.client.WebSocketClient;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;
import org.skyscreamer.jsonassert.JSONAssert;

/** API tests for WebsocketMarketStreamsApi */
public class WebsocketMarketStreamsApiTest {

    private WebsocketMarketStreamsApi api;
    private StreamConnectionWrapper connectionSpy;
    private Session sessionMock;

    @BeforeEach
    public void initApiClient() throws Exception {
        URL resource = WebsocketMarketStreamsApi.class.getResource("/test-ed25519-prv-key.pem");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        File file = new File(resource.toURI());
        signatureConfiguration.setPrivateKey(file.getAbsolutePath());
        WebSocketClientConfiguration clientConfiguration = new WebSocketClientConfiguration();
        // @TODO: run tests for LOGON as well
        clientConfiguration.setAutoLogon(false);
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);
        clientConfiguration.setUrl("wss://localhost:8080");

        WebSocketClient webSocketClient = Mockito.mock(WebSocketClient.class);
        CompletableFuture<Session> sessionCompletableFuture = new CompletableFuture<>();
        Mockito.doReturn(sessionCompletableFuture)
                .when(webSocketClient)
                .connect(Mockito.any(), Mockito.any(), Mockito.any());
        sessionMock = Mockito.mock(Session.class);

        RemoteEndpoint remoteEndpointMock = Mockito.mock(RemoteEndpoint.class);
        Mockito.doReturn(remoteEndpointMock).when(sessionMock).getRemote();

        sessionCompletableFuture.complete(sessionMock);
        StreamConnectionWrapper connectionWrapper =
                new StreamConnectionWrapper(clientConfiguration, webSocketClient);
        connectionSpy = Mockito.spy(connectionWrapper);
        Mockito.doReturn(1736393892000L).when(connectionSpy).getTimestamp();
        connectionSpy.connect();
        WebsocketMarketStreamsApi accountApi = new WebsocketMarketStreamsApi(connectionSpy);
        api = Mockito.spy(accountApi);
        Mockito.doReturn("eaf3292c-64b6-4c04-ad4f-4ca2608b42b4").when(api).getRequestID();
    }

    /**
     * Aggregate Trade Streams
     *
     * <p>The Aggregate Trade Streams push market trade information that is aggregated for fills
     * with same price and taking side every 100 milliseconds. Update Speed: 100ms
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void aggregateTradeStreamsTest() throws ApiException, URISyntaxException, IOException {
        AggregateTradeStreamsRequest aggregateTradeStreamsRequest =
                new AggregateTradeStreamsRequest();

        aggregateTradeStreamsRequest.symbol("btcusdt");

        StreamBlockingQueueWrapper<AggregateTradeStreamsResponse> response =
                api.aggregateTradeStreams(aggregateTradeStreamsRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, AggregateTradeStreamsResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, AggregateTradeStreamsResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/<symbol>@aggTrade-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * All Book Tickers Stream
     *
     * <p>Pushes any update to the best bid or ask&#39;s price or quantity in real-time for all
     * symbols. Update Speed: Real-time
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void allBookTickersStreamTest() throws ApiException, URISyntaxException, IOException {
        AllBookTickersStreamRequest allBookTickersStreamRequest = new AllBookTickersStreamRequest();

        StreamBlockingQueueWrapper<AllBookTickersStreamResponse> response =
                api.allBookTickersStream(allBookTickersStreamRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, AllBookTickersStreamResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, AllBookTickersStreamResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/!bookTicker-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * All Market Liquidation Order Streams
     *
     * <p>The All Liquidation Order Snapshot Streams push force liquidation order information for
     * all symbols in the market. For each symbol，only the latest one liquidation order within
     * 1000ms will be pushed as the snapshot. If no liquidation happens in the interval of 1000ms,
     * no stream will be pushed. Update Speed: 1000ms
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void allMarketLiquidationOrderStreamsTest()
            throws ApiException, URISyntaxException, IOException {
        AllMarketLiquidationOrderStreamsRequest allMarketLiquidationOrderStreamsRequest =
                new AllMarketLiquidationOrderStreamsRequest();

        StreamBlockingQueueWrapper<AllMarketLiquidationOrderStreamsResponse> response =
                api.allMarketLiquidationOrderStreams(allMarketLiquidationOrderStreamsRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, AllMarketLiquidationOrderStreamsResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, AllMarketLiquidationOrderStreamsResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/!forceOrder@arr-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * All Market Mini Tickers Stream
     *
     * <p>24hr rolling window mini-ticker statistics for all symbols. These are NOT the statistics
     * of the UTC day, but a 24hr rolling window from requestTime to 24hrs before. Note that only
     * tickers that have changed will be present in the array. Update Speed: 1000ms
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void allMarketMiniTickersStreamTest()
            throws ApiException, URISyntaxException, IOException {
        AllMarketMiniTickersStreamRequest allMarketMiniTickersStreamRequest =
                new AllMarketMiniTickersStreamRequest();

        StreamBlockingQueueWrapper<AllMarketMiniTickersStreamResponse> response =
                api.allMarketMiniTickersStream(allMarketMiniTickersStreamRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, AllMarketMiniTickersStreamResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, AllMarketMiniTickersStreamResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/!miniTicker@arr-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * All Market Tickers Streams
     *
     * <p>24hr rolling window ticker statistics for all symbols. These are NOT the statistics of the
     * UTC day, but a 24hr rolling window from requestTime to 24hrs before. Note that only tickers
     * that have changed will be present in the array. Update Speed: 1000ms
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void allMarketTickersStreamsTest() throws ApiException, URISyntaxException, IOException {
        AllMarketTickersStreamsRequest allMarketTickersStreamsRequest =
                new AllMarketTickersStreamsRequest();

        StreamBlockingQueueWrapper<AllMarketTickersStreamsResponse> response =
                api.allMarketTickersStreams(allMarketTickersStreamsRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, AllMarketTickersStreamsResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, AllMarketTickersStreamsResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/!ticker@arr-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Continuous Contract Kline/Candlestick Streams
     *
     * <p>Kline update every second Update Speed: 250ms
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void continuousContractKlineCandlestickStreamsTest()
            throws ApiException, URISyntaxException, IOException {
        ContinuousContractKlineCandlestickStreamsRequest
                continuousContractKlineCandlestickStreamsRequest =
                        new ContinuousContractKlineCandlestickStreamsRequest();

        continuousContractKlineCandlestickStreamsRequest.pair("btcusdt");
        continuousContractKlineCandlestickStreamsRequest.contractType("next_quarter");
        continuousContractKlineCandlestickStreamsRequest.interval("1m");

        StreamBlockingQueueWrapper<ContinuousContractKlineCandlestickStreamsResponse> response =
                api.continuousContractKlineCandlestickStreams(
                        continuousContractKlineCandlestickStreamsRequest);
        ArgumentCaptor<
                        RequestWrapperDTO<
                                Set<String>, ContinuousContractKlineCandlestickStreamsResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, ContinuousContractKlineCandlestickStreamsResponse>
                requestWrapperDTO = callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/<pair>_<contractType>@continuousKline_<interval>-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Contract Info Stream
     *
     * <p>ContractInfo stream pushes when contract info updates(listing/settlement/contract bracket
     * update). &#x60;bks&#x60; field only shows up when bracket gets updated. Update Speed:
     * Real-time
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void contractInfoStreamTest() throws ApiException, URISyntaxException, IOException {
        ContractInfoStreamRequest contractInfoStreamRequest = new ContractInfoStreamRequest();

        StreamBlockingQueueWrapper<ContractInfoStreamResponse> response =
                api.contractInfoStream(contractInfoStreamRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, ContractInfoStreamResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, ContractInfoStreamResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/!contractInfo-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Diff. Book Depth Streams
     *
     * <p>Bids and asks, pushed every 250 milliseconds, 500 milliseconds, or 100 milliseconds Update
     * Speed: 250ms or 500ms or 100ms
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void diffBookDepthStreamsTest() throws ApiException, URISyntaxException, IOException {
        DiffBookDepthStreamsRequest diffBookDepthStreamsRequest = new DiffBookDepthStreamsRequest();

        diffBookDepthStreamsRequest.symbol("btcusdt");

        StreamBlockingQueueWrapper<DiffBookDepthStreamsResponse> response =
                api.diffBookDepthStreams(diffBookDepthStreamsRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, DiffBookDepthStreamsResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, DiffBookDepthStreamsResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/<symbol>@depth<updateSpeed>-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Index Kline/Candlestick Streams
     *
     * <p>Index Kline/Candlestick Streams Update Speed: 250ms
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void indexKlineCandlestickStreamsTest()
            throws ApiException, URISyntaxException, IOException {
        IndexKlineCandlestickStreamsRequest indexKlineCandlestickStreamsRequest =
                new IndexKlineCandlestickStreamsRequest();

        indexKlineCandlestickStreamsRequest.pair("btcusdt");
        indexKlineCandlestickStreamsRequest.interval("1m");

        StreamBlockingQueueWrapper<IndexKlineCandlestickStreamsResponse> response =
                api.indexKlineCandlestickStreams(indexKlineCandlestickStreamsRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, IndexKlineCandlestickStreamsResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, IndexKlineCandlestickStreamsResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/<pair>@indexPriceKline_<interval>-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Index Price Stream
     *
     * <p>Index Price Stream Update Speed: 3000ms OR 1000ms
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void indexPriceStreamTest() throws ApiException, URISyntaxException, IOException {
        IndexPriceStreamRequest indexPriceStreamRequest = new IndexPriceStreamRequest();

        indexPriceStreamRequest.pair("btcusdt");
        indexPriceStreamRequest.updateSpeed("100ms");

        StreamBlockingQueueWrapper<IndexPriceStreamResponse> response =
                api.indexPriceStream(indexPriceStreamRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, IndexPriceStreamResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, IndexPriceStreamResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/<pair>@indexPrice<updateSpeed>-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Individual Symbol Book Ticker Streams
     *
     * <p>Pushes any update to the best bid or ask&#39;s price or quantity in real-time for a
     * specified symbol. Update Speed: Real-time
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void individualSymbolBookTickerStreamsTest()
            throws ApiException, URISyntaxException, IOException {
        IndividualSymbolBookTickerStreamsRequest individualSymbolBookTickerStreamsRequest =
                new IndividualSymbolBookTickerStreamsRequest();

        individualSymbolBookTickerStreamsRequest.symbol("btcusdt");

        StreamBlockingQueueWrapper<IndividualSymbolBookTickerStreamsResponse> response =
                api.individualSymbolBookTickerStreams(individualSymbolBookTickerStreamsRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, IndividualSymbolBookTickerStreamsResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, IndividualSymbolBookTickerStreamsResponse>
                requestWrapperDTO = callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/<symbol>@bookTicker-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Individual Symbol Mini Ticker Stream
     *
     * <p>24hr rolling window mini-ticker statistics for a single symbol. These are NOT the
     * statistics of the UTC day, but a 24hr rolling window from requestTime to 24hrs before. Update
     * Speed: 500ms
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void individualSymbolMiniTickerStreamTest()
            throws ApiException, URISyntaxException, IOException {
        IndividualSymbolMiniTickerStreamRequest individualSymbolMiniTickerStreamRequest =
                new IndividualSymbolMiniTickerStreamRequest();

        individualSymbolMiniTickerStreamRequest.symbol("btcusdt");

        StreamBlockingQueueWrapper<IndividualSymbolMiniTickerStreamResponse> response =
                api.individualSymbolMiniTickerStream(individualSymbolMiniTickerStreamRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, IndividualSymbolMiniTickerStreamResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, IndividualSymbolMiniTickerStreamResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/<symbol>@miniTicker-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Individual Symbol Ticker Streams
     *
     * <p>24hr rolling window ticker statistics for a single symbol. These are NOT the statistics of
     * the UTC day, but a 24hr rolling window from requestTime to 24hrs before. Update Speed: 500ms
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void individualSymbolTickerStreamsTest()
            throws ApiException, URISyntaxException, IOException {
        IndividualSymbolTickerStreamsRequest individualSymbolTickerStreamsRequest =
                new IndividualSymbolTickerStreamsRequest();

        individualSymbolTickerStreamsRequest.symbol("btcusdt");

        StreamBlockingQueueWrapper<IndividualSymbolTickerStreamsResponse> response =
                api.individualSymbolTickerStreams(individualSymbolTickerStreamsRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, IndividualSymbolTickerStreamsResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, IndividualSymbolTickerStreamsResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/<symbol>@ticker-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Kline/Candlestick Streams
     *
     * <p>The Kline/Candlestick Stream push updates to the current klines/candlestick every 250
     * milliseconds (if existing). Update Speed: 250ms
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void klineCandlestickStreamsTest() throws ApiException, URISyntaxException, IOException {
        KlineCandlestickStreamsRequest klineCandlestickStreamsRequest =
                new KlineCandlestickStreamsRequest();

        klineCandlestickStreamsRequest.symbol("btcusdt");
        klineCandlestickStreamsRequest.interval("1m");

        StreamBlockingQueueWrapper<KlineCandlestickStreamsResponse> response =
                api.klineCandlestickStreams(klineCandlestickStreamsRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, KlineCandlestickStreamsResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, KlineCandlestickStreamsResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/<symbol>@kline_<interval>-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Liquidation Order Streams
     *
     * <p>The Liquidation Order Snapshot Streams push force liquidation order information for
     * specific symbol. For each symbol，only the latest one liquidation order within 1000ms will be
     * pushed as the snapshot. If no liquidation happens in the interval of 1000ms, no stream will
     * be pushed. Update Speed: 1000ms
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void liquidationOrderStreamsTest() throws ApiException, URISyntaxException, IOException {
        LiquidationOrderStreamsRequest liquidationOrderStreamsRequest =
                new LiquidationOrderStreamsRequest();

        liquidationOrderStreamsRequest.symbol("btcusdt");

        StreamBlockingQueueWrapper<LiquidationOrderStreamsResponse> response =
                api.liquidationOrderStreams(liquidationOrderStreamsRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, LiquidationOrderStreamsResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, LiquidationOrderStreamsResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/<symbol>@forceOrder-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Mark Price Kline/Candlestick Streams
     *
     * <p>Mark Price Kline/Candlestick Streams Update Speed: 250ms
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void markPriceKlineCandlestickStreamsTest()
            throws ApiException, URISyntaxException, IOException {
        MarkPriceKlineCandlestickStreamsRequest markPriceKlineCandlestickStreamsRequest =
                new MarkPriceKlineCandlestickStreamsRequest();

        markPriceKlineCandlestickStreamsRequest.symbol("btcusdt");
        markPriceKlineCandlestickStreamsRequest.interval("1m");

        StreamBlockingQueueWrapper<MarkPriceKlineCandlestickStreamsResponse> response =
                api.markPriceKlineCandlestickStreams(markPriceKlineCandlestickStreamsRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, MarkPriceKlineCandlestickStreamsResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, MarkPriceKlineCandlestickStreamsResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/<symbol>@markPriceKline_<interval>-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Mark Price of All Symbols of a Pair
     *
     * <p>Mark Price of All Symbols of a Pair Update Speed: 3000ms OR 1000ms
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void markPriceOfAllSymbolsOfAPairTest()
            throws ApiException, URISyntaxException, IOException {
        MarkPriceOfAllSymbolsOfAPairRequest markPriceOfAllSymbolsOfAPairRequest =
                new MarkPriceOfAllSymbolsOfAPairRequest();

        markPriceOfAllSymbolsOfAPairRequest.pair("btcusdt");
        markPriceOfAllSymbolsOfAPairRequest.updateSpeed("100ms");

        StreamBlockingQueueWrapper<MarkPriceOfAllSymbolsOfAPairResponse> response =
                api.markPriceOfAllSymbolsOfAPair(markPriceOfAllSymbolsOfAPairRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, MarkPriceOfAllSymbolsOfAPairResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, MarkPriceOfAllSymbolsOfAPairResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/<pair>@markPrice<updateSpeed>-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Mark Price Stream
     *
     * <p>Mark price update stream Update Speed: 3000ms OR 1000ms
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void markPriceStreamTest() throws ApiException, URISyntaxException, IOException {
        MarkPriceStreamRequest markPriceStreamRequest = new MarkPriceStreamRequest();

        markPriceStreamRequest.symbol("btcusdt");
        markPriceStreamRequest.setUpdateSpeed("100ms");

        StreamBlockingQueueWrapper<MarkPriceStreamResponse> response =
                api.markPriceStream(markPriceStreamRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, MarkPriceStreamResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, MarkPriceStreamResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/<symbol>@markPrice<updateSpeed>-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Partial Book Depth Streams
     *
     * <p>Top **&lt;levels\\&gt;** bids and asks, Valid **&lt;levels\\&gt;** are 5, 10, or 20.
     * Update Speed: 250ms, 500ms or 100ms
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void partialBookDepthStreamsTest() throws ApiException, URISyntaxException, IOException {
        PartialBookDepthStreamsRequest partialBookDepthStreamsRequest =
                new PartialBookDepthStreamsRequest();

        partialBookDepthStreamsRequest.symbol("btcusdt");
        partialBookDepthStreamsRequest.levels(10L);
        partialBookDepthStreamsRequest.setUpdateSpeed("100ms");

        StreamBlockingQueueWrapper<PartialBookDepthStreamsResponse> response =
                api.partialBookDepthStreams(partialBookDepthStreamsRequest);
        ArgumentCaptor<RequestWrapperDTO<Set<String>, PartialBookDepthStreamsResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<Set<String>, PartialBookDepthStreamsResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        Set<String> params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                WebsocketMarketStreamsApiTest.class.getResource(
                        "/expected/stream/WebsocketMarketStreamsApi/<symbol>@depth<levels><updateSpeed>-test.json");
        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }
}
