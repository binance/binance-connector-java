/*
 * Binance Derivatives Trading COIN Futures REST API
 * OpenAPI Specification for the Binance Derivatives Trading COIN Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_coin_futures.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.BasisResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.CheckServerTimeResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.CompressedAggregateTradesListResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ContinuousContractKlineCandlestickDataResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ContractType;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ExchangeInformationResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.GetFundingRateHistoryOfPerpetualFuturesResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.GetFundingRateInfoResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.IndexPriceAndMarkPriceResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.IndexPriceKlineCandlestickDataResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.Interval;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.KlineCandlestickDataResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.LongShortRatioResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.MarkPriceKlineCandlestickDataResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.OldTradesLookupResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.OpenInterestResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.OpenInterestStatisticsResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.OrderBookResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.Period;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.PremiumIndexKlineDataResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.QueryIndexPriceConstituentsResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.RecentTradesListResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.SymbolOrderBookTickerResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.SymbolPriceTickerResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.TakerBuySellVolumeResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.Ticker24hrPriceChangeStatisticsResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.TopTraderLongShortRatioAccountsResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.TopTraderLongShortRatioPositionsResponse;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for MarketDataApi */
public class MarketDataApiTest {

    private MarketDataApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new MarketDataApi(apiClientSpy);
    }

    /**
     * Basis
     *
     * <p>Query basis * If startTime and endTime are not sent, the most recent data is returned. *
     * Only the data of the latest 30 days is available. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void basisTest() throws ApiException, CryptoException {
        String pair = "";
        ContractType contractType = ContractType.PERPETUAL;
        Period period = Period.PERIOD_5m;
        Long limit = 100L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        ApiResponse<BasisResponse> response =
                api.basis(pair, contractType, period, limit, startTime, endTime);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/futures/data/basis", actualRequest.url().encodedPath());
    }

    /**
     * Check Server time
     *
     * <p>Test connectivity to the Rest API and get the current server time. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void checkServerTimeTest() throws ApiException, CryptoException {
        ApiResponse<CheckServerTimeResponse> response = api.checkServerTime();

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/time", actualRequest.url().encodedPath());
    }

    /**
     * Compressed/Aggregate Trades List
     *
     * <p>Get compressed, aggregate trades. Market trades that fill in 100ms with the same price and
     * the same taking side will have the quantity aggregated. * support querying futures trade
     * histories that are not older than one year * If both &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; are sent, time between &#x60;startTime&#x60; and &#x60;endTime&#x60; must
     * be less than 1 hour. * If &#x60;fromId&#x60;, &#x60;startTime&#x60;, and &#x60;endTime&#x60;
     * are not sent, the most recent aggregate trades will be returned. * Only market trades will be
     * aggregated and returned, which means the insurance fund trades and ADL trades won&#39;t be
     * aggregated. * Sending both &#x60;startTime&#x60;/&#x60;endTime&#x60; and &#x60;fromId&#x60;
     * might cause response timeout, please send either &#x60;fromId&#x60; or
     * &#x60;startTime&#x60;/&#x60;endTime&#x60; Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void compressedAggregateTradesListTest() throws ApiException, CryptoException {
        String symbol = "";
        Long fromId = 1L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        ApiResponse<CompressedAggregateTradesListResponse> response =
                api.compressedAggregateTradesList(symbol, fromId, startTime, endTime, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/aggTrades", actualRequest.url().encodedPath());
    }

    /**
     * Continuous Contract Kline/Candlestick Data
     *
     * <p>Kline/candlestick bars for a specific contract type. Klines are uniquely identified by
     * their open time. * Contract type: * PERPETUAL * CURRENT_QUARTER * NEXT_QUARTER 1000 | 10 *
     * The difference between &#x60;startTime&#x60; and &#x60;endTime&#x60; can only be up to 200
     * days * Between &#x60;startTime&#x60; and &#x60;endTime&#x60;, the most recent
     * &#x60;limit&#x60; data from &#x60;endTime&#x60; will be returned: * If &#x60;startTime&#x60;
     * and &#x60;endTime&#x60; are not sent, current timestamp will be set as &#x60;endTime&#x60;,
     * and the most recent data will be returned. * If &#x60;startTime&#x60; is sent only, the
     * timestamp of 200 days after &#x60;startTime&#x60; will be set as &#x60;endTime&#x60;(up to
     * the current time) * If &#x60;endTime&#x60; is sent only, the timestamp of 200 days before
     * &#x60;endTime&#x60; will be set as &#x60;startTime&#x60; Weight: based on parameter LIMIT
     * LIMIT | weight ---|--- [1,100) | 1 [100, 500) | 2 [500, 1000] | 5 &gt; 1000 | 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void continuousContractKlineCandlestickDataTest() throws ApiException, CryptoException {
        String pair = "";
        ContractType contractType = ContractType.PERPETUAL;
        Interval interval = Interval.INTERVAL_1m;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        ApiResponse<ContinuousContractKlineCandlestickDataResponse> response =
                api.continuousContractKlineCandlestickData(
                        pair, contractType, interval, startTime, endTime, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/continuousKlines", actualRequest.url().encodedPath());
    }

    /**
     * Exchange Information
     *
     * <p>Current exchange trading rules and symbol information Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void exchangeInformationTest() throws ApiException, CryptoException {
        ApiResponse<ExchangeInformationResponse> response = api.exchangeInformation();

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/exchangeInfo", actualRequest.url().encodedPath());
    }

    /**
     * Get Funding Rate History of Perpetual Futures
     *
     * <p>Get Funding Rate History of Perpetual Futures * empty array will be returned for delivery
     * symbols. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFundingRateHistoryOfPerpetualFuturesTest() throws ApiException, CryptoException {
        String symbol = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        ApiResponse<GetFundingRateHistoryOfPerpetualFuturesResponse> response =
                api.getFundingRateHistoryOfPerpetualFutures(symbol, startTime, endTime, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/fundingRate", actualRequest.url().encodedPath());
    }

    /**
     * Get Funding Rate Info
     *
     * <p>Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor /
     * fundingIntervalHours adjustment Weight: 0
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFundingRateInfoTest() throws ApiException, CryptoException {
        ApiResponse<GetFundingRateInfoResponse> response = api.getFundingRateInfo();

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/fundingInfo", actualRequest.url().encodedPath());
    }

    /**
     * Index Price and Mark Price
     *
     * <p>Query index price and mark price Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void indexPriceAndMarkPriceTest() throws ApiException, CryptoException {
        String symbol = "";
        String pair = "";
        ApiResponse<IndexPriceAndMarkPriceResponse> response =
                api.indexPriceAndMarkPrice(symbol, pair);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/premiumIndex", actualRequest.url().encodedPath());
    }

    /**
     * Index Price Kline/Candlestick Data
     *
     * <p>Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by
     * their open time. 1000 | 10 * The difference between &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; can only be up to 200 days * Between &#x60;startTime&#x60; and
     * &#x60;endTime&#x60;, the most recent &#x60;limit&#x60; data from &#x60;endTime&#x60; will be
     * returned: * If &#x60;startTime&#x60; and &#x60;endTime&#x60; are not sent, current timestamp
     * will be set as &#x60;endTime&#x60;, and the most recent data will be returned. * If
     * &#x60;startTime&#x60; is sent only, the timestamp of 200 days after &#x60;startTime&#x60;
     * will be set as &#x60;endTime&#x60;(up to the current time) * If &#x60;endTime&#x60; is sent
     * only, the timestamp of 200 days before &#x60;endTime&#x60; will be set as
     * &#x60;startTime&#x60; Weight: based on parameter LIMIT LIMIT | weight ---|--- [1,100) | 1
     * [100, 500) | 2 [500, 1000] | 5 &gt; 1000 | 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void indexPriceKlineCandlestickDataTest() throws ApiException, CryptoException {
        String pair = "";
        Interval interval = Interval.INTERVAL_1m;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        ApiResponse<IndexPriceKlineCandlestickDataResponse> response =
                api.indexPriceKlineCandlestickData(pair, interval, startTime, endTime, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/indexPriceKlines", actualRequest.url().encodedPath());
    }

    /**
     * Kline/Candlestick Data
     *
     * <p>Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time.
     * 1000 | 10 * The difference between &#x60;startTime&#x60; and &#x60;endTime&#x60; can only be
     * up to 200 days * Between &#x60;startTime&#x60; and &#x60;endTime&#x60;, the most recent
     * &#x60;limit&#x60; data from &#x60;endTime&#x60; will be returned: * If &#x60;startTime&#x60;
     * and &#x60;endTime&#x60; are not sent, current timestamp will be set as &#x60;endTime&#x60;,
     * and the most recent data will be returned. * If &#x60;startTime&#x60; is sent only, the
     * timestamp of 200 days after &#x60;startTime&#x60; will be set as &#x60;endTime&#x60;(up to
     * the current time) * If &#x60;endTime&#x60; is sent only, the timestamp of 200 days before
     * &#x60;endTime&#x60; will be set as &#x60;startTime&#x60; Weight: based on parameter LIMIT
     * LIMIT | weight ---|--- [1,100) | 1 [100, 500) | 2 [500, 1000] | 5 &gt; 1000 | 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void klineCandlestickDataTest() throws ApiException, CryptoException {
        String symbol = "";
        Interval interval = Interval.INTERVAL_1m;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        ApiResponse<KlineCandlestickDataResponse> response =
                api.klineCandlestickData(symbol, interval, startTime, endTime, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/klines", actualRequest.url().encodedPath());
    }

    /**
     * Long/Short Ratio
     *
     * <p>Query symbol Long/Short Ratio * If startTime and endTime are not sent, the most recent
     * data is returned. * Only the data of the latest 30 days is available. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void longShortRatioTest() throws ApiException, CryptoException {
        String pair = "";
        Period period = Period.PERIOD_5m;
        Long limit = 100L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        ApiResponse<LongShortRatioResponse> response =
                api.longShortRatio(pair, period, limit, startTime, endTime);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/futures/data/globalLongShortAccountRatio", actualRequest.url().encodedPath());
    }

    /**
     * Mark Price Kline/Candlestick Data
     *
     * <p>Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by
     * their open time. 1000 | 10 * The difference between &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; can only be up to 200 days * Between &#x60;startTime&#x60; and
     * &#x60;endTime&#x60;, the most recent &#x60;limit&#x60; data from &#x60;endTime&#x60; will be
     * returned: * If &#x60;startTime&#x60; and &#x60;endTime&#x60; are not sent, current timestamp
     * will be set as &#x60;endTime&#x60;, and the most recent data will be returned. * If
     * &#x60;startTime&#x60; is sent only, the timestamp of 200 days after &#x60;startTime&#x60;
     * will be set as &#x60;endTime&#x60;(up to the current time) * If &#x60;endTime&#x60; is sent
     * only, the timestamp of 200 days before &#x60;endTime&#x60; will be set as
     * &#x60;startTime&#x60; Weight: based on parameter LIMIT LIMIT | weight ---|--- [1,100) | 1
     * [100, 500) | 2 [500, 1000] | 5 &gt; 1000 | 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void markPriceKlineCandlestickDataTest() throws ApiException, CryptoException {
        String symbol = "";
        Interval interval = Interval.INTERVAL_1m;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        ApiResponse<MarkPriceKlineCandlestickDataResponse> response =
                api.markPriceKlineCandlestickData(symbol, interval, startTime, endTime, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/markPriceKlines", actualRequest.url().encodedPath());
    }

    /**
     * Old Trades Lookup(MARKET_DATA)
     *
     * <p>Get older market historical trades. * Market trades means trades filled in the order book.
     * Only market trades will be returned, which means the insurance fund trades and ADL trades
     * won&#39;t be returned. Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void oldTradesLookupTest() throws ApiException, CryptoException {
        String symbol = "";
        Long limit = 100L;
        Long fromId = 1L;
        ApiResponse<OldTradesLookupResponse> response = api.oldTradesLookup(symbol, limit, fromId);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/historicalTrades", actualRequest.url().encodedPath());
    }

    /**
     * Open Interest
     *
     * <p>Get present open interest of a specific symbol. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void openInterestTest() throws ApiException, CryptoException {
        String symbol = "";
        ApiResponse<OpenInterestResponse> response = api.openInterest(symbol);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/openInterest", actualRequest.url().encodedPath());
    }

    /**
     * Open Interest Statistics
     *
     * <p>Query open interest stats * If startTime and endTime are not sent, the most recent data is
     * returned. * Only the data of the latest 30 days is available. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void openInterestStatisticsTest() throws ApiException, CryptoException {
        String pair = "";
        ContractType contractType = ContractType.PERPETUAL;
        Period period = Period.PERIOD_5m;
        Long limit = 100L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        ApiResponse<OpenInterestStatisticsResponse> response =
                api.openInterestStatistics(pair, contractType, period, limit, startTime, endTime);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/futures/data/openInterestHist", actualRequest.url().encodedPath());
    }

    /**
     * Order Book
     *
     * <p>Query orderbook on specific symbol Weight: Adjusted based on the limit: Limit | Weight
     * ------------ | ------------ 5, 10, 20, 50 | 2 100 | 5 500 | 10 1000 | 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void orderBookTest() throws ApiException, CryptoException {
        String symbol = "";
        Long limit = 100L;
        ApiResponse<OrderBookResponse> response = api.orderBook(symbol, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/depth", actualRequest.url().encodedPath());
    }

    /**
     * Premium index Kline Data
     *
     * <p>Premium index kline bars of a symbol. Klines are uniquely identified by their open time. *
     * If startTime and endTime are not sent, the most recent klines are returned. Weight: based on
     * parameter LIMIT | LIMIT | weight | | ----------- | ------ | | [1,100) | 1 | | [100, 500) | 2
     * | | [500, 1000] | 5 | | &gt; 1000 | 10 |
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void premiumIndexKlineDataTest() throws ApiException, CryptoException {
        String symbol = "";
        Interval interval = Interval.INTERVAL_1m;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        ApiResponse<PremiumIndexKlineDataResponse> response =
                api.premiumIndexKlineData(symbol, interval, startTime, endTime, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/premiumIndexKlines", actualRequest.url().encodedPath());
    }

    /**
     * Query Index Price Constituents
     *
     * <p>Query index price constituents Weight: 2
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryIndexPriceConstituentsTest() throws ApiException, CryptoException {
        String symbol = "";
        ApiResponse<QueryIndexPriceConstituentsResponse> response =
                api.queryIndexPriceConstituents(symbol);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/constituents", actualRequest.url().encodedPath());
    }

    /**
     * Recent Trades List
     *
     * <p>Get recent market trades * Market trades means trades filled in the order book. Only
     * market trades will be returned, which means the insurance fund trades and ADL trades
     * won&#39;t be returned. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void recentTradesListTest() throws ApiException, CryptoException {
        String symbol = "";
        Long limit = 100L;
        ApiResponse<RecentTradesListResponse> response = api.recentTradesList(symbol, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/trades", actualRequest.url().encodedPath());
    }

    /**
     * Symbol Order Book Ticker
     *
     * <p>Best price/qty on the order book for a symbol or symbols. * Symbol and pair cannot be sent
     * together * If a pair is sent,tickers for all symbols of the pair will be returned * If either
     * a pair or symbol is sent, tickers for all symbols of all pairs will be returned Weight: 2 for
     * a single symbol, 5 when the symbol parameter is omitted
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void symbolOrderBookTickerTest() throws ApiException, CryptoException {
        String symbol = "";
        String pair = "";
        ApiResponse<SymbolOrderBookTickerResponse> response =
                api.symbolOrderBookTicker(symbol, pair);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/ticker/bookTicker", actualRequest.url().encodedPath());
    }

    /**
     * Symbol Price Ticker
     *
     * <p>Latest price for a symbol or symbols. * Symbol and pair cannot be sent together * If a
     * pair is sent,tickers for all symbols of the pair will be returned * If either a pair or
     * symbol is sent, tickers for all symbols of all pairs will be returned Weight: 1 for a single
     * symbol, 2 when the symbol parameter is omitted
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void symbolPriceTickerTest() throws ApiException, CryptoException {
        String symbol = "";
        String pair = "";
        ApiResponse<SymbolPriceTickerResponse> response = api.symbolPriceTicker(symbol, pair);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/ticker/price", actualRequest.url().encodedPath());
    }

    /**
     * Taker Buy/Sell Volume
     *
     * <p>Taker Buy Volume: the total volume of buy orders filled by takers within the period. Taker
     * Sell Volume: the total volume of sell orders filled by takers within the period. * If
     * startTime and endTime are not sent, the most recent data is returned. * Only the data of the
     * latest 30 days is available. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void takerBuySellVolumeTest() throws ApiException, CryptoException {
        String pair = "";
        ContractType contractType = ContractType.PERPETUAL;
        Period period = Period.PERIOD_5m;
        Long limit = 100L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        ApiResponse<TakerBuySellVolumeResponse> response =
                api.takerBuySellVolume(pair, contractType, period, limit, startTime, endTime);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/futures/data/takerBuySellVol", actualRequest.url().encodedPath());
    }

    /**
     * Test Connectivity
     *
     * <p>Test connectivity to the Rest API. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void testConnectivityTest() throws ApiException, CryptoException {
        api.testConnectivity();

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy).execute(callArgumentCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/ping", actualRequest.url().encodedPath());
    }

    /**
     * 24hr Ticker Price Change Statistics
     *
     * <p>24 hour rolling window price change statistics. * Symbol and pair cannot be sent together
     * * If a pair is sent,tickers for all symbols of the pair will be returned * If either a pair
     * or symbol is sent, tickers for all symbols of all pairs will be returned Weight: 1 for a
     * single symbol, 40 when the symbol parameter is omitted Careful when accessing this with no
     * symbol.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void ticker24hrPriceChangeStatisticsTest() throws ApiException, CryptoException {
        String symbol = "";
        String pair = "";
        ApiResponse<Ticker24hrPriceChangeStatisticsResponse> response =
                api.ticker24hrPriceChangeStatistics(symbol, pair);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/ticker/24hr", actualRequest.url().encodedPath());
    }

    /**
     * Top Trader Long/Short Ratio (Accounts)
     *
     * <p>The proportion of net long and net short accounts to total accounts of the top 20% users
     * with the highest margin balance. Each account is counted once only. Long Account % &#x3D;
     * Accounts of top traders with net long positions / Total accounts of top traders with open
     * positions Short Account % &#x3D; Accounts of top traders with net short positions / Total
     * accounts of top traders with open positions Long/Short Ratio (Accounts) &#x3D; Long Account %
     * / Short Account % * If startTime and endTime are not sent, the most recent data is returned.
     * * Only the data of the latest 30 days is available. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void topTraderLongShortRatioAccountsTest() throws ApiException, CryptoException {
        String symbol = "";
        Period period = Period.PERIOD_5m;
        Long limit = 100L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        ApiResponse<TopTraderLongShortRatioAccountsResponse> response =
                api.topTraderLongShortRatioAccounts(symbol, period, limit, startTime, endTime);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/futures/data/topLongShortAccountRatio", actualRequest.url().encodedPath());
    }

    /**
     * Top Trader Long/Short Ratio (Positions)
     *
     * <p>The proportion of net long and net short positions to total open positions of the top 20%
     * users with the highest margin balance. Long Position % &#x3D; Long positions of top traders /
     * Total open positions of top traders Short Position % &#x3D; Short positions of top traders /
     * Total open positions of top traders Long/Short Ratio (Positions) &#x3D; Long Position % /
     * Short Position % * If startTime and endTime are not sent, the most recent data is returned. *
     * Only the data of the latest 30 days is available. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void topTraderLongShortRatioPositionsTest() throws ApiException, CryptoException {
        String pair = "";
        Period period = Period.PERIOD_5m;
        Long limit = 100L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        ApiResponse<TopTraderLongShortRatioPositionsResponse> response =
                api.topTraderLongShortRatioPositions(pair, period, limit, startTime, endTime);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/futures/data/topLongShortPositionRatio", actualRequest.url().encodedPath());
    }
}
