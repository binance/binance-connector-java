/*
 * Binance Derivatives Trading COIN Futures REST API
 * OpenAPI Specification for the Binance Derivatives Trading COIN Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_coin_futures.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.AccountInformationResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.FuturesAccountBalanceResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.GetCurrentPositionModeResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.GetDownloadIdForFuturesOrderHistoryResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.GetDownloadIdForFuturesTradeHistoryResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.GetDownloadIdForFuturesTransactionHistoryResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.GetFuturesOrderHistoryDownloadLinkByIdResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.GetFuturesTradeDownloadLinkByIdResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.GetFuturesTransactionHistoryDownloadLinkByIdResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.GetIncomeHistoryResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.NotionalBracketForPairResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.NotionalBracketForSymbolResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.UserCommissionRateResponse;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for AccountApi */
public class AccountApiTest {

    private AccountApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new AccountApi(apiClientSpy);
    }

    /**
     * Account Information (USER_DATA)
     *
     * <p>Get current account information. * for One-way Mode user, the \&quot;positions\&quot; will
     * only show the \&quot;BOTH\&quot; positions * for Hedge Mode user, the \&quot;positions\&quot;
     * will show \&quot;BOTH\&quot;, \&quot;LONG\&quot;, and \&quot;SHORT\&quot; positions. Weight:
     * 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void accountInformationTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<AccountInformationResponse> response = api.accountInformation(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/account", actualRequest.url().encodedPath());
    }

    /**
     * Futures Account Balance (USER_DATA)
     *
     * <p>Check futures account balance Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void futuresAccountBalanceTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<FuturesAccountBalanceResponse> response = api.futuresAccountBalance(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/balance", actualRequest.url().encodedPath());
    }

    /**
     * Get Current Position Mode(USER_DATA)
     *
     * <p>Get user&#39;s position mode (Hedge Mode or One-way Mode ) on ***EVERY symbol*** Weight:
     * 30
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getCurrentPositionModeTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<GetCurrentPositionModeResponse> response =
                api.getCurrentPositionMode(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/positionSide/dual", actualRequest.url().encodedPath());
    }

    /**
     * Get Download Id For Futures Order History (USER_DATA)
     *
     * <p>Get Download Id For Futures Order History * Request Limitation is 10 times per month,
     * shared by front end download page and rest api * The time between &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; can not be longer than 1 year Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getDownloadIdForFuturesOrderHistoryTest() throws ApiException, CryptoException {
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long recvWindow = 5000L;
        ApiResponse<GetDownloadIdForFuturesOrderHistoryResponse> response =
                api.getDownloadIdForFuturesOrderHistory(startTime, endTime, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "startTime=1623319461670&endTime=1641782889000&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "812caedbe8f349196a4532c2050ff706ed2569fed185039c7b60a78cd84bc718",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/order/asyn", actualRequest.url().encodedPath());
    }

    /**
     * Get Download Id For Futures Trade History (USER_DATA)
     *
     * <p>Get download id for futures trade history * Request Limitation is 5 times per month,
     * shared by front end download page and rest api * The time between &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; can not be longer than 1 year Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getDownloadIdForFuturesTradeHistoryTest() throws ApiException, CryptoException {
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long recvWindow = 5000L;
        ApiResponse<GetDownloadIdForFuturesTradeHistoryResponse> response =
                api.getDownloadIdForFuturesTradeHistory(startTime, endTime, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "startTime=1623319461670&endTime=1641782889000&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "812caedbe8f349196a4532c2050ff706ed2569fed185039c7b60a78cd84bc718",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/trade/asyn", actualRequest.url().encodedPath());
    }

    /**
     * Get Download Id For Futures Transaction History(USER_DATA)
     *
     * <p>Get download id for futures transaction history * Request Limitation is 5 times per month,
     * shared by front end download page and rest api * The time between &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; can not be longer than 1 year Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getDownloadIdForFuturesTransactionHistoryTest()
            throws ApiException, CryptoException {
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long recvWindow = 5000L;
        ApiResponse<GetDownloadIdForFuturesTransactionHistoryResponse> response =
                api.getDownloadIdForFuturesTransactionHistory(startTime, endTime, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "startTime=1623319461670&endTime=1641782889000&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "812caedbe8f349196a4532c2050ff706ed2569fed185039c7b60a78cd84bc718",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/income/asyn", actualRequest.url().encodedPath());
    }

    /**
     * Get Futures Order History Download Link by Id (USER_DATA)
     *
     * <p>Get futures order history download link by Id * Download link expiration: 24h Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFuturesOrderHistoryDownloadLinkByIdTest() throws ApiException, CryptoException {
        String downloadId = "1";
        Long recvWindow = 5000L;
        ApiResponse<GetFuturesOrderHistoryDownloadLinkByIdResponse> response =
                api.getFuturesOrderHistoryDownloadLinkById(downloadId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "downloadId=1&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "4947fe463a17e3ec0b50fc22b21afc2aafddf3da892fa0c8dfd1b9c50af87349",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/order/asyn/id", actualRequest.url().encodedPath());
    }

    /**
     * Get Futures Trade Download Link by Id(USER_DATA)
     *
     * <p>Get futures trade download link by Id * Download link expiration: 24h Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFuturesTradeDownloadLinkByIdTest() throws ApiException, CryptoException {
        String downloadId = "1";
        Long recvWindow = 5000L;
        ApiResponse<GetFuturesTradeDownloadLinkByIdResponse> response =
                api.getFuturesTradeDownloadLinkById(downloadId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "downloadId=1&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "4947fe463a17e3ec0b50fc22b21afc2aafddf3da892fa0c8dfd1b9c50af87349",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/trade/asyn/id", actualRequest.url().encodedPath());
    }

    /**
     * Get Futures Transaction History Download Link by Id (USER_DATA)
     *
     * <p>Get futures transaction history download link by Id * Download link expiration: 24h
     * Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFuturesTransactionHistoryDownloadLinkByIdTest()
            throws ApiException, CryptoException {
        String downloadId = "1";
        Long recvWindow = 5000L;
        ApiResponse<GetFuturesTransactionHistoryDownloadLinkByIdResponse> response =
                api.getFuturesTransactionHistoryDownloadLinkById(downloadId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "downloadId=1&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "4947fe463a17e3ec0b50fc22b21afc2aafddf3da892fa0c8dfd1b9c50af87349",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/income/asyn/id", actualRequest.url().encodedPath());
    }

    /**
     * Get Income History(USER_DATA)
     *
     * <p>Get income history * If &#x60;incomeType &#x60; is not sent, all kinds of flow will be
     * returned * \&quot;trandId\&quot; is unique in the same \&quot;incomeType\&quot; for a user *
     * The time between &#x60;startTime&#x60; and &#x60;endTime&#x60; can not be longer than 1 year
     * Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getIncomeHistoryTest() throws ApiException, CryptoException {
        String symbol = "";
        String incomeType = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long page = 0L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<GetIncomeHistoryResponse> response =
                api.getIncomeHistory(
                        symbol, incomeType, startTime, endTime, page, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&incomeType=&startTime=1623319461670&endTime=1641782889000&page=0&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "05f9946fedf735df42817e55ffdc78ca315f60a95c723d2f957b7ce76546ef2e",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/income", actualRequest.url().encodedPath());
    }

    /**
     * Notional Bracket for Pair(USER_DATA)
     *
     * <p>**Not recommended to continue using this v1 endpoint** Get the pair&#39;s default notional
     * bracket list, may return ambiguous values when there have been multiple different
     * &#x60;symbol&#x60; brackets under the &#x60;pair&#x60;, suggest using the following &#x60;GET
     * /dapi/v2/leverageBracket&#x60; query instead to get the specific &#x60;symbol&#x60; notional
     * bracket list. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void notionalBracketForPairTest() throws ApiException, CryptoException {
        String pair = "";
        Long recvWindow = 5000L;
        ApiResponse<NotionalBracketForPairResponse> response =
                api.notionalBracketForPair(pair, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("pair=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "ca1d3c60bdcdd0a059d6e271455558cbdeb37973a99d026324dc2572ec1e9003",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/leverageBracket", actualRequest.url().encodedPath());
    }

    /**
     * Notional Bracket for Symbol(USER_DATA)
     *
     * <p>Get the symbol&#39;s notional bracket list. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void notionalBracketForSymbolTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<NotionalBracketForSymbolResponse> response =
                api.notionalBracketForSymbol(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v2/leverageBracket", actualRequest.url().encodedPath());
    }

    /**
     * User Commission Rate (USER_DATA)
     *
     * <p>Query user commission rate Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void userCommissionRateTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<UserCommissionRateResponse> response =
                api.userCommissionRate(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/dapi/v1/commissionRate", actualRequest.url().encodedPath());
    }
}
