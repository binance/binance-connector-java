/*
 * Binance Derivatives Trading COIN Futures WebSocket API
 * OpenAPI Specification for the Binance Derivatives Trading COIN Futures WebSocket API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_coin_futures.websocket.api.api;

import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.exception.ConstraintViolationException;
import com.binance.connector.client.common.websocket.adapter.ConnectionInterface;
import com.binance.connector.client.common.websocket.dtos.ApiRequestWrapperDTO;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.api.model.CloseUserDataStreamRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.api.model.CloseUserDataStreamResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.api.model.KeepaliveUserDataStreamRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.api.model.KeepaliveUserDataStreamResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.api.model.StartUserDataStreamRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.websocket.api.model.StartUserDataStreamResponse;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.constraints.*;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator;

public class UserDataStreamsApi {
    private ConnectionInterface connection;

    public UserDataStreamsApi() {}

    public UserDataStreamsApi(ConnectionInterface connection) {
        this.connection = connection;
    }

    /**
     * Close User Data Stream (USER_STREAM) Close out a user data stream. Weight: 1
     *
     * @param closeUserDataStreamRequest (required)
     * @return CloseUserDataStreamResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Close User Data Stream </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/user-data-streams/Close-User-Data-Stream-Wsp">Close
     *     User Data Stream (USER_STREAM) Documentation</a>
     */
    public CompletableFuture<CloseUserDataStreamResponse> closeUserDataStream(
            CloseUserDataStreamRequest closeUserDataStreamRequest) throws ApiException {
        closeUserDataStreamValidateBeforeCall(closeUserDataStreamRequest);
        String methodName = "/userDataStream.stop".substring(1);
        ApiRequestWrapperDTO<CloseUserDataStreamRequest, CloseUserDataStreamResponse> build =
                new ApiRequestWrapperDTO.Builder<
                                CloseUserDataStreamRequest, CloseUserDataStreamResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(closeUserDataStreamRequest)
                        .responseType(CloseUserDataStreamResponse.class)
                        .signed(false)
                        .apiKeyOnly(true)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void closeUserDataStreamValidateBeforeCall(
            CloseUserDataStreamRequest closeUserDataStreamRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<CloseUserDataStreamRequest>> violations =
                    validator.validate(closeUserDataStreamRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Keepalive User Data Stream (USER_STREAM) Keepalive a user data stream to prevent a time out.
     * User data streams will close after 60 minutes. It&#39;s recommended to send a ping about
     * every 60 minutes. Weight: 1
     *
     * @param keepaliveUserDataStreamRequest (required)
     * @return KeepaliveUserDataStreamResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Keepalive User Data Stream </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/user-data-streams/Keepalive-User-Data-Stream-Wsp">Keepalive
     *     User Data Stream (USER_STREAM) Documentation</a>
     */
    public CompletableFuture<KeepaliveUserDataStreamResponse> keepaliveUserDataStream(
            KeepaliveUserDataStreamRequest keepaliveUserDataStreamRequest) throws ApiException {
        keepaliveUserDataStreamValidateBeforeCall(keepaliveUserDataStreamRequest);
        String methodName = "/userDataStream.ping".substring(1);
        ApiRequestWrapperDTO<KeepaliveUserDataStreamRequest, KeepaliveUserDataStreamResponse>
                build =
                        new ApiRequestWrapperDTO.Builder<
                                        KeepaliveUserDataStreamRequest,
                                        KeepaliveUserDataStreamResponse>()
                                .id(getRequestID())
                                .method(methodName)
                                .params(keepaliveUserDataStreamRequest)
                                .responseType(KeepaliveUserDataStreamResponse.class)
                                .signed(false)
                                .apiKeyOnly(true)
                                .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void keepaliveUserDataStreamValidateBeforeCall(
            KeepaliveUserDataStreamRequest keepaliveUserDataStreamRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<KeepaliveUserDataStreamRequest>> violations =
                    validator.validate(keepaliveUserDataStreamRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Start User Data Stream (USER_STREAM) Start a new user data stream. The stream will close
     * after 60 minutes unless a keepalive is sent. If the account has an active
     * &#x60;listenKey&#x60;, that &#x60;listenKey&#x60; will be returned and its validity will be
     * extended for 60 minutes. Weight: 1
     *
     * @param startUserDataStreamRequest (required)
     * @return StartUserDataStreamResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Start User Data Stream </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/user-data-streams/Start-User-Data-Stream-Wsp">Start
     *     User Data Stream (USER_STREAM) Documentation</a>
     */
    public CompletableFuture<StartUserDataStreamResponse> startUserDataStream(
            StartUserDataStreamRequest startUserDataStreamRequest) throws ApiException {
        startUserDataStreamValidateBeforeCall(startUserDataStreamRequest);
        String methodName = "/userDataStream.start".substring(1);
        ApiRequestWrapperDTO<StartUserDataStreamRequest, StartUserDataStreamResponse> build =
                new ApiRequestWrapperDTO.Builder<
                                StartUserDataStreamRequest, StartUserDataStreamResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(startUserDataStreamRequest)
                        .responseType(StartUserDataStreamResponse.class)
                        .signed(false)
                        .apiKeyOnly(true)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void startUserDataStreamValidateBeforeCall(
            StartUserDataStreamRequest startUserDataStreamRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<StartUserDataStreamRequest>> violations =
                    validator.validate(startUserDataStreamRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    public String getRequestID() {
        return UUID.randomUUID().toString();
    }
}
