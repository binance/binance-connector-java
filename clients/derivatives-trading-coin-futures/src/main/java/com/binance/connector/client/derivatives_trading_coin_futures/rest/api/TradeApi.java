/*
 * Binance Derivatives Trading COIN Futures REST API
 * OpenAPI Specification for the Binance Derivatives Trading COIN Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_coin_futures.rest.api;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.DecimalFormatter;
import com.binance.connector.client.common.JSON;
import com.binance.connector.client.common.Pair;
import com.binance.connector.client.common.SystemUtil;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.exception.ConstraintViolationException;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.AccountTradeListResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.AllOrdersResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.AutoCancelAllOpenOrdersRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.AutoCloseType;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.CancelAllOpenOrdersResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.CancelMultipleOrdersResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.CancelOrderResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ChangeInitialLeverageRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ChangeInitialLeverageResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ChangeMarginTypeRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ChangeMarginTypeResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ChangePositionModeRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ChangePositionModeResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.CurrentAllOpenOrdersResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.GetOrderModifyHistoryResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.GetPositionMarginChangeHistoryResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ModifyIsolatedPositionMarginRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ModifyIsolatedPositionMarginResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ModifyMultipleOrdersRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ModifyMultipleOrdersResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ModifyOrderRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.ModifyOrderResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.NewOrderRequest;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.NewOrderResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.OrderIdList;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.OrigClientOrderIdList;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.PositionAdlQuantileEstimationResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.PositionInformationResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.QueryCurrentOpenOrderResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.QueryOrderResponse;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.Type;
import com.binance.connector.client.derivatives_trading_coin_futures.rest.model.UsersForceOrdersResponse;
import com.google.gson.reflect.TypeToken;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Valid;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.constraints.*;
import jakarta.validation.executable.ExecutableValidator;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator;

public class TradeApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    private static final String USER_AGENT =
            String.format(
                    "binance-derivatives-trading-coin-futures/1.0.0 (Java/%s; %s; %s)",
                    SystemUtil.getJavaVersion(), SystemUtil.getOs(), SystemUtil.getArch());
    private static final boolean HAS_TIME_UNIT = false;

    public TradeApi(ClientConfiguration clientConfiguration) {
        this(new ApiClient(clientConfiguration));
    }

    public TradeApi(ApiClient apiClient) {
        apiClient.setUserAgent(USER_AGENT);
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for accountTradeList
     *
     * @param symbol (optional)
     * @param pair (optional)
     * @param orderId (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param fromId ID to get aggregate trades from INCLUSIVE. (optional)
     * @param limit Default 100; max 1000 (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Account Trade List </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Account-Trade-List">Account
     *     Trade List (USER_DATA) Documentation</a>
     */
    private okhttp3.Call accountTradeListCall(
            String symbol,
            String pair,
            Long orderId,
            Long startTime,
            Long endTime,
            Long fromId,
            Long limit,
            Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dapi/v1/userTrades";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (pair != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pair", pair));
        }

        if (orderId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderId", orderId));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (fromId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromId", fromId));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call accountTradeListValidateBeforeCall(
            String symbol,
            String pair,
            Long orderId,
            Long startTime,
            Long endTime,
            Long fromId,
            Long limit,
            Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {
                symbol, pair, orderId, startTime, endTime, fromId, limit, recvWindow
            };
            Method method =
                    this.getClass()
                            .getMethod(
                                    "accountTradeList",
                                    String.class,
                                    String.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return accountTradeListCall(
                        symbol, pair, orderId, startTime, endTime, fromId, limit, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Account Trade List (USER_DATA) Get trades for a specific account and symbol. * Either symbol
     * or pair must be sent * Symbol and pair cannot be sent together * Pair and fromId cannot be
     * sent together * OrderId can only be sent together with symbol * If a pair is sent,tickers for
     * all symbols of the pair will be returned * The parameter &#x60;fromId&#x60; cannot be sent
     * with &#x60;startTime&#x60; or &#x60;endTime&#x60; * If startTime and endTime are both not
     * sent, then the last 7 days&#39; data will be returned. * The time between startTime and
     * endTime cannot be longer than 7 days. Weight: 20 with symbol，40 with pair
     *
     * @param symbol (optional)
     * @param pair (optional)
     * @param orderId (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param fromId ID to get aggregate trades from INCLUSIVE. (optional)
     * @param limit Default 100; max 1000 (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;AccountTradeListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Account Trade List </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Account-Trade-List">Account
     *     Trade List (USER_DATA) Documentation</a>
     */
    public ApiResponse<AccountTradeListResponse> accountTradeList(
            String symbol,
            String pair,
            Long orderId,
            Long startTime,
            Long endTime,
            Long fromId,
            Long limit,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                accountTradeListValidateBeforeCall(
                        symbol, pair, orderId, startTime, endTime, fromId, limit, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<AccountTradeListResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for allOrders
     *
     * @param symbol (optional)
     * @param pair (optional)
     * @param orderId (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> All Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/All-Orders">All
     *     Orders (USER_DATA) Documentation</a>
     */
    private okhttp3.Call allOrdersCall(
            String symbol,
            String pair,
            Long orderId,
            Long startTime,
            Long endTime,
            Long limit,
            Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dapi/v1/allOrders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (pair != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pair", pair));
        }

        if (orderId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderId", orderId));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call allOrdersValidateBeforeCall(
            String symbol,
            String pair,
            Long orderId,
            Long startTime,
            Long endTime,
            Long limit,
            Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {
                symbol, pair, orderId, startTime, endTime, limit, recvWindow
            };
            Method method =
                    this.getClass()
                            .getMethod(
                                    "allOrders",
                                    String.class,
                                    String.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return allOrdersCall(symbol, pair, orderId, startTime, endTime, limit, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * All Orders (USER_DATA) Get all account orders; active, canceled, or filled. * These orders
     * will not be found: * order status is CANCELED or EXPIRED AND order has NO filled trade AND
     * created time + 3 days &lt; current time * order create time + 90 days &lt; current time *
     * Either &#x60;symbol&#x60; or &#x60;pair&#x60; must be sent. * &#x60;pair&#x60; can&#39;t be
     * sent with &#x60;orderId&#x60; * If &#x60;orderId&#x60; is set, it will get orders &gt;&#x3D;
     * that &#x60;orderId&#x60;. Otherwise most recent orders are returned. * If orderId is set, it
     * will get orders &gt;&#x3D; that orderId. Otherwise most recent orders are returned. * The
     * query time period must be less then 7 days( default as the recent 7 days). Weight: 20 with
     * symbol, 40 with pair
     *
     * @param symbol (optional)
     * @param pair (optional)
     * @param orderId (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;AllOrdersResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> All Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/All-Orders">All
     *     Orders (USER_DATA) Documentation</a>
     */
    public ApiResponse<AllOrdersResponse> allOrders(
            String symbol,
            String pair,
            Long orderId,
            Long startTime,
            Long endTime,
            Long limit,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                allOrdersValidateBeforeCall(
                        symbol, pair, orderId, startTime, endTime, limit, recvWindow);
        java.lang.reflect.Type localVarReturnType = new TypeToken<AllOrdersResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for autoCancelAllOpenOrders
     *
     * @param autoCancelAllOpenOrdersRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Auto-Cancel-All-Open-Orders">Auto-Cancel
     *     All Open Orders (TRADE) Documentation</a>
     */
    private okhttp3.Call autoCancelAllOpenOrdersCall(
            AutoCancelAllOpenOrdersRequest autoCancelAllOpenOrdersRequest) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dapi/v1/countdownCancelAll";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (autoCancelAllOpenOrdersRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", autoCancelAllOpenOrdersRequest.getSymbol());
        }

        if (autoCancelAllOpenOrdersRequest.getCountdownTime() != null) {
            localVarFormParams.put(
                    "countdownTime", autoCancelAllOpenOrdersRequest.getCountdownTime());
        }

        if (autoCancelAllOpenOrdersRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", autoCancelAllOpenOrdersRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call autoCancelAllOpenOrdersValidateBeforeCall(
            AutoCancelAllOpenOrdersRequest autoCancelAllOpenOrdersRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {autoCancelAllOpenOrdersRequest};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "autoCancelAllOpenOrders",
                                    AutoCancelAllOpenOrdersRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return autoCancelAllOpenOrdersCall(autoCancelAllOpenOrdersRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Auto-Cancel All Open Orders (TRADE) Cancel all open orders of the specified symbol at the end
     * of the specified countdown. This rest endpoint means to ensure your open orders are canceled
     * in case of an outage. The endpoint should be called repeatedly as heartbeats so that the
     * existing countdown time can be canceled and repalced by a new one. The system will check all
     * countdowns **approximately every 10 milliseconds**, so please note that sufficient redundancy
     * should be considered when using this function. We do not recommend setting the countdown time
     * to be too precise or too small. * Example usage: Call this endpoint at 30s intervals with an
     * countdownTime of 120000 (120s). If this endpoint is not called within 120 seconds, all your
     * orders of the specified symbol will be automatically canceled. If this endpoint is called
     * with an countdownTime of 0, the countdown timer will be stopped. Weight: 10
     *
     * @param autoCancelAllOpenOrdersRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Auto-Cancel-All-Open-Orders">Auto-Cancel
     *     All Open Orders (TRADE) Documentation</a>
     */
    public ApiResponse<Void> autoCancelAllOpenOrders(
            @Valid @NotNull AutoCancelAllOpenOrdersRequest autoCancelAllOpenOrdersRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                autoCancelAllOpenOrdersValidateBeforeCall(autoCancelAllOpenOrdersRequest);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Build call for cancelAllOpenOrders
     *
     * @param symbol (required)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cancel All Open Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Cancel-All-Open-Orders">Cancel
     *     All Open Orders(TRADE) Documentation</a>
     */
    private okhttp3.Call cancelAllOpenOrdersCall(String symbol, Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dapi/v1/allOpenOrders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "DELETE",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cancelAllOpenOrdersValidateBeforeCall(String symbol, Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, recvWindow};
            Method method =
                    this.getClass().getMethod("cancelAllOpenOrders", String.class, Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return cancelAllOpenOrdersCall(symbol, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Cancel All Open Orders(TRADE) Cancel All Open Orders Weight: 1
     *
     * @param symbol (required)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;CancelAllOpenOrdersResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cancel All Open Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Cancel-All-Open-Orders">Cancel
     *     All Open Orders(TRADE) Documentation</a>
     */
    public ApiResponse<CancelAllOpenOrdersResponse> cancelAllOpenOrders(
            @NotNull String symbol, Long recvWindow) throws ApiException {
        okhttp3.Call localVarCall = cancelAllOpenOrdersValidateBeforeCall(symbol, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<CancelAllOpenOrdersResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for cancelMultipleOrders
     *
     * @param symbol (required)
     * @param orderIdList max length 10 &lt;br /&gt; e.g. [1234567,2345678] (optional)
     * @param origClientOrderIdList max length 10&lt;br /&gt; e.g.
     *     [\&quot;my_id_1\&quot;,\&quot;my_id_2\&quot;], encode the double quotes. No space after
     *     comma. (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cancel Multiple Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Cancel-Multiple-Orders">Cancel
     *     Multiple Orders(TRADE) Documentation</a>
     */
    private okhttp3.Call cancelMultipleOrdersCall(
            String symbol,
            OrderIdList orderIdList,
            OrigClientOrderIdList origClientOrderIdList,
            Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dapi/v1/batchOrders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (orderIdList != null) {
            String json = JSON.getGson().toJson(orderIdList);
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderIdList", json));
        }

        if (origClientOrderIdList != null) {
            String json = JSON.getGson().toJson(origClientOrderIdList);
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("origClientOrderIdList", json));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "DELETE",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cancelMultipleOrdersValidateBeforeCall(
            String symbol,
            OrderIdList orderIdList,
            OrigClientOrderIdList origClientOrderIdList,
            Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, orderIdList, origClientOrderIdList, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "cancelMultipleOrders",
                                    String.class,
                                    OrderIdList.class,
                                    OrigClientOrderIdList.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return cancelMultipleOrdersCall(
                        symbol, orderIdList, origClientOrderIdList, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Cancel Multiple Orders(TRADE) Cancel Multiple Orders * Either &#x60;orderIdList&#x60; or
     * &#x60;origClientOrderIdList &#x60; must be sent. Weight: 1
     *
     * @param symbol (required)
     * @param orderIdList max length 10 &lt;br /&gt; e.g. [1234567,2345678] (optional)
     * @param origClientOrderIdList max length 10&lt;br /&gt; e.g.
     *     [\&quot;my_id_1\&quot;,\&quot;my_id_2\&quot;], encode the double quotes. No space after
     *     comma. (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;CancelMultipleOrdersResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cancel Multiple Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Cancel-Multiple-Orders">Cancel
     *     Multiple Orders(TRADE) Documentation</a>
     */
    public ApiResponse<CancelMultipleOrdersResponse> cancelMultipleOrders(
            @NotNull String symbol,
            OrderIdList orderIdList,
            OrigClientOrderIdList origClientOrderIdList,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                cancelMultipleOrdersValidateBeforeCall(
                        symbol, orderIdList, origClientOrderIdList, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<CancelMultipleOrdersResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for cancelOrder
     *
     * @param symbol (required)
     * @param orderId (optional)
     * @param origClientOrderId (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cancel Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Cancel-Order">Cancel
     *     Order (TRADE) Documentation</a>
     */
    private okhttp3.Call cancelOrderCall(
            String symbol, Long orderId, String origClientOrderId, Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dapi/v1/order";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (orderId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderId", orderId));
        }

        if (origClientOrderId != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("origClientOrderId", origClientOrderId));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "DELETE",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cancelOrderValidateBeforeCall(
            String symbol, Long orderId, String origClientOrderId, Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, orderId, origClientOrderId, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "cancelOrder",
                                    String.class,
                                    Long.class,
                                    String.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return cancelOrderCall(symbol, orderId, origClientOrderId, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Cancel Order (TRADE) Cancel an active order. * Either &#x60;orderId&#x60; or
     * &#x60;origClientOrderId&#x60; must be sent. Weight: 1
     *
     * @param symbol (required)
     * @param orderId (optional)
     * @param origClientOrderId (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;CancelOrderResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cancel Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Cancel-Order">Cancel
     *     Order (TRADE) Documentation</a>
     */
    public ApiResponse<CancelOrderResponse> cancelOrder(
            @NotNull String symbol, Long orderId, String origClientOrderId, Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                cancelOrderValidateBeforeCall(symbol, orderId, origClientOrderId, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<CancelOrderResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for changeInitialLeverage
     *
     * @param changeInitialLeverageRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Change Initial Leverage </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Change-Initial-Leverage">Change
     *     Initial Leverage (TRADE) Documentation</a>
     */
    private okhttp3.Call changeInitialLeverageCall(
            ChangeInitialLeverageRequest changeInitialLeverageRequest) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dapi/v1/leverage";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (changeInitialLeverageRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", changeInitialLeverageRequest.getSymbol());
        }

        if (changeInitialLeverageRequest.getLeverage() != null) {
            localVarFormParams.put("leverage", changeInitialLeverageRequest.getLeverage());
        }

        if (changeInitialLeverageRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", changeInitialLeverageRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call changeInitialLeverageValidateBeforeCall(
            ChangeInitialLeverageRequest changeInitialLeverageRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {changeInitialLeverageRequest};
            Method method =
                    this.getClass()
                            .getMethod("changeInitialLeverage", ChangeInitialLeverageRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return changeInitialLeverageCall(changeInitialLeverageRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Change Initial Leverage (TRADE) Change user&#39;s initial leverage in the specific symbol
     * market. For Hedge Mode, LONG and SHORT positions of one symbol use the same initial leverage
     * and share a total notional value. Weight: 1
     *
     * @param changeInitialLeverageRequest (required)
     * @return ApiResponse&lt;ChangeInitialLeverageResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Change Initial Leverage </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Change-Initial-Leverage">Change
     *     Initial Leverage (TRADE) Documentation</a>
     */
    public ApiResponse<ChangeInitialLeverageResponse> changeInitialLeverage(
            @Valid @NotNull ChangeInitialLeverageRequest changeInitialLeverageRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                changeInitialLeverageValidateBeforeCall(changeInitialLeverageRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<ChangeInitialLeverageResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for changeMarginType
     *
     * @param changeMarginTypeRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Change Margin Type </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Change-Margin-Type">Change
     *     Margin Type (TRADE) Documentation</a>
     */
    private okhttp3.Call changeMarginTypeCall(ChangeMarginTypeRequest changeMarginTypeRequest)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dapi/v1/marginType";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (changeMarginTypeRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", changeMarginTypeRequest.getSymbol());
        }

        if (changeMarginTypeRequest.getMarginType() != null) {
            localVarFormParams.put("marginType", changeMarginTypeRequest.getMarginType());
        }

        if (changeMarginTypeRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", changeMarginTypeRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call changeMarginTypeValidateBeforeCall(
            ChangeMarginTypeRequest changeMarginTypeRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {changeMarginTypeRequest};
            Method method =
                    this.getClass().getMethod("changeMarginType", ChangeMarginTypeRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return changeMarginTypeCall(changeMarginTypeRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Change Margin Type (TRADE) Change user&#39;s margin type in the specific symbol market.For
     * Hedge Mode, LONG and SHORT positions of one symbol use the same margin type. With ISOLATED
     * margin type, margins of the LONG and SHORT positions are isolated from each other. Weight: 1
     *
     * @param changeMarginTypeRequest (required)
     * @return ApiResponse&lt;ChangeMarginTypeResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Change Margin Type </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Change-Margin-Type">Change
     *     Margin Type (TRADE) Documentation</a>
     */
    public ApiResponse<ChangeMarginTypeResponse> changeMarginType(
            @Valid @NotNull ChangeMarginTypeRequest changeMarginTypeRequest) throws ApiException {
        okhttp3.Call localVarCall = changeMarginTypeValidateBeforeCall(changeMarginTypeRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<ChangeMarginTypeResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for changePositionMode
     *
     * @param changePositionModeRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Change Position Mode </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Change-Position-Mode">Change
     *     Position Mode(TRADE) Documentation</a>
     */
    private okhttp3.Call changePositionModeCall(ChangePositionModeRequest changePositionModeRequest)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dapi/v1/positionSide/dual";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (changePositionModeRequest.getDualSidePosition() != null) {
            localVarFormParams.put(
                    "dualSidePosition", changePositionModeRequest.getDualSidePosition());
        }

        if (changePositionModeRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", changePositionModeRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call changePositionModeValidateBeforeCall(
            ChangePositionModeRequest changePositionModeRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {changePositionModeRequest};
            Method method =
                    this.getClass()
                            .getMethod("changePositionMode", ChangePositionModeRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return changePositionModeCall(changePositionModeRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Change Position Mode(TRADE) Change user&#39;s position mode (Hedge Mode or One-way Mode ) on
     * ***EVERY symbol*** Weight: 1
     *
     * @param changePositionModeRequest (required)
     * @return ApiResponse&lt;ChangePositionModeResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Change Position Mode </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Change-Position-Mode">Change
     *     Position Mode(TRADE) Documentation</a>
     */
    public ApiResponse<ChangePositionModeResponse> changePositionMode(
            @Valid @NotNull ChangePositionModeRequest changePositionModeRequest)
            throws ApiException {
        okhttp3.Call localVarCall = changePositionModeValidateBeforeCall(changePositionModeRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<ChangePositionModeResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for currentAllOpenOrders
     *
     * @param symbol (optional)
     * @param pair (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Current All Open Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Current-All-Open-Orders">Current
     *     All Open Orders (USER_DATA) Documentation</a>
     */
    private okhttp3.Call currentAllOpenOrdersCall(String symbol, String pair, Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dapi/v1/openOrders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (pair != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pair", pair));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call currentAllOpenOrdersValidateBeforeCall(
            String symbol, String pair, Long recvWindow) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, pair, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "currentAllOpenOrders", String.class, String.class, Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return currentAllOpenOrdersCall(symbol, pair, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Current All Open Orders (USER_DATA) Get all open orders on a symbol. **Careful** when
     * accessing this with no symbol. Weight: 1 for a single symbol, 40 for mutltiple symbols
     *
     * @param symbol (optional)
     * @param pair (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;CurrentAllOpenOrdersResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Current All Open Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Current-All-Open-Orders">Current
     *     All Open Orders (USER_DATA) Documentation</a>
     */
    public ApiResponse<CurrentAllOpenOrdersResponse> currentAllOpenOrders(
            String symbol, String pair, Long recvWindow) throws ApiException {
        okhttp3.Call localVarCall =
                currentAllOpenOrdersValidateBeforeCall(symbol, pair, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<CurrentAllOpenOrdersResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for getOrderModifyHistory
     *
     * @param symbol (required)
     * @param orderId (optional)
     * @param origClientOrderId (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Get Order Modify History </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Get-Order-Modify-History">Get
     *     Order Modify History (USER_DATA) Documentation</a>
     */
    private okhttp3.Call getOrderModifyHistoryCall(
            String symbol,
            Long orderId,
            String origClientOrderId,
            Long startTime,
            Long endTime,
            Long limit,
            Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dapi/v1/orderAmendment";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (orderId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderId", orderId));
        }

        if (origClientOrderId != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("origClientOrderId", origClientOrderId));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getOrderModifyHistoryValidateBeforeCall(
            String symbol,
            Long orderId,
            String origClientOrderId,
            Long startTime,
            Long endTime,
            Long limit,
            Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {
                symbol, orderId, origClientOrderId, startTime, endTime, limit, recvWindow
            };
            Method method =
                    this.getClass()
                            .getMethod(
                                    "getOrderModifyHistory",
                                    String.class,
                                    Long.class,
                                    String.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return getOrderModifyHistoryCall(
                        symbol, orderId, origClientOrderId, startTime, endTime, limit, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Get Order Modify History (USER_DATA) Get order modification history * Either
     * &#x60;orderId&#x60; or &#x60;origClientOrderId&#x60; must be sent, and the
     * &#x60;orderId&#x60; will prevail if both are sent. * Order modify history longer than 3 month
     * is not avaliable Weight: 1
     *
     * @param symbol (required)
     * @param orderId (optional)
     * @param origClientOrderId (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;GetOrderModifyHistoryResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Get Order Modify History </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Get-Order-Modify-History">Get
     *     Order Modify History (USER_DATA) Documentation</a>
     */
    public ApiResponse<GetOrderModifyHistoryResponse> getOrderModifyHistory(
            @NotNull String symbol,
            Long orderId,
            String origClientOrderId,
            Long startTime,
            Long endTime,
            Long limit,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                getOrderModifyHistoryValidateBeforeCall(
                        symbol, orderId, origClientOrderId, startTime, endTime, limit, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<GetOrderModifyHistoryResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for getPositionMarginChangeHistory
     *
     * @param symbol (required)
     * @param type 1: Add position margin,2: Reduce position margin (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Get Position Margin Change History </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Get-Position-Margin-Change-History">Get
     *     Position Margin Change History(TRADE) Documentation</a>
     */
    private okhttp3.Call getPositionMarginChangeHistoryCall(
            String symbol, Type type, Long startTime, Long endTime, Long limit, Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dapi/v1/positionMargin/history";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (type != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("type", type));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPositionMarginChangeHistoryValidateBeforeCall(
            String symbol, Type type, Long startTime, Long endTime, Long limit, Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, type, startTime, endTime, limit, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "getPositionMarginChangeHistory",
                                    String.class,
                                    Type.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return getPositionMarginChangeHistoryCall(
                        symbol, type, startTime, endTime, limit, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Get Position Margin Change History(TRADE) Get position margin change history Weight: 1
     *
     * @param symbol (required)
     * @param type 1: Add position margin,2: Reduce position margin (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;GetPositionMarginChangeHistoryResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Get Position Margin Change History </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Get-Position-Margin-Change-History">Get
     *     Position Margin Change History(TRADE) Documentation</a>
     */
    public ApiResponse<GetPositionMarginChangeHistoryResponse> getPositionMarginChangeHistory(
            @NotNull String symbol,
            Type type,
            Long startTime,
            Long endTime,
            Long limit,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                getPositionMarginChangeHistoryValidateBeforeCall(
                        symbol, type, startTime, endTime, limit, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<GetPositionMarginChangeHistoryResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for modifyIsolatedPositionMargin
     *
     * @param modifyIsolatedPositionMarginRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Modify Isolated Position Margin </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Modify-Isolated-Position-Margin">Modify
     *     Isolated Position Margin(TRADE) Documentation</a>
     */
    private okhttp3.Call modifyIsolatedPositionMarginCall(
            ModifyIsolatedPositionMarginRequest modifyIsolatedPositionMarginRequest)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dapi/v1/positionMargin";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (modifyIsolatedPositionMarginRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", modifyIsolatedPositionMarginRequest.getSymbol());
        }

        if (modifyIsolatedPositionMarginRequest.getPositionSide() != null) {
            localVarFormParams.put(
                    "positionSide", modifyIsolatedPositionMarginRequest.getPositionSide());
        }

        if (modifyIsolatedPositionMarginRequest.getAmount() != null) {
            localVarFormParams.put(
                    "amount",
                    DecimalFormatter.getFormatter()
                            .format(modifyIsolatedPositionMarginRequest.getAmount()));
        }

        if (modifyIsolatedPositionMarginRequest.getType() != null) {
            localVarFormParams.put("type", modifyIsolatedPositionMarginRequest.getType());
        }

        if (modifyIsolatedPositionMarginRequest.getRecvWindow() != null) {
            localVarFormParams.put(
                    "recvWindow", modifyIsolatedPositionMarginRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call modifyIsolatedPositionMarginValidateBeforeCall(
            ModifyIsolatedPositionMarginRequest modifyIsolatedPositionMarginRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {modifyIsolatedPositionMarginRequest};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "modifyIsolatedPositionMargin",
                                    ModifyIsolatedPositionMarginRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return modifyIsolatedPositionMarginCall(modifyIsolatedPositionMarginRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Modify Isolated Position Margin(TRADE) Modify Isolated Position Margin * Only for isolated
     * symbol Weight: 1
     *
     * @param modifyIsolatedPositionMarginRequest (required)
     * @return ApiResponse&lt;ModifyIsolatedPositionMarginResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Modify Isolated Position Margin </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Modify-Isolated-Position-Margin">Modify
     *     Isolated Position Margin(TRADE) Documentation</a>
     */
    public ApiResponse<ModifyIsolatedPositionMarginResponse> modifyIsolatedPositionMargin(
            @Valid @NotNull ModifyIsolatedPositionMarginRequest modifyIsolatedPositionMarginRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                modifyIsolatedPositionMarginValidateBeforeCall(modifyIsolatedPositionMarginRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<ModifyIsolatedPositionMarginResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for modifyMultipleOrders
     *
     * @param modifyMultipleOrdersRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Modify Multiple Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Modify-Multiple-Orders">Modify
     *     Multiple Orders(TRADE) Documentation</a>
     */
    private okhttp3.Call modifyMultipleOrdersCall(
            ModifyMultipleOrdersRequest modifyMultipleOrdersRequest) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dapi/v1/batchOrders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (modifyMultipleOrdersRequest.getBatchOrders() != null) {
            String json = JSON.getGson().toJson(modifyMultipleOrdersRequest.getBatchOrders());
            localVarFormParams.put("batchOrders", json);
        }

        if (modifyMultipleOrdersRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", modifyMultipleOrdersRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "PUT",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call modifyMultipleOrdersValidateBeforeCall(
            ModifyMultipleOrdersRequest modifyMultipleOrdersRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {modifyMultipleOrdersRequest};
            Method method =
                    this.getClass()
                            .getMethod("modifyMultipleOrders", ModifyMultipleOrdersRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return modifyMultipleOrdersCall(modifyMultipleOrdersRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Modify Multiple Orders(TRADE) Modify Multiple Orders * Parameter rules are same with
     * &#x60;Modify Order&#x60; * Batch modify orders are processed concurrently, and the order of
     * matching is not guaranteed. * The order of returned contents for batch modify orders is the
     * same as the order of the order list. * One order can only be modfied for less than 10000
     * times Weight: 5
     *
     * @param modifyMultipleOrdersRequest (required)
     * @return ApiResponse&lt;ModifyMultipleOrdersResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Modify Multiple Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Modify-Multiple-Orders">Modify
     *     Multiple Orders(TRADE) Documentation</a>
     */
    public ApiResponse<ModifyMultipleOrdersResponse> modifyMultipleOrders(
            @Valid @NotNull ModifyMultipleOrdersRequest modifyMultipleOrdersRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                modifyMultipleOrdersValidateBeforeCall(modifyMultipleOrdersRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<ModifyMultipleOrdersResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for modifyOrder
     *
     * @param modifyOrderRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Modify Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Modify-Order">Modify
     *     Order (TRADE) Documentation</a>
     */
    private okhttp3.Call modifyOrderCall(ModifyOrderRequest modifyOrderRequest)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dapi/v1/order";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (modifyOrderRequest.getOrderId() != null) {
            localVarFormParams.put("orderId", modifyOrderRequest.getOrderId());
        }

        if (modifyOrderRequest.getOrigClientOrderId() != null) {
            localVarFormParams.put("origClientOrderId", modifyOrderRequest.getOrigClientOrderId());
        }

        if (modifyOrderRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", modifyOrderRequest.getSymbol());
        }

        if (modifyOrderRequest.getSide() != null) {
            localVarFormParams.put("side", modifyOrderRequest.getSide());
        }

        if (modifyOrderRequest.getQuantity() != null) {
            localVarFormParams.put(
                    "quantity",
                    DecimalFormatter.getFormatter().format(modifyOrderRequest.getQuantity()));
        }

        if (modifyOrderRequest.getPrice() != null) {
            localVarFormParams.put(
                    "price", DecimalFormatter.getFormatter().format(modifyOrderRequest.getPrice()));
        }

        if (modifyOrderRequest.getPriceMatch() != null) {
            localVarFormParams.put("priceMatch", modifyOrderRequest.getPriceMatch());
        }

        if (modifyOrderRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", modifyOrderRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "PUT",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call modifyOrderValidateBeforeCall(ModifyOrderRequest modifyOrderRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {modifyOrderRequest};
            Method method = this.getClass().getMethod("modifyOrder", ModifyOrderRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return modifyOrderCall(modifyOrderRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Modify Order (TRADE) Order modify function, currently only LIMIT order modification is
     * supported, modified orders will be reordered in the match queue * Either &#x60;orderId&#x60;
     * or &#x60;origClientOrderId&#x60; must be sent, and the &#x60;orderId&#x60; will prevail if
     * both are sent. * Either &#x60;quantity&#x60; or &#x60;price&#x60; must be sent. * When the
     * new &#x60;quantity&#x60; or &#x60;price&#x60; doesn&#39;t satisfy PRICE_FILTER /
     * PERCENT_FILTER / LOT_SIZE, amendment will be rejected and the order will stay as it is. *
     * However the order will be cancelled by the amendment in the following situations: * when the
     * order is in partially filled status and the new &#x60;quantity&#x60; &lt;&#x3D;
     * &#x60;executedQty&#x60; * When the order is &#x60;GTX&#x60; and the new price will cause it
     * to be executed immediately * One order can only be modfied for less than 10000 times * Modify
     * order will set &#x60;selfTradePreventionMode&#x60; to &#x60;NONE&#x60; Weight: 1
     *
     * @param modifyOrderRequest (required)
     * @return ApiResponse&lt;ModifyOrderResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Modify Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Modify-Order">Modify
     *     Order (TRADE) Documentation</a>
     */
    public ApiResponse<ModifyOrderResponse> modifyOrder(
            @Valid @NotNull ModifyOrderRequest modifyOrderRequest) throws ApiException {
        okhttp3.Call localVarCall = modifyOrderValidateBeforeCall(modifyOrderRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<ModifyOrderResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for newOrder
     *
     * @param newOrderRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> New Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/New-Order">New
     *     Order (TRADE) Documentation</a>
     */
    private okhttp3.Call newOrderCall(NewOrderRequest newOrderRequest) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dapi/v1/order";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (newOrderRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", newOrderRequest.getSymbol());
        }

        if (newOrderRequest.getSide() != null) {
            localVarFormParams.put("side", newOrderRequest.getSide());
        }

        if (newOrderRequest.getPositionSide() != null) {
            localVarFormParams.put("positionSide", newOrderRequest.getPositionSide());
        }

        if (newOrderRequest.getType() != null) {
            localVarFormParams.put("type", newOrderRequest.getType());
        }

        if (newOrderRequest.getTimeInForce() != null) {
            localVarFormParams.put("timeInForce", newOrderRequest.getTimeInForce());
        }

        if (newOrderRequest.getQuantity() != null) {
            localVarFormParams.put(
                    "quantity",
                    DecimalFormatter.getFormatter().format(newOrderRequest.getQuantity()));
        }

        if (newOrderRequest.getReduceOnly() != null) {
            localVarFormParams.put("reduceOnly", newOrderRequest.getReduceOnly());
        }

        if (newOrderRequest.getPrice() != null) {
            localVarFormParams.put(
                    "price", DecimalFormatter.getFormatter().format(newOrderRequest.getPrice()));
        }

        if (newOrderRequest.getNewClientOrderId() != null) {
            localVarFormParams.put("newClientOrderId", newOrderRequest.getNewClientOrderId());
        }

        if (newOrderRequest.getStopPrice() != null) {
            localVarFormParams.put(
                    "stopPrice",
                    DecimalFormatter.getFormatter().format(newOrderRequest.getStopPrice()));
        }

        if (newOrderRequest.getClosePosition() != null) {
            localVarFormParams.put("closePosition", newOrderRequest.getClosePosition());
        }

        if (newOrderRequest.getActivationPrice() != null) {
            localVarFormParams.put(
                    "activationPrice",
                    DecimalFormatter.getFormatter().format(newOrderRequest.getActivationPrice()));
        }

        if (newOrderRequest.getCallbackRate() != null) {
            localVarFormParams.put(
                    "callbackRate",
                    DecimalFormatter.getFormatter().format(newOrderRequest.getCallbackRate()));
        }

        if (newOrderRequest.getWorkingType() != null) {
            localVarFormParams.put("workingType", newOrderRequest.getWorkingType());
        }

        if (newOrderRequest.getPriceProtect() != null) {
            localVarFormParams.put("priceProtect", newOrderRequest.getPriceProtect());
        }

        if (newOrderRequest.getNewOrderRespType() != null) {
            localVarFormParams.put("newOrderRespType", newOrderRequest.getNewOrderRespType());
        }

        if (newOrderRequest.getPriceMatch() != null) {
            localVarFormParams.put("priceMatch", newOrderRequest.getPriceMatch());
        }

        if (newOrderRequest.getSelfTradePreventionMode() != null) {
            localVarFormParams.put(
                    "selfTradePreventionMode", newOrderRequest.getSelfTradePreventionMode());
        }

        if (newOrderRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", newOrderRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call newOrderValidateBeforeCall(NewOrderRequest newOrderRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {newOrderRequest};
            Method method = this.getClass().getMethod("newOrder", NewOrderRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return newOrderCall(newOrderRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * New Order (TRADE) Send in a new order. * Order with type &#x60;STOP&#x60;, parameter
     * &#x60;timeInForce&#x60; can be sent ( default &#x60;GTC&#x60;). * Order with type
     * &#x60;TAKE_PROFIT&#x60;, parameter &#x60;timeInForce&#x60; can be sent ( default
     * &#x60;GTC&#x60;). * Condition orders will be triggered when: * If
     * parameter&#x60;priceProtect&#x60;is sent as true: * when price reaches the
     * &#x60;stopPrice&#x60; ，the difference rate between \&quot;MARK_PRICE\&quot; and
     * \&quot;CONTRACT_PRICE\&quot; cannot be larger than the \&quot;triggerProtect\&quot; of the
     * symbol * \&quot;triggerProtect\&quot; of a symbol can be got from &#x60;GET
     * /dapi/v1/exchangeInfo&#x60; * &#x60;STOP&#x60;, &#x60;STOP_MARKET&#x60;: * BUY: latest price
     * (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &gt;&#x3D; &#x60;stopPrice&#x60; *
     * SELL: latest price (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &lt;&#x3D;
     * &#x60;stopPrice&#x60; * &#x60;TAKE_PROFIT&#x60;, &#x60;TAKE_PROFIT_MARKET&#x60;: * BUY:
     * latest price (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &lt;&#x3D;
     * &#x60;stopPrice&#x60; * SELL: latest price (\&quot;MARK_PRICE\&quot; or
     * \&quot;CONTRACT_PRICE\&quot;) &gt;&#x3D; &#x60;stopPrice&#x60; *
     * &#x60;TRAILING_STOP_MARKET&#x60;: * BUY: the lowest price after order placed &#x60;&lt;&#x3D;
     * &#x60;activationPrice&#x60;, and the latest price &gt;&#x60;&#x3D; the lowest price * (1 +
     * &#x60;callbackRate&#x60;) * SELL: the highest price after order placed &gt;&#x3D;
     * &#x60;activationPrice&#x60;, and the latest price &lt;&#x3D; the highest price * (1 -
     * &#x60;callbackRate&#x60;) * For &#x60;TRAILING_STOP_MARKET&#x60;, if you got such error code.
     * &#x60;&#x60;{\&quot;code\&quot;: -2021, \&quot;msg\&quot;: \&quot;Order would immediately
     * trigger.\&quot;}&#x60;&#x60; means that the parameters you send do not meet the following
     * requirements: * BUY: &#x60;activationPrice&#x60; should be smaller than latest price. * SELL:
     * &#x60;activationPrice&#x60; should be larger than latest price. * If &#x60;newOrderRespType
     * &#x60; is sent as &#x60;RESULT&#x60; : * &#x60;MARKET&#x60; order: the final FILLED result of
     * the order will be return directly. * &#x60;LIMIT&#x60; order with special
     * &#x60;timeInForce&#x60;: the final status result of the order(FILLED or EXPIRED) will be
     * returned directly. * &#x60;STOP_MARKET&#x60;, &#x60;TAKE_PROFIT_MARKET&#x60; with
     * &#x60;closePosition&#x60;&#x3D;&#x60;true&#x60;: * Follow the same rules for condition
     * orders. * If triggered,**close all** current long position( if &#x60;SELL&#x60;) or current
     * short position( if &#x60;BUY&#x60;). * Cannot be used with &#x60;quantity&#x60; parameter *
     * Cannot be used with &#x60;reduceOnly&#x60; parameter * In Hedge Mode,cannot be used with
     * &#x60;BUY&#x60; orders in &#x60;LONG&#x60; position side. and cannot be used with
     * &#x60;SELL&#x60; orders in &#x60;SHORT&#x60; position side *
     * &#x60;selfTradePreventionMode&#x60; is only effective when &#x60;timeInForce&#x60; set to
     * &#x60;IOC&#x60; or &#x60;GTC&#x60;. Weight: 1 on 1min order rate
     * limit(X-MBX-ORDER-COUNT-1M)\\ 0 on IP rate limit(x-mbx-used-weight-1m)
     *
     * @param newOrderRequest (required)
     * @return ApiResponse&lt;NewOrderResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> New Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/New-Order">New
     *     Order (TRADE) Documentation</a>
     */
    public ApiResponse<NewOrderResponse> newOrder(@Valid @NotNull NewOrderRequest newOrderRequest)
            throws ApiException {
        okhttp3.Call localVarCall = newOrderValidateBeforeCall(newOrderRequest);
        java.lang.reflect.Type localVarReturnType = new TypeToken<NewOrderResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for positionAdlQuantileEstimation
     *
     * @param symbol (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Position ADL Quantile Estimation </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Position-ADL-Quantile-Estimation">Position
     *     ADL Quantile Estimation(USER_DATA) Documentation</a>
     */
    private okhttp3.Call positionAdlQuantileEstimationCall(String symbol, Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dapi/v1/adlQuantile";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call positionAdlQuantileEstimationValidateBeforeCall(
            String symbol, Long recvWindow) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod("positionAdlQuantileEstimation", String.class, Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return positionAdlQuantileEstimationCall(symbol, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Position ADL Quantile Estimation(USER_DATA) Query position ADL quantile estimation * Values
     * update every 30s. * Values 0, 1, 2, 3, 4 shows the queue position and possibility of ADL from
     * low to high. * For positions of the symbol are in One-way Mode or isolated margined in Hedge
     * Mode, \&quot;LONG\&quot;, \&quot;SHORT\&quot;, and \&quot;BOTH\&quot; will be returned to
     * show the positions&#39; adl quantiles of different position sides. * If the positions of the
     * symbol are crossed margined in Hedge Mode: * \&quot;HEDGE\&quot; as a sign will be returned
     * instead of \&quot;BOTH\&quot;; * A same value caculated on unrealized pnls on long and short
     * sides&#39; positions will be shown for \&quot;LONG\&quot; and \&quot;SHORT\&quot; when there
     * are positions in both of long and short sides. Weight: 5
     *
     * @param symbol (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;PositionAdlQuantileEstimationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Position ADL Quantile Estimation </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Position-ADL-Quantile-Estimation">Position
     *     ADL Quantile Estimation(USER_DATA) Documentation</a>
     */
    public ApiResponse<PositionAdlQuantileEstimationResponse> positionAdlQuantileEstimation(
            String symbol, Long recvWindow) throws ApiException {
        okhttp3.Call localVarCall =
                positionAdlQuantileEstimationValidateBeforeCall(symbol, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<PositionAdlQuantileEstimationResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for positionInformation
     *
     * @param marginAsset (optional)
     * @param pair (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Position Information </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Position-Information">Position
     *     Information(USER_DATA) Documentation</a>
     */
    private okhttp3.Call positionInformationCall(String marginAsset, String pair, Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dapi/v1/positionRisk";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (marginAsset != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("marginAsset", marginAsset));
        }

        if (pair != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pair", pair));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call positionInformationValidateBeforeCall(
            String marginAsset, String pair, Long recvWindow) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {marginAsset, pair, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "positionInformation", String.class, String.class, Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return positionInformationCall(marginAsset, pair, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Position Information(USER_DATA) Get current account information. * If neither
     * &#x60;marginAsset&#x60; nor &#x60;pair&#x60; is sent, positions of all symbols with
     * &#x60;TRADING&#x60; status will be returned. * for One-way Mode user, the response will only
     * show the \&quot;BOTH\&quot; positions * for Hedge Mode user, the response will show
     * \&quot;BOTH\&quot;, \&quot;LONG\&quot;, and \&quot;SHORT\&quot; positions. Please use with
     * user data stream &#x60;ACCOUNT_UPDATE&#x60; to meet your timeliness and accuracy needs.
     * Weight: 1
     *
     * @param marginAsset (optional)
     * @param pair (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;PositionInformationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Position Information </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Position-Information">Position
     *     Information(USER_DATA) Documentation</a>
     */
    public ApiResponse<PositionInformationResponse> positionInformation(
            String marginAsset, String pair, Long recvWindow) throws ApiException {
        okhttp3.Call localVarCall =
                positionInformationValidateBeforeCall(marginAsset, pair, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<PositionInformationResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for queryCurrentOpenOrder
     *
     * @param symbol (required)
     * @param orderId (optional)
     * @param origClientOrderId (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Current Open Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Query-Current-Open-Order">Query
     *     Current Open Order(USER_DATA) Documentation</a>
     */
    private okhttp3.Call queryCurrentOpenOrderCall(
            String symbol, Long orderId, String origClientOrderId, Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dapi/v1/openOrder";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (orderId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderId", orderId));
        }

        if (origClientOrderId != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("origClientOrderId", origClientOrderId));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryCurrentOpenOrderValidateBeforeCall(
            String symbol, Long orderId, String origClientOrderId, Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, orderId, origClientOrderId, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "queryCurrentOpenOrder",
                                    String.class,
                                    Long.class,
                                    String.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return queryCurrentOpenOrderCall(symbol, orderId, origClientOrderId, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Query Current Open Order(USER_DATA) Query Current Open Order * Either&#x60;orderId&#x60; or
     * &#x60;origClientOrderId&#x60; must be sent * If the queried order has been filled or
     * cancelled, the error message \&quot;Order does not exist\&quot; will be returned. Weight: 1
     *
     * @param symbol (required)
     * @param orderId (optional)
     * @param origClientOrderId (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;QueryCurrentOpenOrderResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Current Open Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Query-Current-Open-Order">Query
     *     Current Open Order(USER_DATA) Documentation</a>
     */
    public ApiResponse<QueryCurrentOpenOrderResponse> queryCurrentOpenOrder(
            @NotNull String symbol, Long orderId, String origClientOrderId, Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                queryCurrentOpenOrderValidateBeforeCall(
                        symbol, orderId, origClientOrderId, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<QueryCurrentOpenOrderResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for queryOrder
     *
     * @param symbol (required)
     * @param orderId (optional)
     * @param origClientOrderId (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Query-Order">Query
     *     Order (USER_DATA) Documentation</a>
     */
    private okhttp3.Call queryOrderCall(
            String symbol, Long orderId, String origClientOrderId, Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dapi/v1/order";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (orderId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderId", orderId));
        }

        if (origClientOrderId != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("origClientOrderId", origClientOrderId));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryOrderValidateBeforeCall(
            String symbol, Long orderId, String origClientOrderId, Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, orderId, origClientOrderId, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "queryOrder",
                                    String.class,
                                    Long.class,
                                    String.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return queryOrderCall(symbol, orderId, origClientOrderId, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Query Order (USER_DATA) Check an order&#39;s status. * These orders will not be found: *
     * order status is CANCELED or EXPIRED AND order has NO filled trade AND created time + 3 days
     * &lt; current time * order create time + 90 days &lt; current time * Either
     * &#x60;orderId&#x60; or &#x60;origClientOrderId&#x60; must be sent. Weight: 1
     *
     * @param symbol (required)
     * @param orderId (optional)
     * @param origClientOrderId (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;QueryOrderResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Query-Order">Query
     *     Order (USER_DATA) Documentation</a>
     */
    public ApiResponse<QueryOrderResponse> queryOrder(
            @NotNull String symbol, Long orderId, String origClientOrderId, Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                queryOrderValidateBeforeCall(symbol, orderId, origClientOrderId, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<QueryOrderResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for usersForceOrders
     *
     * @param symbol (optional)
     * @param autoCloseType \&quot;LIQUIDATION\&quot; for liquidation orders, \&quot;ADL\&quot; for
     *     ADL orders. (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User&#39;s Force Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Users-Force-Orders">User&#39;s
     *     Force Orders(USER_DATA) Documentation</a>
     */
    private okhttp3.Call usersForceOrdersCall(
            String symbol,
            AutoCloseType autoCloseType,
            Long startTime,
            Long endTime,
            Long limit,
            Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/dapi/v1/forceOrders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (autoCloseType != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("autoCloseType", autoCloseType));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usersForceOrdersValidateBeforeCall(
            String symbol,
            AutoCloseType autoCloseType,
            Long startTime,
            Long endTime,
            Long limit,
            Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {
                symbol, autoCloseType, startTime, endTime, limit, recvWindow
            };
            Method method =
                    this.getClass()
                            .getMethod(
                                    "usersForceOrders",
                                    String.class,
                                    AutoCloseType.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return usersForceOrdersCall(
                        symbol, autoCloseType, startTime, endTime, limit, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * User&#39;s Force Orders(USER_DATA) User&#39;s Force Orders * If \&quot;autoCloseType\&quot;
     * is not sent, orders with both of the types will be returned * If \&quot;startTime\&quot; is
     * not sent, data within 200 days before \&quot;endTime\&quot; can be queried Weight: 20 with
     * symbol, 50 without symbol
     *
     * @param symbol (optional)
     * @param autoCloseType \&quot;LIQUIDATION\&quot; for liquidation orders, \&quot;ADL\&quot; for
     *     ADL orders. (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;UsersForceOrdersResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User&#39;s Force Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Users-Force-Orders">User&#39;s
     *     Force Orders(USER_DATA) Documentation</a>
     */
    public ApiResponse<UsersForceOrdersResponse> usersForceOrders(
            String symbol,
            AutoCloseType autoCloseType,
            Long startTime,
            Long endTime,
            Long limit,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                usersForceOrdersValidateBeforeCall(
                        symbol, autoCloseType, startTime, endTime, limit, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<UsersForceOrdersResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }
}
