/*
 * Binance Derivatives Trading Portfolio Margin REST API
 * OpenAPI Specification for the Binance Derivatives Trading Portfolio Margin REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_portfolio_margin.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.AutoCloseType;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.CancelAllCmOpenConditionalOrdersResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.CancelAllCmOpenOrdersResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.CancelAllUmOpenConditionalOrdersResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.CancelAllUmOpenOrdersResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.CancelCmConditionalOrderResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.CancelCmOrderResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.CancelMarginAccountAllOpenOrdersOnASymbolResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.CancelMarginAccountOcoOrdersResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.CancelMarginAccountOrderResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.CancelUmConditionalOrderResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.CancelUmOrderResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.CmAccountTradeListResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.CmPositionAdlQuantileEstimationResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.GetUmFuturesBnbBurnStatusResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.MarginAccountBorrowRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.MarginAccountBorrowResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.MarginAccountNewOcoRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.MarginAccountNewOcoResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.MarginAccountRepayDebtRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.MarginAccountRepayDebtResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.MarginAccountRepayRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.MarginAccountRepayResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.MarginAccountTradeListResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.ModifyCmOrderRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.ModifyCmOrderResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.ModifyUmOrderRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.ModifyUmOrderResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.NewCmConditionalOrderRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.NewCmConditionalOrderResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.NewCmOrderRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.NewCmOrderResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.NewMarginOrderRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.NewMarginOrderResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.NewUmConditionalOrderRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.NewUmConditionalOrderResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.NewUmOrderRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.NewUmOrderResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryAllCmConditionalOrdersResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryAllCmOrdersResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryAllCurrentCmOpenConditionalOrdersResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryAllCurrentCmOpenOrdersResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryAllCurrentUmOpenConditionalOrdersResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryAllCurrentUmOpenOrdersResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryAllMarginAccountOrdersResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryAllUmConditionalOrdersResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryAllUmOrdersResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryCmConditionalOrderHistoryResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryCmModifyOrderHistoryResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryCmOrderResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryCurrentCmOpenConditionalOrderResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryCurrentCmOpenOrderResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryCurrentMarginOpenOrderResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryCurrentUmOpenConditionalOrderResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryCurrentUmOpenOrderResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryMarginAccountOrderResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryMarginAccountsAllOcoResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryMarginAccountsOcoResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryMarginAccountsOpenOcoResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryUmConditionalOrderHistoryResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryUmModifyOrderHistoryResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryUmOrderResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryUsersCmForceOrdersResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryUsersMarginForceOrdersResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryUsersUmForceOrdersResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.Side;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.StrategyType;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.ToggleBnbBurnOnUmFuturesTradeRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.ToggleBnbBurnOnUmFuturesTradeResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.Type;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.UmAccountTradeListResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.UmPositionAdlQuantileEstimationResponse;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for TradeApi */
public class TradeApiTest {

    private TradeApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new TradeApi(apiClientSpy);
    }

    /**
     * Cancel All CM Open Conditional Orders(TRADE)
     *
     * <p>Cancel All CM Open Conditional Orders Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelAllCmOpenConditionalOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<CancelAllCmOpenConditionalOrdersResponse> response =
                api.cancelAllCmOpenConditionalOrders(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/conditional/allOpenOrders", actualRequest.url().encodedPath());
    }

    /**
     * Cancel All CM Open Orders(TRADE)
     *
     * <p>Cancel all active LIMIT orders on specific symbol Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelAllCmOpenOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<CancelAllCmOpenOrdersResponse> response =
                api.cancelAllCmOpenOrders(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/allOpenOrders", actualRequest.url().encodedPath());
    }

    /**
     * Cancel All UM Open Conditional Orders (TRADE)
     *
     * <p>Cancel All UM Open Conditional Orders Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelAllUmOpenConditionalOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<CancelAllUmOpenConditionalOrdersResponse> response =
                api.cancelAllUmOpenConditionalOrders(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/conditional/allOpenOrders", actualRequest.url().encodedPath());
    }

    /**
     * Cancel All UM Open Orders(TRADE)
     *
     * <p>Cancel all active LIMIT orders on specific symbol Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelAllUmOpenOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<CancelAllUmOpenOrdersResponse> response =
                api.cancelAllUmOpenOrders(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/allOpenOrders", actualRequest.url().encodedPath());
    }

    /**
     * Cancel CM Conditional Order(TRADE)
     *
     * <p>Cancel CM Conditional Order * Either &#x60;strategyId&#x60; or
     * &#x60;newClientStrategyId&#x60; must be sent. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelCmConditionalOrderTest() throws ApiException, CryptoException {
        String symbol = "";
        Long strategyId = 1L;
        String newClientStrategyId = "1";
        Long recvWindow = 5000L;
        ApiResponse<CancelCmConditionalOrderResponse> response =
                api.cancelCmConditionalOrder(symbol, strategyId, newClientStrategyId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&strategyId=1&newClientStrategyId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "a122adefbf5aadf438d7dc29aaf824c9960c880ff367781502c41a638ee6637f",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/conditional/order", actualRequest.url().encodedPath());
    }

    /**
     * Cancel CM Order(TRADE)
     *
     * <p>Cancel an active LIMIT order * Either &#x60;orderId&#x60; or &#x60;origClientOrderId&#x60;
     * must be sent. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelCmOrderTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        String origClientOrderId = "1";
        Long recvWindow = 5000L;
        ApiResponse<CancelCmOrderResponse> response =
                api.cancelCmOrder(symbol, orderId, origClientOrderId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&orderId=1&origClientOrderId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "cbec82483be2ad044b893ffb2e6bc0d55370e378eaea0b4b61d95893bd9cc458",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/order", actualRequest.url().encodedPath());
    }

    /**
     * Cancel Margin Account All Open Orders on a Symbol(TRADE)
     *
     * <p>Cancel Margin Account All Open Orders on a Symbol Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelMarginAccountAllOpenOrdersOnASymbolTest()
            throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<CancelMarginAccountAllOpenOrdersOnASymbolResponse> response =
                api.cancelMarginAccountAllOpenOrdersOnASymbol(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/margin/allOpenOrders", actualRequest.url().encodedPath());
    }

    /**
     * Cancel Margin Account OCO Orders(TRADE)
     *
     * <p>Cancel Margin Account OCO Orders * Additional notes: Canceling an individual leg will
     * cancel the entire OCO Weight: 2
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelMarginAccountOcoOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderListId = 1L;
        String listClientOrderId = "1";
        String newClientOrderId = "1";
        Long recvWindow = 5000L;
        ApiResponse<CancelMarginAccountOcoOrdersResponse> response =
                api.cancelMarginAccountOcoOrders(
                        symbol, orderListId, listClientOrderId, newClientOrderId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&orderListId=1&listClientOrderId=1&newClientOrderId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "a45bdd3aa762931d7a258dd29daa4df12bf8980aa9020db3df0e49fb49044d58",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/margin/orderList", actualRequest.url().encodedPath());
    }

    /**
     * Cancel Margin Account Order(TRADE)
     *
     * <p>Cancel Margin Account Order * Either &#x60;orderId&#x60; or &#x60;origClientOrderId&#x60;
     * must be sent. Weight: 2
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelMarginAccountOrderTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        String origClientOrderId = "1";
        String newClientOrderId = "1";
        Long recvWindow = 5000L;
        ApiResponse<CancelMarginAccountOrderResponse> response =
                api.cancelMarginAccountOrder(
                        symbol, orderId, origClientOrderId, newClientOrderId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&orderId=1&origClientOrderId=1&newClientOrderId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "bde8880b45003f9fc2944760c55aa5805d96649e145da141ccdbc1f7451fd1fc",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/margin/order", actualRequest.url().encodedPath());
    }

    /**
     * Cancel UM Conditional Order(TRADE)
     *
     * <p>Cancel UM Conditional Order * Either &#x60;strategyId&#x60; or
     * &#x60;newClientStrategyId&#x60; must be sent. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelUmConditionalOrderTest() throws ApiException, CryptoException {
        String symbol = "";
        Long strategyId = 1L;
        String newClientStrategyId = "1";
        Long recvWindow = 5000L;
        ApiResponse<CancelUmConditionalOrderResponse> response =
                api.cancelUmConditionalOrder(symbol, strategyId, newClientStrategyId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&strategyId=1&newClientStrategyId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "a122adefbf5aadf438d7dc29aaf824c9960c880ff367781502c41a638ee6637f",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/conditional/order", actualRequest.url().encodedPath());
    }

    /**
     * Cancel UM Order(TRADE)
     *
     * <p>Cancel an active UM LIMIT order * Either &#x60;orderId&#x60; or
     * &#x60;origClientOrderId&#x60; must be sent. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelUmOrderTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        String origClientOrderId = "1";
        Long recvWindow = 5000L;
        ApiResponse<CancelUmOrderResponse> response =
                api.cancelUmOrder(symbol, orderId, origClientOrderId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&orderId=1&origClientOrderId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "cbec82483be2ad044b893ffb2e6bc0d55370e378eaea0b4b61d95893bd9cc458",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/order", actualRequest.url().encodedPath());
    }

    /**
     * CM Account Trade List(USER_DATA)
     *
     * <p>Get trades for a specific account and CM symbol. * Either &#x60;symbol&#x60; or
     * &#x60;pair&#x60; must be sent * &#x60;symbol&#x60; and &#x60;pair&#x60; cannot be sent
     * together * &#x60;pair&#x60; and &#x60;fromId&#x60; cannot be sent together *
     * &#x60;OrderId&#x60; can only be sent together with symbol * If a &#x60;pair&#x60; is sent,
     * tickers for all symbols of the &#x60;pair&#x60; will be returned * The parameter
     * &#x60;fromId&#x60; cannot be sent with &#x60;startTime&#x60; or &#x60;endTime&#x60; Weight:
     * 20 with symbol, 40 with pair
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cmAccountTradeListTest() throws ApiException, CryptoException {
        String symbol = "";
        String pair = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long fromId = 1L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<CmAccountTradeListResponse> response =
                api.cmAccountTradeList(symbol, pair, startTime, endTime, fromId, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&pair=&startTime=1623319461670&endTime=1641782889000&fromId=1&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "bbf5f4652084c7930acb2dd52e609ec86e6b1af1db7971e283c9cff769bf35a1",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/userTrades", actualRequest.url().encodedPath());
    }

    /**
     * CM Position ADL Quantile Estimation(USER_DATA)
     *
     * <p>Query CM Position ADL Quantile Estimation * Values update every 30s. * Values 0, 1, 2, 3,
     * 4 shows the queue position and possibility of ADL from low to high. * For positions of the
     * symbol are in One-way Mode or isolated margined in Hedge Mode, \&quot;LONG\&quot;,
     * \&quot;SHORT\&quot;, and \&quot;BOTH\&quot; will be returned to show the positions&#39; adl
     * quantiles of different position sides. * If the positions of the symbol are crossed margined
     * in Hedge Mode: * \&quot;HEDGE\&quot; as a sign will be returned instead of
     * \&quot;BOTH\&quot;; * A same value caculated on unrealized pnls on long and short sides&#39;
     * positions will be shown for \&quot;LONG\&quot; and \&quot;SHORT\&quot; when there are
     * positions in both of long and short sides. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cmPositionAdlQuantileEstimationTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<CmPositionAdlQuantileEstimationResponse> response =
                api.cmPositionAdlQuantileEstimation(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/adlQuantile", actualRequest.url().encodedPath());
    }

    /**
     * Get UM Futures BNB Burn Status (USER_DATA)
     *
     * <p>Get user&#39;s BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off )
     * Weight: 30
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getUmFuturesBnbBurnStatusTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<GetUmFuturesBnbBurnStatusResponse> response =
                api.getUmFuturesBnbBurnStatus(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/feeBurn", actualRequest.url().encodedPath());
    }

    /**
     * Margin Account Borrow(MARGIN)
     *
     * <p>Apply for a margin loan. Weight: 100
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void marginAccountBorrowTest() throws ApiException, CryptoException {
        MarginAccountBorrowRequest marginAccountBorrowRequest = new MarginAccountBorrowRequest();

        marginAccountBorrowRequest.asset("");
        marginAccountBorrowRequest.amount(1d);

        ApiResponse<MarginAccountBorrowResponse> response =
                api.marginAccountBorrow(marginAccountBorrowRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000amount=1&asset=", signInputCaptor.getValue());
        assertEquals(
                "bdf4ac8bca8190f70887c6f51a3651b89a8e693487de037a66a7d489ebcde7a4",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/marginLoan", actualRequest.url().encodedPath());
    }

    /**
     * Margin Account New OCO(TRADE)
     *
     * <p>Send in a new OCO for a margin account * Price Restrictions: * &#x60;SELL&#x60;: Limit
     * Price &gt; Last Price &gt; Stop Price * &#x60;BUY&#x60;: Limit Price &lt; Last Price &lt;
     * Stop Price * Quantity Restrictions: * Both legs must have the same quantity *
     * &#x60;ICEBERG&#x60; quantities however do not have to be the same. * Order Rate Limit *
     * &#x60;OCO&#x60; counts as 2 orders against the order rate limit. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void marginAccountNewOcoTest() throws ApiException, CryptoException {
        MarginAccountNewOcoRequest marginAccountNewOcoRequest = new MarginAccountNewOcoRequest();

        marginAccountNewOcoRequest.symbol("");
        marginAccountNewOcoRequest.side(Side.BUY);
        marginAccountNewOcoRequest.quantity(1d);
        marginAccountNewOcoRequest.price(1d);
        marginAccountNewOcoRequest.stopPrice(1d);

        ApiResponse<MarginAccountNewOcoResponse> response =
                api.marginAccountNewOco(marginAccountNewOcoRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=&side=BUY&stopPrice=1&quantity=1&price=1",
                signInputCaptor.getValue());
        assertEquals(
                "a44f38881c72baae22ef0ab8d4275a3dad363487848a7ea9ea3c7ba58a6ccdb9",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/margin/order/oco", actualRequest.url().encodedPath());
    }

    /**
     * Margin Account Repay(MARGIN)
     *
     * <p>Repay for a margin loan. Weight: 100
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void marginAccountRepayTest() throws ApiException, CryptoException {
        MarginAccountRepayRequest marginAccountRepayRequest = new MarginAccountRepayRequest();

        marginAccountRepayRequest.asset("");
        marginAccountRepayRequest.amount(1d);

        ApiResponse<MarginAccountRepayResponse> response =
                api.marginAccountRepay(marginAccountRepayRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000amount=1&asset=", signInputCaptor.getValue());
        assertEquals(
                "bdf4ac8bca8190f70887c6f51a3651b89a8e693487de037a66a7d489ebcde7a4",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/repayLoan", actualRequest.url().encodedPath());
    }

    /**
     * Margin Account Repay Debt(TRADE)
     *
     * <p>Repay debt for a margin loan. * The repay asset amount cannot exceed 50000 USD equivalent
     * value for a single request. * If &#x60;amount&#x60; is not sent, all the asset loan will be
     * repaid if having enough specific repay assets. * If &#x60;amount&#x60; is sent, only the
     * certain amount of the asset loan will be repaid if having enough specific repay assets. * The
     * system will use the same asset to repay the loan first (if have) no matter whether put the
     * asset in &#x60;specifyRepayAssets&#x60; Weight: 3000
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void marginAccountRepayDebtTest() throws ApiException, CryptoException {
        MarginAccountRepayDebtRequest marginAccountRepayDebtRequest =
                new MarginAccountRepayDebtRequest();

        marginAccountRepayDebtRequest.asset("");

        ApiResponse<MarginAccountRepayDebtResponse> response =
                api.marginAccountRepayDebt(marginAccountRepayDebtRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000asset=", signInputCaptor.getValue());
        assertEquals(
                "733c2733b75fbea096af9abd7a6e22ac4cce318248e66e514087362c82db2bf1",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/margin/repay-debt", actualRequest.url().encodedPath());
    }

    /**
     * Margin Account Trade List (USER_DATA)
     *
     * <p>Margin Account Trade List Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void marginAccountTradeListTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long fromId = 1L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<MarginAccountTradeListResponse> response =
                api.marginAccountTradeList(
                        symbol, orderId, startTime, endTime, fromId, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&orderId=1&startTime=1623319461670&endTime=1641782889000&fromId=1&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "10058794572cc782968aa3d3e6b73a369146898e471235e8712344dea70cb4d5",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/margin/myTrades", actualRequest.url().encodedPath());
    }

    /**
     * Modify CM Order(TRADE)
     *
     * <p>Order modify function, currently only LIMIT order modification is supported, modified
     * orders will be reordered in the match queue * Either &#x60;orderId&#x60; or
     * &#x60;origClientOrderId&#x60; must be sent, and the &#x60;orderId&#x60; will prevail if both
     * are sent. * Both &#x60;quantity&#x60; and &#x60;price&#x60; must be sent * When the new
     * &#x60;quantity&#x60; or &#x60;price&#x60; doesn&#39;t satisfy PRICE_FILTER / PERCENT_FILTER /
     * LOT_SIZE, amendment will be rejected and the order will stay as it is. * However the order
     * will be cancelled by the amendment in the following situations: * when the order is in
     * partially filled status and the new &#x60;quantity&#x60; &lt;&#x3D; &#x60;executedQty&#x60; *
     * When the order is &#x60;GTX&#x60; and the new price will cause it to be executed immediately
     * Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void modifyCmOrderTest() throws ApiException, CryptoException {
        ModifyCmOrderRequest modifyCmOrderRequest = new ModifyCmOrderRequest();

        modifyCmOrderRequest.symbol("");
        modifyCmOrderRequest.side(Side.BUY);
        modifyCmOrderRequest.quantity(1d);
        modifyCmOrderRequest.price(1d);

        ApiResponse<ModifyCmOrderResponse> response = api.modifyCmOrder(modifyCmOrderRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=&side=BUY&quantity=1&price=1",
                signInputCaptor.getValue());
        assertEquals(
                "5d55a15240b44cfacea70546cc8dc2e0e1394ec0f194ec1bf1e67bfac92cd911",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/order", actualRequest.url().encodedPath());
    }

    /**
     * Modify UM Order(TRADE)
     *
     * <p>Order modify function, currently only LIMIT order modification is supported, modified
     * orders will be reordered in the match queue * Either orderId or origClientOrderId must be
     * sent, and the orderId will prevail if both are sent. * Both quantity and price must be sent *
     * When the new quantity or price doesn&#39;t satisfy PRICE_FILTER / PERCENT_FILTER / LOT_SIZE,
     * amendment will be rejected and the order will stay as it is. * However the order will be
     * cancelled by the amendment in the following situations: * when the order is in partially
     * filled status and the new quantity &lt;&#x3D; executedQty * When the order is GTX and the new
     * price will cause it to be executed immediately Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void modifyUmOrderTest() throws ApiException, CryptoException {
        ModifyUmOrderRequest modifyUmOrderRequest = new ModifyUmOrderRequest();

        modifyUmOrderRequest.symbol("");
        modifyUmOrderRequest.side(Side.BUY);
        modifyUmOrderRequest.quantity(1d);
        modifyUmOrderRequest.price(1d);

        ApiResponse<ModifyUmOrderResponse> response = api.modifyUmOrder(modifyUmOrderRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=&side=BUY&quantity=1&price=1",
                signInputCaptor.getValue());
        assertEquals(
                "5d55a15240b44cfacea70546cc8dc2e0e1394ec0f194ec1bf1e67bfac92cd911",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/order", actualRequest.url().encodedPath());
    }

    /**
     * New CM Conditional Order(TRADE)
     *
     * <p>New CM Conditional Order * Order with type &#x60;STOP/TAKE_PROFIT&#x60;, parameter
     * &#x60;timeInForce&#x60; can be sent ( default &#x60;GTC&#x60;). * Condition orders will be
     * triggered when: * &#x60;STOP&#x60;, &#x60;STOP_MARKET&#x60;: * BUY: \&quot;MARK_PRICE\&quot;
     * &gt;&#x3D; &#x60;stopPrice&#x60; * SELL: \&quot;MARK_PRICE\&quot; &lt;&#x3D;
     * &#x60;stopPrice&#x60; * &#x60;TAKE_PROFIT&#x60;, &#x60;TAKE_PROFIT_MARKET&#x60;: * BUY:
     * \&quot;MARK_PRICE\&quot; &lt;&#x3D; &#x60;stopPrice&#x60; * SELL: \&quot;MARK_PRICE\&quot;
     * &gt;&#x3D; &#x60;stopPrice&#x60; * &#x60;TRAILING_STOP_MARKET&#x60;: * BUY: the lowest mark
     * price after order placed &#x60;&lt;&#x3D; &#x60;activationPrice&#x60;, and the latest mark
     * price &gt;&#x60;&#x3D; the lowest mark price * (1 + &#x60;callbackRate&#x60;) * SELL: the
     * highest mark price after order placed &gt;&#x3D; &#x60;activationPrice&#x60;, and the latest
     * mark price &lt;&#x3D; the highest mark price * (1 - &#x60;callbackRate&#x60;) * For
     * &#x60;TRAILING_STOP_MARKET&#x60;, if you got such error code. &#x60;{\&quot;code\&quot;:
     * -2021, \&quot;msg\&quot;: \&quot;Order would immediately trigger.\&quot;}&#x60; means that
     * the parameters you send do not meet the following requirements: * BUY:
     * &#x60;activationPrice&#x60; should be smaller than latest mark price. * SELL:
     * &#x60;activationPrice&#x60; should be larger than latest mark price. * Condition orders will
     * be triggered when: * If parameter&#x60;priceProtect&#x60;is sent as true: * when price
     * reaches the &#x60;stopPrice&#x60; ï¼Œthe difference rate between \&quot;MARK_PRICE\&quot; and
     * \&quot;CONTRACT_PRICE\&quot; cannot be larger than the \&quot;triggerProtect\&quot; of the
     * symbol * \&quot;triggerProtect\&quot; of a symbol can be got from &#x60;GET
     * /fapi/v1/exchangeInfo&#x60; * &#x60;STOP&#x60;, &#x60;STOP_MARKET&#x60;: * BUY: latest price
     * (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &gt;&#x3D; &#x60;stopPrice&#x60; *
     * SELL: latest price (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &lt;&#x3D;
     * &#x60;stopPrice&#x60; * &#x60;TAKE_PROFIT&#x60;, &#x60;TAKE_PROFIT_MARKET&#x60;: * BUY:
     * latest price (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &lt;&#x3D;
     * &#x60;stopPrice&#x60; * SELL: latest price (\&quot;MARK_PRICE\&quot; or
     * \&quot;CONTRACT_PRICE\&quot;) &gt;&#x3D; &#x60;stopPrice&#x60; Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void newCmConditionalOrderTest() throws ApiException, CryptoException {
        NewCmConditionalOrderRequest newCmConditionalOrderRequest =
                new NewCmConditionalOrderRequest();

        newCmConditionalOrderRequest.symbol("");
        newCmConditionalOrderRequest.side(Side.BUY);
        newCmConditionalOrderRequest.strategyType(StrategyType.STOP);

        ApiResponse<NewCmConditionalOrderResponse> response =
                api.newCmConditionalOrder(newCmConditionalOrderRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=&side=BUY&strategyType=STOP",
                signInputCaptor.getValue());
        assertEquals(
                "90ee840124872cb94e932dcfe904552453a2318cc73c56bc526955dba5cd9f9b",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/conditional/order", actualRequest.url().encodedPath());
    }

    /**
     * New CM Order(TRADE)
     *
     * <p>Place new CM order * If &#x60;newOrderRespType&#x60; is sent as &#x60;RESULT&#x60; : *
     * &#x60;MARKET&#x60; order: the final FILLED result of the order will be return directly. *
     * &#x60;LIMIT&#x60; order with special &#x60;timeInForce&#x60;: the final status result of the
     * order(FILLED or EXPIRED) will be returned directly. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void newCmOrderTest() throws ApiException, CryptoException {
        NewCmOrderRequest newCmOrderRequest = new NewCmOrderRequest();

        newCmOrderRequest.symbol("");
        newCmOrderRequest.side(Side.BUY);
        newCmOrderRequest.type(Type.LIMIT);

        ApiResponse<NewCmOrderResponse> response = api.newCmOrder(newCmOrderRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=&side=BUY&type=LIMIT", signInputCaptor.getValue());
        assertEquals(
                "b88c38300689d53932ba198ab2b30c30c872482dcaedbb4bede2f40535ba160a",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/order", actualRequest.url().encodedPath());
    }

    /**
     * New Margin Order(TRADE)
     *
     * <p>New Margin Order Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void newMarginOrderTest() throws ApiException, CryptoException {
        NewMarginOrderRequest newMarginOrderRequest = new NewMarginOrderRequest();

        newMarginOrderRequest.symbol("");
        newMarginOrderRequest.side(Side.BUY);
        newMarginOrderRequest.type(Type.LIMIT);

        ApiResponse<NewMarginOrderResponse> response = api.newMarginOrder(newMarginOrderRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=&side=BUY&type=LIMIT", signInputCaptor.getValue());
        assertEquals(
                "b88c38300689d53932ba198ab2b30c30c872482dcaedbb4bede2f40535ba160a",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/margin/order", actualRequest.url().encodedPath());
    }

    /**
     * New UM Conditional Order (TRADE)
     *
     * <p>Place new UM conditional order * Order with type &#x60;STOP/TAKE_PROFIT&#x60;, parameter
     * &#x60;timeInForce&#x60; can be sent ( default &#x60;GTC&#x60;). * Condition orders will be
     * triggered when: * &#x60;STOP&#x60;, &#x60;STOP_MARKET&#x60;: * BUY: \&quot;MARK_PRICE\&quot;
     * &gt;&#x3D; &#x60;stopPrice&#x60; * SELL: \&quot;MARK_PRICE\&quot; &lt;&#x3D;
     * &#x60;stopPrice&#x60; * &#x60;TAKE_PROFIT&#x60;, &#x60;TAKE_PROFIT_MARKET&#x60;: * BUY:
     * \&quot;MARK_PRICE\&quot; &lt;&#x3D; &#x60;stopPrice&#x60; * SELL: \&quot;MARK_PRICE\&quot;
     * &gt;&#x3D; &#x60;stopPrice&#x60; * &#x60;TRAILING_STOP_MARKET&#x60;: * BUY: the lowest mark
     * price after order placed &#x60;&lt;&#x3D; &#x60;activationPrice&#x60;, and the latest mark
     * price &gt;&#x60;&#x3D; the lowest mark price * (1 + &#x60;callbackRate&#x60;) * SELL: the
     * highest mark price after order placed &gt;&#x3D; &#x60;activationPrice&#x60;, and the latest
     * mark price &lt;&#x3D; the highest mark price * (1 - &#x60;callbackRate&#x60;) * For
     * &#x60;TRAILING_STOP_MARKET&#x60;, if you got such error code. &#x60;{\&quot;code\&quot;:
     * -2021, \&quot;msg\&quot;: \&quot;Order would immediately trigger.\&quot;}&#x60; means that
     * the parameters you send do not meet the following requirements: * BUY:
     * &#x60;activationPrice&#x60; should be smaller than latest mark price. * SELL:
     * &#x60;activationPrice&#x60; should be larger than latest mark price. * Condition orders will
     * be triggered when: * If parameter&#x60;priceProtect&#x60;is sent as true: * when price
     * reaches the &#x60;stopPrice&#x60; ï¼Œthe difference rate between \&quot;MARK_PRICE\&quot; and
     * \&quot;CONTRACT_PRICE\&quot; cannot be larger than the \&quot;triggerProtect\&quot; of the
     * symbol * \&quot;triggerProtect\&quot; of a symbol can be got from &#x60;GET
     * /fapi/v1/exchangeInfo&#x60; * &#x60;STOP&#x60;, &#x60;STOP_MARKET&#x60;: * BUY: latest price
     * (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &gt;&#x3D; &#x60;stopPrice&#x60; *
     * SELL: latest price (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &lt;&#x3D;
     * &#x60;stopPrice&#x60; * &#x60;TAKE_PROFIT&#x60;, &#x60;TAKE_PROFIT_MARKET&#x60;: * BUY:
     * latest price (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &lt;&#x3D;
     * &#x60;stopPrice&#x60; * SELL: latest price (\&quot;MARK_PRICE\&quot; or
     * \&quot;CONTRACT_PRICE\&quot;) &gt;&#x3D; &#x60;stopPrice&#x60; *
     * &#x60;selfTradePreventionMode&#x60; is only effective when &#x60;timeInForce&#x60; set to
     * &#x60;IOC&#x60; or &#x60;GTC&#x60; or &#x60;GTD&#x60;. * In extreme market conditions,
     * timeInForce &#x60;GTD&#x60; order auto cancel time might be delayed comparing to
     * &#x60;goodTillDate&#x60; Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void newUmConditionalOrderTest() throws ApiException, CryptoException {
        NewUmConditionalOrderRequest newUmConditionalOrderRequest =
                new NewUmConditionalOrderRequest();

        newUmConditionalOrderRequest.symbol("");
        newUmConditionalOrderRequest.side(Side.BUY);
        newUmConditionalOrderRequest.strategyType(StrategyType.STOP);

        ApiResponse<NewUmConditionalOrderResponse> response =
                api.newUmConditionalOrder(newUmConditionalOrderRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=&side=BUY&strategyType=STOP",
                signInputCaptor.getValue());
        assertEquals(
                "90ee840124872cb94e932dcfe904552453a2318cc73c56bc526955dba5cd9f9b",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/conditional/order", actualRequest.url().encodedPath());
    }

    /**
     * New UM Order (TRADE)
     *
     * <p>Place new UM order * If &#x60;newOrderRespType&#x60; is sent as &#x60;RESULT&#x60; : *
     * &#x60;MARKET&#x60; order: the final FILLED result of the order will be return directly. *
     * &#x60;LIMIT&#x60; order with special &#x60;timeInForce&#x60;: the final status result of the
     * order(FILLED or EXPIRED) will be returned directly. * &#x60;selfTradePreventionMode&#x60; is
     * only effective when &#x60;timeInForce&#x60; set to &#x60;IOC&#x60; or &#x60;GTC&#x60; or
     * &#x60;GTD&#x60;. * In extreme market conditions, timeInForce &#x60;GTD&#x60; order auto
     * cancel time might be delayed comparing to &#x60;goodTillDate&#x60; Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void newUmOrderTest() throws ApiException, CryptoException {
        NewUmOrderRequest newUmOrderRequest = new NewUmOrderRequest();

        newUmOrderRequest.symbol("");
        newUmOrderRequest.side(Side.BUY);
        newUmOrderRequest.type(Type.LIMIT);

        ApiResponse<NewUmOrderResponse> response = api.newUmOrder(newUmOrderRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=&side=BUY&type=LIMIT", signInputCaptor.getValue());
        assertEquals(
                "b88c38300689d53932ba198ab2b30c30c872482dcaedbb4bede2f40535ba160a",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/order", actualRequest.url().encodedPath());
    }

    /**
     * Query All CM Conditional Orders(USER_DATA)
     *
     * <p>Query All CM Conditional Orders * These orders will not be found: * order strategyStatus
     * is &#x60;CANCELED&#x60; or &#x60;EXPIRED&#x60;, **AND** * order has NO filled trade, **AND**
     * * created time + 7 days &lt; current time * The query time period must be less than 7 days(
     * default as the recent 7 days). Weight: 1 for a single symbol; 40 when the symbol parameter is
     * omitted
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryAllCmConditionalOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        Long strategyId = 1L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<QueryAllCmConditionalOrdersResponse> response =
                api.queryAllCmConditionalOrders(
                        symbol, strategyId, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&strategyId=1&startTime=1623319461670&endTime=1641782889000&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "8ff012ad54bf04a6af72d3d876922b09f79bdadf4b5517a042ad7370d9151113",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/conditional/allOrders", actualRequest.url().encodedPath());
    }

    /**
     * Query All CM Orders (USER_DATA)
     *
     * <p>Get all account CM orders; active, canceled, or filled. * Either &#x60;symbol&#x60; or
     * &#x60;pair&#x60; must be sent. * If &#x60;orderId&#x60; is set, it will get orders &gt;&#x3D;
     * that orderId. Otherwise most recent orders are returned. * These orders will not be found: *
     * order status is &#x60;CANCELED&#x60; or &#x60;EXPIRED&#x60;, **AND** * order has NO filled
     * trade, **AND** * created time + 3 days &lt; current time Weight: 20 with symbol, 40 with pair
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryAllCmOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        String pair = "";
        Long orderId = 1L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<QueryAllCmOrdersResponse> response =
                api.queryAllCmOrders(symbol, pair, orderId, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&pair=&orderId=1&startTime=1623319461670&endTime=1641782889000&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "9445a77882a6628612b980279cee60afc4cf7c4a1263b48ec49bf8021cdf5300",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/allOrders", actualRequest.url().encodedPath());
    }

    /**
     * Query All Current CM Open Conditional Orders (USER_DATA)
     *
     * <p>Get all open conditional orders on a symbol. **Careful** when accessing this with no
     * symbol. * If the symbol is not sent, orders for all symbols will be returned in an array.
     * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryAllCurrentCmOpenConditionalOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<QueryAllCurrentCmOpenConditionalOrdersResponse> response =
                api.queryAllCurrentCmOpenConditionalOrders(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/conditional/openOrders", actualRequest.url().encodedPath());
    }

    /**
     * Query All Current CM Open Orders(USER_DATA)
     *
     * <p>Get all open orders on a symbol. * If the symbol is not sent, orders for all symbols will
     * be returned in an array. Weight: 1 for a single symbol; 40 when the symbol parameter is
     * omitted Careful when accessing this with no symbol.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryAllCurrentCmOpenOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        String pair = "";
        Long recvWindow = 5000L;
        ApiResponse<QueryAllCurrentCmOpenOrdersResponse> response =
                api.queryAllCurrentCmOpenOrders(symbol, pair, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&pair=&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "11b129369c0f8682cf70f667a8b90c4c55856d335dceef536e582ac7a1be7481",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/openOrders", actualRequest.url().encodedPath());
    }

    /**
     * Query All Current UM Open Conditional Orders(USER_DATA)
     *
     * <p>Get all open conditional orders on a symbol. * If the symbol is not sent, orders for all
     * symbols will be returned in an array. Weight: 1 for a single symbol; 40 when the symbol
     * parameter is omitted Careful when accessing this with no symbol.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryAllCurrentUmOpenConditionalOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<QueryAllCurrentUmOpenConditionalOrdersResponse> response =
                api.queryAllCurrentUmOpenConditionalOrders(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/conditional/openOrders", actualRequest.url().encodedPath());
    }

    /**
     * Query All Current UM Open Orders(USER_DATA)
     *
     * <p>Get all open orders on a symbol. * If the symbol is not sent, orders for all symbols will
     * be returned in an array. Weight: 1 for a single symbol; 40 when the symbol parameter is
     * omitted
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryAllCurrentUmOpenOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<QueryAllCurrentUmOpenOrdersResponse> response =
                api.queryAllCurrentUmOpenOrders(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/openOrders", actualRequest.url().encodedPath());
    }

    /**
     * Query All Margin Account Orders (USER_DATA)
     *
     * <p>Query All Margin Account Orders Weight: 100
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryAllMarginAccountOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<QueryAllMarginAccountOrdersResponse> response =
                api.queryAllMarginAccountOrders(
                        symbol, orderId, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&orderId=1&startTime=1623319461670&endTime=1641782889000&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "dc0808314025fc813dcde0328cd6754c982d28888760fc74b17e072087eb4895",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/margin/allOrders", actualRequest.url().encodedPath());
    }

    /**
     * Query All UM Conditional Orders(USER_DATA)
     *
     * <p>Query All UM Conditional Orders * These orders will not be found: * order strategyStatus
     * is &#x60;CANCELED&#x60; or &#x60;EXPIRED&#x60;, **AND** * order has NO filled trade, **AND**
     * * created time + 7 days &lt; current time * The query time period must be less than 7 days(
     * default as the recent 7 days). Weight: 1 for a single symbol; 40 when the symbol parameter is
     * omitted
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryAllUmConditionalOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        Long strategyId = 1L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<QueryAllUmConditionalOrdersResponse> response =
                api.queryAllUmConditionalOrders(
                        symbol, strategyId, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&strategyId=1&startTime=1623319461670&endTime=1641782889000&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "8ff012ad54bf04a6af72d3d876922b09f79bdadf4b5517a042ad7370d9151113",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/conditional/allOrders", actualRequest.url().encodedPath());
    }

    /**
     * Query All UM Orders(USER_DATA)
     *
     * <p>Get all account UM orders; active, canceled, or filled. * These orders will not be found:
     * * order status is &#x60;CANCELED&#x60; or &#x60;EXPIRED&#x60;, **AND** * order has NO filled
     * trade, **AND** * created time + 3 days &lt; current time * If &#x60;orderId&#x60; is set, it
     * will get orders &gt;&#x3D; that orderId. Otherwise most recent orders are returned. * The
     * query time period must be less then 7 days( default as the recent 7 days). Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryAllUmOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<QueryAllUmOrdersResponse> response =
                api.queryAllUmOrders(symbol, orderId, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&orderId=1&startTime=1623319461670&endTime=1641782889000&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "dc0808314025fc813dcde0328cd6754c982d28888760fc74b17e072087eb4895",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/allOrders", actualRequest.url().encodedPath());
    }

    /**
     * Query CM Conditional Order History(USER_DATA)
     *
     * <p>Query CM Conditional Order History * Either &#x60;strategyId&#x60; or
     * &#x60;newClientStrategyId&#x60; must be sent. * &#x60;NEW&#x60; orders will not be found. *
     * These orders will not be found: * order status is &#x60;CANCELED&#x60; or
     * &#x60;EXPIRED&#x60;, **AND** * order has NO filled trade, **AND** * created time + 7 days
     * &lt; current time Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryCmConditionalOrderHistoryTest() throws ApiException, CryptoException {
        String symbol = "";
        Long strategyId = 1L;
        String newClientStrategyId = "1";
        Long recvWindow = 5000L;
        ApiResponse<QueryCmConditionalOrderHistoryResponse> response =
                api.queryCmConditionalOrderHistory(
                        symbol, strategyId, newClientStrategyId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&strategyId=1&newClientStrategyId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "a122adefbf5aadf438d7dc29aaf824c9960c880ff367781502c41a638ee6637f",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/conditional/orderHistory", actualRequest.url().encodedPath());
    }

    /**
     * Query CM Modify Order History(TRADE)
     *
     * <p>Get order modification history * Either &#x60;orderId&#x60; or
     * &#x60;origClientOrderId&#x60; must be sent, and the &#x60;orderId&#x60; will prevail if both
     * are sent. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryCmModifyOrderHistoryTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        String origClientOrderId = "1";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<QueryCmModifyOrderHistoryResponse> response =
                api.queryCmModifyOrderHistory(
                        symbol, orderId, origClientOrderId, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&orderId=1&origClientOrderId=1&startTime=1623319461670&endTime=1641782889000&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "8dfcc843fc05f631a3b12c4a0080f9d1f2283472ee0032b3e7e7fd46d855bcde",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/orderAmendment", actualRequest.url().encodedPath());
    }

    /**
     * Query CM Order(USER_DATA)
     *
     * <p>Check an CM order&#39;s status. * Either &#x60;orderId&#x60; or
     * &#x60;origClientOrderId&#x60; must be sent. * These orders will not be found: * order status
     * is &#x60;CANCELED&#x60; or &#x60;EXPIRED&#x60;, **AND** * order has NO filled trade, **AND**
     * * created time + 3 days &lt; current time Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryCmOrderTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        String origClientOrderId = "1";
        Long recvWindow = 5000L;
        ApiResponse<QueryCmOrderResponse> response =
                api.queryCmOrder(symbol, orderId, origClientOrderId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&orderId=1&origClientOrderId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "cbec82483be2ad044b893ffb2e6bc0d55370e378eaea0b4b61d95893bd9cc458",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/order", actualRequest.url().encodedPath());
    }

    /**
     * Query Current CM Open Conditional Order(USER_DATA)
     *
     * <p>Query Current CM Open Conditional Order * Either &#x60;strategyId&#x60; or
     * &#x60;newClientStrategyId&#x60; must be sent. * If the queried order has been triggered,
     * cancelled or expired, the error message \&quot;Order does not exist\&quot; will be returned.
     * Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryCurrentCmOpenConditionalOrderTest() throws ApiException, CryptoException {
        String symbol = "";
        Long strategyId = 1L;
        String newClientStrategyId = "1";
        Long recvWindow = 5000L;
        ApiResponse<QueryCurrentCmOpenConditionalOrderResponse> response =
                api.queryCurrentCmOpenConditionalOrder(
                        symbol, strategyId, newClientStrategyId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&strategyId=1&newClientStrategyId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "a122adefbf5aadf438d7dc29aaf824c9960c880ff367781502c41a638ee6637f",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/conditional/openOrder", actualRequest.url().encodedPath());
    }

    /**
     * Query Current CM Open Order (USER_DATA)
     *
     * <p>Query current CM open order * Either &#x60;orderId&#x60; or &#x60;origClientOrderId&#x60;
     * must be sent. * If the queried order has been filled or cancelled, the error message
     * \&quot;Order does not exist\&quot; will be returned. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryCurrentCmOpenOrderTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        String origClientOrderId = "1";
        Long recvWindow = 5000L;
        ApiResponse<QueryCurrentCmOpenOrderResponse> response =
                api.queryCurrentCmOpenOrder(symbol, orderId, origClientOrderId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&orderId=1&origClientOrderId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "cbec82483be2ad044b893ffb2e6bc0d55370e378eaea0b4b61d95893bd9cc458",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/openOrder", actualRequest.url().encodedPath());
    }

    /**
     * Query Current Margin Open Order (USER_DATA)
     *
     * <p>Query Current Margin Open Order Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryCurrentMarginOpenOrderTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<QueryCurrentMarginOpenOrderResponse> response =
                api.queryCurrentMarginOpenOrder(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/margin/openOrders", actualRequest.url().encodedPath());
    }

    /**
     * Query Current UM Open Conditional Order(USER_DATA)
     *
     * <p>Query Current UM Open Conditional Order * Either &#x60;strategyId&#x60; or
     * &#x60;newClientStrategyId&#x60; must be sent. * If the queried order has been
     * &#x60;CANCELED&#x60;, &#x60;TRIGGERED&#x60;æˆ–&#x60;EXPIRED&#x60;, the error message
     * \&quot;Order does not exist\&quot; will be returned. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryCurrentUmOpenConditionalOrderTest() throws ApiException, CryptoException {
        String symbol = "";
        Long strategyId = 1L;
        String newClientStrategyId = "1";
        Long recvWindow = 5000L;
        ApiResponse<QueryCurrentUmOpenConditionalOrderResponse> response =
                api.queryCurrentUmOpenConditionalOrder(
                        symbol, strategyId, newClientStrategyId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&strategyId=1&newClientStrategyId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "a122adefbf5aadf438d7dc29aaf824c9960c880ff367781502c41a638ee6637f",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/conditional/openOrder", actualRequest.url().encodedPath());
    }

    /**
     * Query Current UM Open Order(USER_DATA)
     *
     * <p>Query current UM open order * Either &#x60;orderId&#x60; or &#x60;origClientOrderId&#x60;
     * must be sent. * If the queried order has been filled or cancelled, the error message
     * \&quot;Order does not exist\&quot; will be returned. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryCurrentUmOpenOrderTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        String origClientOrderId = "1";
        Long recvWindow = 5000L;
        ApiResponse<QueryCurrentUmOpenOrderResponse> response =
                api.queryCurrentUmOpenOrder(symbol, orderId, origClientOrderId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&orderId=1&origClientOrderId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "cbec82483be2ad044b893ffb2e6bc0d55370e378eaea0b4b61d95893bd9cc458",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/openOrder", actualRequest.url().encodedPath());
    }

    /**
     * Query Margin Account Order (USER_DATA)
     *
     * <p>Query Margin Account Order Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryMarginAccountOrderTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        String origClientOrderId = "1";
        Long recvWindow = 5000L;
        ApiResponse<QueryMarginAccountOrderResponse> response =
                api.queryMarginAccountOrder(symbol, orderId, origClientOrderId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&orderId=1&origClientOrderId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "cbec82483be2ad044b893ffb2e6bc0d55370e378eaea0b4b61d95893bd9cc458",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/margin/order", actualRequest.url().encodedPath());
    }

    /**
     * Query Margin Account&#39;s all OCO (USER_DATA)
     *
     * <p>Query all OCO for a specific margin account based on provided optional parameters Weight:
     * 100
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryMarginAccountsAllOcoTest() throws ApiException, CryptoException {
        Long fromId = 1L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<QueryMarginAccountsAllOcoResponse> response =
                api.queryMarginAccountsAllOco(fromId, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "fromId=1&startTime=1623319461670&endTime=1641782889000&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "61b488868ac713a73a80bc2a2702ed4b195aeb136137d09a8678e33a99f2d71d",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/margin/allOrderList", actualRequest.url().encodedPath());
    }

    /**
     * Query Margin Account&#39;s OCO (USER_DATA)
     *
     * <p>Retrieves a specific OCO based on provided optional parameters Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryMarginAccountsOcoTest() throws ApiException, CryptoException {
        Long orderListId = 1L;
        String origClientOrderId = "1";
        Long recvWindow = 5000L;
        ApiResponse<QueryMarginAccountsOcoResponse> response =
                api.queryMarginAccountsOco(orderListId, origClientOrderId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "orderListId=1&origClientOrderId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "7f372679c9ee620eee8ee577b66daacf79e10664aa713f1cde699495c3cec0a5",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/margin/orderList", actualRequest.url().encodedPath());
    }

    /**
     * Query Margin Account&#39;s Open OCO (USER_DATA)
     *
     * <p>Query Margin Account&#39;s Open OCO Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryMarginAccountsOpenOcoTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<QueryMarginAccountsOpenOcoResponse> response =
                api.queryMarginAccountsOpenOco(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/margin/openOrderList", actualRequest.url().encodedPath());
    }

    /**
     * Query UM Conditional Order History(USER_DATA)
     *
     * <p>Query UM Conditional Order History * Either &#x60;strategyId&#x60; or
     * &#x60;newClientStrategyId&#x60; must be sent. * &#x60;NEW&#x60; orders will not be found. *
     * These orders will not be found: * order status is &#x60;CANCELED&#x60; or
     * &#x60;EXPIRED&#x60;, **AND** * order has NO filled trade, **AND** * created time + 7 days
     * &lt; current time Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryUmConditionalOrderHistoryTest() throws ApiException, CryptoException {
        String symbol = "";
        Long strategyId = 1L;
        String newClientStrategyId = "1";
        Long recvWindow = 5000L;
        ApiResponse<QueryUmConditionalOrderHistoryResponse> response =
                api.queryUmConditionalOrderHistory(
                        symbol, strategyId, newClientStrategyId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&strategyId=1&newClientStrategyId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "a122adefbf5aadf438d7dc29aaf824c9960c880ff367781502c41a638ee6637f",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/conditional/orderHistory", actualRequest.url().encodedPath());
    }

    /**
     * Query UM Modify Order History(TRADE)
     *
     * <p>Get order modification history * Either &#x60;orderId&#x60; or
     * &#x60;origClientOrderId&#x60; must be sent, and the &#x60;orderId&#x60; will prevail if both
     * are sent. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryUmModifyOrderHistoryTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        String origClientOrderId = "1";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<QueryUmModifyOrderHistoryResponse> response =
                api.queryUmModifyOrderHistory(
                        symbol, orderId, origClientOrderId, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&orderId=1&origClientOrderId=1&startTime=1623319461670&endTime=1641782889000&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "8dfcc843fc05f631a3b12c4a0080f9d1f2283472ee0032b3e7e7fd46d855bcde",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/orderAmendment", actualRequest.url().encodedPath());
    }

    /**
     * Query UM Order (USER_DATA)
     *
     * <p>Check an UM order&#39;s status. * These orders will not be found: * Either
     * &#x60;orderId&#x60; or &#x60;origClientOrderId&#x60; must be sent. * order status is
     * &#x60;CANCELED&#x60; or &#x60;EXPIRED&#x60;, **AND** * order has NO filled trade, **AND** *
     * created time + 3 days &lt; current time Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryUmOrderTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        String origClientOrderId = "1";
        Long recvWindow = 5000L;
        ApiResponse<QueryUmOrderResponse> response =
                api.queryUmOrder(symbol, orderId, origClientOrderId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&orderId=1&origClientOrderId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "cbec82483be2ad044b893ffb2e6bc0d55370e378eaea0b4b61d95893bd9cc458",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/order", actualRequest.url().encodedPath());
    }

    /**
     * Query User&#39;s CM Force Orders(USER_DATA)
     *
     * <p>Query User&#39;s CM Force Orders * If \&quot;autoCloseType\&quot; is not sent, orders with
     * both of the types will be returned * If \&quot;startTime\&quot; is not sent, data within 7
     * days before \&quot;endTime\&quot; can be queried Weight: 20 with symbol, 50 without symbol
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryUsersCmForceOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        AutoCloseType autoCloseType = AutoCloseType.LIQUIDATION;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<QueryUsersCmForceOrdersResponse> response =
                api.queryUsersCmForceOrders(
                        symbol, autoCloseType, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&autoCloseType=LIQUIDATION&startTime=1623319461670&endTime=1641782889000&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "a8fbc61c925506a4d0328c80dbe4bd786245accbfc50aef2a14a769d18bde9d9",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/forceOrders", actualRequest.url().encodedPath());
    }

    /**
     * Query User&#39;s Margin Force Orders(USER_DATA)
     *
     * <p>Query user&#39;s margin force orders Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryUsersMarginForceOrdersTest() throws ApiException, CryptoException {
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long current = 1L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<QueryUsersMarginForceOrdersResponse> response =
                api.queryUsersMarginForceOrders(startTime, endTime, current, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "startTime=1623319461670&endTime=1641782889000&current=1&size=10&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "2ecc0415a3bdb2963e8030cdf6cf00de6f49d21b71ff939dda42e5756eb8ba66",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/margin/forceOrders", actualRequest.url().encodedPath());
    }

    /**
     * Query User&#39;s UM Force Orders (USER_DATA)
     *
     * <p>Query User&#39;s UM Force Orders * If &#x60;autoCloseType&#x60; is not sent, orders with
     * both of the types will be returned * If &#x60;startTime&#x60; is not sent, data within 7 days
     * before &#x60;endTime&#x60; can be queried Weight: 20 with symbol, 50 without symbol
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryUsersUmForceOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        AutoCloseType autoCloseType = AutoCloseType.LIQUIDATION;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<QueryUsersUmForceOrdersResponse> response =
                api.queryUsersUmForceOrders(
                        symbol, autoCloseType, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&autoCloseType=LIQUIDATION&startTime=1623319461670&endTime=1641782889000&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "a8fbc61c925506a4d0328c80dbe4bd786245accbfc50aef2a14a769d18bde9d9",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/forceOrders", actualRequest.url().encodedPath());
    }

    /**
     * Toggle BNB Burn On UM Futures Trade (TRADE)
     *
     * <p>Change user&#39;s BNB Fee Discount for UM Futures (Fee Discount On or Fee Discount Off )
     * on ***EVERY symbol*** * The BNB would not be collected from UM-PM account to the Portfolio
     * Margin account. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void toggleBnbBurnOnUmFuturesTradeTest() throws ApiException, CryptoException {
        ToggleBnbBurnOnUmFuturesTradeRequest toggleBnbBurnOnUmFuturesTradeRequest =
                new ToggleBnbBurnOnUmFuturesTradeRequest();

        toggleBnbBurnOnUmFuturesTradeRequest.feeBurn("");

        ApiResponse<ToggleBnbBurnOnUmFuturesTradeResponse> response =
                api.toggleBnbBurnOnUmFuturesTrade(toggleBnbBurnOnUmFuturesTradeRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000feeBurn=", signInputCaptor.getValue());
        assertEquals(
                "b5185b9009ad5a0346daec6e86f58d6828c88fcc961b7eef5514f9bc0680560d",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/feeBurn", actualRequest.url().encodedPath());
    }

    /**
     * UM Account Trade List(USER_DATA)
     *
     * <p>Get trades for a specific account and UM symbol. * If &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; are both not sent, then the last &#39;24 hours&#39; data will be
     * returned. * The time between &#x60;startTime&#x60; and &#x60;endTime&#x60; cannot be longer
     * than 24 hours. * The parameter &#x60;fromId&#x60; cannot be sent with &#x60;startTime&#x60;
     * or &#x60;endTime&#x60;. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void umAccountTradeListTest() throws ApiException, CryptoException {
        String symbol = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long fromId = 1L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<UmAccountTradeListResponse> response =
                api.umAccountTradeList(symbol, startTime, endTime, fromId, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&startTime=1623319461670&endTime=1641782889000&fromId=1&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "4c4bae763e30633fc02c53d17c6ffbcf320a1e7056aad6d7bfc1545d015bab9b",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/userTrades", actualRequest.url().encodedPath());
    }

    /**
     * UM Position ADL Quantile Estimation(USER_DATA)
     *
     * <p>Query UM Position ADL Quantile Estimation * Values update every 30s. * Values 0, 1, 2, 3,
     * 4 shows the queue position and possibility of ADL from low to high. * For positions of the
     * symbol are in One-way Mode or isolated margined in Hedge Mode, \&quot;LONG\&quot;,
     * \&quot;SHORT\&quot;, and \&quot;BOTH\&quot; will be returned to show the positions&#39; adl
     * quantiles of different position sides. * If the positions of the symbol are crossed margined
     * in Hedge Mode: * \&quot;HEDGE\&quot; as a sign will be returned instead of
     * \&quot;BOTH\&quot;; * A same value caculated on unrealized pnls on long and short sides&#39;
     * positions will be shown for \&quot;LONG\&quot; and \&quot;SHORT\&quot; when there are
     * positions in both of long and short sides. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void umPositionAdlQuantileEstimationTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<UmPositionAdlQuantileEstimationResponse> response =
                api.umPositionAdlQuantileEstimation(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/adlQuantile", actualRequest.url().encodedPath());
    }
}
