/*
 * Binance Derivatives Trading Portfolio Margin REST API
 * OpenAPI Specification for the Binance Derivatives Trading Portfolio Margin REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_portfolio_margin.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.AccountBalanceResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.AccountInformationResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.BnbTransferRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.BnbTransferResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.ChangeAutoRepayFuturesStatusRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.ChangeAutoRepayFuturesStatusResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.ChangeCmInitialLeverageRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.ChangeCmInitialLeverageResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.ChangeCmPositionModeRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.ChangeCmPositionModeResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.ChangeUmInitialLeverageRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.ChangeUmInitialLeverageResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.ChangeUmPositionModeRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.ChangeUmPositionModeResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.CmNotionalAndLeverageBracketsResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.FundAutoCollectionRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.FundAutoCollectionResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.FundCollectionByAssetRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.FundCollectionByAssetResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.GetAutoRepayFuturesStatusResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.GetCmAccountDetailResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.GetCmCurrentPositionModeResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.GetCmIncomeHistoryResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.GetDownloadIdForUmFuturesOrderHistoryResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.GetDownloadIdForUmFuturesTradeHistoryResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.GetDownloadIdForUmFuturesTransactionHistoryResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.GetMarginBorrowLoanInterestHistoryResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.GetUmAccountDetailResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.GetUmAccountDetailV2Response;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.GetUmCurrentPositionModeResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.GetUmFuturesOrderDownloadLinkByIdResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.GetUmFuturesTradeDownloadLinkByIdResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.GetUmFuturesTransactionDownloadLinkByIdResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.GetUmIncomeHistoryResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.GetUserCommissionRateForCmResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.GetUserCommissionRateForUmResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.MarginMaxBorrowResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.PortfolioMarginUmTradingQuantitativeRulesIndicatorsResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryCmPositionInformationResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryMarginLoanRecordResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryMarginMaxWithdrawResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryMarginRepayRecordResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryPortfolioMarginNegativeBalanceInterestHistoryResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryUmPositionInformationResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryUserNegativeBalanceAutoExchangeRecordResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.QueryUserRateLimitResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.RepayFuturesNegativeBalanceRequest;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.RepayFuturesNegativeBalanceResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.UmFuturesAccountConfigurationResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.UmFuturesSymbolConfigurationResponse;
import com.binance.connector.client.derivatives_trading_portfolio_margin.rest.model.UmNotionalAndLeverageBracketsResponse;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for AccountApi */
public class AccountApiTest {

    private AccountApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new AccountApi(apiClientSpy);
    }

    /**
     * Account Balance(USER_DATA)
     *
     * <p>Query account balance Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void accountBalanceTest() throws ApiException, CryptoException {
        String asset = "";
        Long recvWindow = 5000L;
        ApiResponse<AccountBalanceResponse> response = api.accountBalance(asset, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("asset=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "a8610b861691761550acea81c71e6fe676ac39bd2020c66ff1115710eaf265a4",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/balance", actualRequest.url().encodedPath());
    }

    /**
     * Account Information(USER_DATA)
     *
     * <p>Query account information Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void accountInformationTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<AccountInformationResponse> response = api.accountInformation(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/account", actualRequest.url().encodedPath());
    }

    /**
     * BNB transfer (TRADE)
     *
     * <p>Transfer BNB in and out of UM * The endpoint can only be called 10 times per 10 minutes in
     * a rolling manner Weight: 750
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void bnbTransferTest() throws ApiException, CryptoException {
        BnbTransferRequest bnbTransferRequest = new BnbTransferRequest();

        bnbTransferRequest.amount(1d);
        bnbTransferRequest.transferSide("");

        ApiResponse<BnbTransferResponse> response = api.bnbTransfer(bnbTransferRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000amount=1&transferSide=", signInputCaptor.getValue());
        assertEquals(
                "e16833932c5efb8dd0192481215116c9f1d39b4d46a89360c91c516dfc2487c5",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/bnb-transfer", actualRequest.url().encodedPath());
    }

    /**
     * Change Auto-repay-futures Status(TRADE)
     *
     * <p>Change Auto-repay-futures Status Weight: 750
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void changeAutoRepayFuturesStatusTest() throws ApiException, CryptoException {
        ChangeAutoRepayFuturesStatusRequest changeAutoRepayFuturesStatusRequest =
                new ChangeAutoRepayFuturesStatusRequest();

        changeAutoRepayFuturesStatusRequest.autoRepay("");

        ApiResponse<ChangeAutoRepayFuturesStatusResponse> response =
                api.changeAutoRepayFuturesStatus(changeAutoRepayFuturesStatusRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000autoRepay=", signInputCaptor.getValue());
        assertEquals(
                "89b69711fce80ffb1748b7a96c12374faa2b2afeb21a900f9a8ca0163615964e",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/repay-futures-switch", actualRequest.url().encodedPath());
    }

    /**
     * Change CM Initial Leverage (TRADE)
     *
     * <p>Change user&#39;s initial leverage of specific symbol in CM. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void changeCmInitialLeverageTest() throws ApiException, CryptoException {
        ChangeCmInitialLeverageRequest changeCmInitialLeverageRequest =
                new ChangeCmInitialLeverageRequest();

        changeCmInitialLeverageRequest.symbol("");
        changeCmInitialLeverageRequest.leverage(0L);

        ApiResponse<ChangeCmInitialLeverageResponse> response =
                api.changeCmInitialLeverage(changeCmInitialLeverageRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000symbol=&leverage=0", signInputCaptor.getValue());
        assertEquals(
                "31c40eeb1a5a52384cff8a195c1c312e32b26a672ad8fb71dc96256a61c4101c",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/leverage", actualRequest.url().encodedPath());
    }

    /**
     * Change CM Position Mode(TRADE)
     *
     * <p>Change user&#39;s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM
     * Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void changeCmPositionModeTest() throws ApiException, CryptoException {
        ChangeCmPositionModeRequest changeCmPositionModeRequest = new ChangeCmPositionModeRequest();

        changeCmPositionModeRequest.dualSidePosition("");

        ApiResponse<ChangeCmPositionModeResponse> response =
                api.changeCmPositionMode(changeCmPositionModeRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000dualSidePosition=", signInputCaptor.getValue());
        assertEquals(
                "234d62c8a0356474ae6889f6aee70005b8ded595c0d02364bc91a55e250c6017",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/positionSide/dual", actualRequest.url().encodedPath());
    }

    /**
     * Change UM Initial Leverage(TRADE)
     *
     * <p>Change user&#39;s initial leverage of specific symbol in UM. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void changeUmInitialLeverageTest() throws ApiException, CryptoException {
        ChangeUmInitialLeverageRequest changeUmInitialLeverageRequest =
                new ChangeUmInitialLeverageRequest();

        changeUmInitialLeverageRequest.symbol("");
        changeUmInitialLeverageRequest.leverage(0L);

        ApiResponse<ChangeUmInitialLeverageResponse> response =
                api.changeUmInitialLeverage(changeUmInitialLeverageRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000symbol=&leverage=0", signInputCaptor.getValue());
        assertEquals(
                "31c40eeb1a5a52384cff8a195c1c312e32b26a672ad8fb71dc96256a61c4101c",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/leverage", actualRequest.url().encodedPath());
    }

    /**
     * Change UM Position Mode(TRADE)
     *
     * <p>Change user&#39;s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM
     * Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void changeUmPositionModeTest() throws ApiException, CryptoException {
        ChangeUmPositionModeRequest changeUmPositionModeRequest = new ChangeUmPositionModeRequest();

        changeUmPositionModeRequest.dualSidePosition("");

        ApiResponse<ChangeUmPositionModeResponse> response =
                api.changeUmPositionMode(changeUmPositionModeRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000dualSidePosition=", signInputCaptor.getValue());
        assertEquals(
                "234d62c8a0356474ae6889f6aee70005b8ded595c0d02364bc91a55e250c6017",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/positionSide/dual", actualRequest.url().encodedPath());
    }

    /**
     * CM Notional and Leverage Brackets(USER_DATA)
     *
     * <p>Query CM notional and leverage brackets Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cmNotionalAndLeverageBracketsTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<CmNotionalAndLeverageBracketsResponse> response =
                api.cmNotionalAndLeverageBrackets(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/leverageBracket", actualRequest.url().encodedPath());
    }

    /**
     * Fund Auto-collection(TRADE)
     *
     * <p>Fund collection for Portfolio Margin * The BNB would not be collected from UM-PM account
     * to the Portfolio Margin account. * You can only use this function 500 times per hour in a
     * rolling manner. Weight: 750
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void fundAutoCollectionTest() throws ApiException, CryptoException {
        FundAutoCollectionRequest fundAutoCollectionRequest = new FundAutoCollectionRequest();

        ApiResponse<FundAutoCollectionResponse> response =
                api.fundAutoCollection(fundAutoCollectionRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "53668e00dc92eb93de0b253c301e9fc0c20042b13db384a0ad94b38688a5a84c",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/auto-collection", actualRequest.url().encodedPath());
    }

    /**
     * Fund Collection by Asset(TRADE)
     *
     * <p>Transfers specific asset from Futures Account to Margin account * The BNB transfer is not
     * be supported Weight: 30
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void fundCollectionByAssetTest() throws ApiException, CryptoException {
        FundCollectionByAssetRequest fundCollectionByAssetRequest =
                new FundCollectionByAssetRequest();

        fundCollectionByAssetRequest.asset("");

        ApiResponse<FundCollectionByAssetResponse> response =
                api.fundCollectionByAsset(fundCollectionByAssetRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000asset=", signInputCaptor.getValue());
        assertEquals(
                "733c2733b75fbea096af9abd7a6e22ac4cce318248e66e514087362c82db2bf1",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/asset-collection", actualRequest.url().encodedPath());
    }

    /**
     * Get Auto-repay-futures Status(USER_DATA)
     *
     * <p>Query Auto-repay-futures Status Weight: 30
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAutoRepayFuturesStatusTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<GetAutoRepayFuturesStatusResponse> response =
                api.getAutoRepayFuturesStatus(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/repay-futures-switch", actualRequest.url().encodedPath());
    }

    /**
     * Get CM Account Detail(USER_DATA)
     *
     * <p>Get current CM account asset and position information. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getCmAccountDetailTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<GetCmAccountDetailResponse> response = api.getCmAccountDetail(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/account", actualRequest.url().encodedPath());
    }

    /**
     * Get CM Current Position Mode(USER_DATA)
     *
     * <p>Get user&#39;s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in CM Weight:
     * 30
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getCmCurrentPositionModeTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<GetCmCurrentPositionModeResponse> response =
                api.getCmCurrentPositionMode(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/positionSide/dual", actualRequest.url().encodedPath());
    }

    /**
     * Get CM Income History(USER_DATA)
     *
     * <p>Get CM Income History * If &#x60;incomeType&#x60; is not sent, all kinds of flow will be
     * returned * \&quot;trandId\&quot; is unique in the same \&quot;incomeType\&quot; for a user *
     * The interval between &#x60;startTime&#x60; and &#x60;endTime&#x60; can not exceed 200 days: *
     * If &#x60;startTime&#x60; and &#x60;endTime&#x60; are not sent, the last 200 days will be
     * returned Weight: 30
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getCmIncomeHistoryTest() throws ApiException, CryptoException {
        String symbol = "";
        String incomeType = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long page = 0L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<GetCmIncomeHistoryResponse> response =
                api.getCmIncomeHistory(
                        symbol, incomeType, startTime, endTime, page, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&incomeType=&startTime=1623319461670&endTime=1641782889000&page=0&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "05f9946fedf735df42817e55ffdc78ca315f60a95c723d2f957b7ce76546ef2e",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/income", actualRequest.url().encodedPath());
    }

    /**
     * Get Download Id For UM Futures Order History (USER_DATA)
     *
     * <p>Get download id for UM futures order history * Request Limitation is 10 times per month,
     * shared by front end download page and rest api * The time between &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; can not be longer than 1 year Weight: 1500
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getDownloadIdForUmFuturesOrderHistoryTest() throws ApiException, CryptoException {
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long recvWindow = 5000L;
        ApiResponse<GetDownloadIdForUmFuturesOrderHistoryResponse> response =
                api.getDownloadIdForUmFuturesOrderHistory(startTime, endTime, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "startTime=1623319461670&endTime=1641782889000&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "812caedbe8f349196a4532c2050ff706ed2569fed185039c7b60a78cd84bc718",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/order/asyn", actualRequest.url().encodedPath());
    }

    /**
     * Get Download Id For UM Futures Trade History (USER_DATA)
     *
     * <p>Get download id for UM futures trade history * Request Limitation is 5 times per month,
     * shared by front end download page and rest api * The time between &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; can not be longer than 1 year Weight: 1500
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getDownloadIdForUmFuturesTradeHistoryTest() throws ApiException, CryptoException {
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long recvWindow = 5000L;
        ApiResponse<GetDownloadIdForUmFuturesTradeHistoryResponse> response =
                api.getDownloadIdForUmFuturesTradeHistory(startTime, endTime, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "startTime=1623319461670&endTime=1641782889000&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "812caedbe8f349196a4532c2050ff706ed2569fed185039c7b60a78cd84bc718",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/trade/asyn", actualRequest.url().encodedPath());
    }

    /**
     * Get Download Id For UM Futures Transaction History (USER_DATA)
     *
     * <p>Get download id for UM futures transaction history * Request Limitation is 5 times per
     * month, shared by front end download page and rest api * The time between
     * &#x60;startTime&#x60; and &#x60;endTime&#x60; can not be longer than 1 year Weight: 1500
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getDownloadIdForUmFuturesTransactionHistoryTest()
            throws ApiException, CryptoException {
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long recvWindow = 5000L;
        ApiResponse<GetDownloadIdForUmFuturesTransactionHistoryResponse> response =
                api.getDownloadIdForUmFuturesTransactionHistory(startTime, endTime, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "startTime=1623319461670&endTime=1641782889000&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "812caedbe8f349196a4532c2050ff706ed2569fed185039c7b60a78cd84bc718",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/income/asyn", actualRequest.url().encodedPath());
    }

    /**
     * Get Margin Borrow/Loan Interest History(USER_DATA)
     *
     * <p>Get Margin Borrow/Loan Interest History * Response in descending order * The max interval
     * between startTime and endTime is 30 days. It is a MUST to ensure data correctness. * If
     * &#x60;startTime&#x60; and &#x60;endTime&#x60; not sent, return records of the last 7 days by
     * default * If &#x60;startTime&#x60; is sent and &#x60;endTime&#x60; is not sent, the records
     * from &#x60;startTime&#x60; to the present will be returned; if &#x60;startTime&#x60; is more
     * than 30 days ago, the records of the past 30 days will be returned. * If
     * &#x60;startTime&#x60; is not sent and &#x60;endTime&#x60; is sent, the records of the 7 days
     * before &#x60;endTime&#x60; is returned. * Type in response has 5 enums: *
     * &#x60;PERIODIC&#x60; interest charged per hour * &#x60;ON_BORROW&#x60; first interest charged
     * on borrow * &#x60;PERIODIC_CONVERTED&#x60; interest charged per hour converted into BNB *
     * &#x60;ON_BORROW_CONVERTED&#x60; first interest charged on borrow converted into BNB *
     * &#x60;PORTFOLIO&#x60; Portfolio Margin negative balance daily interest Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getMarginBorrowLoanInterestHistoryTest() throws ApiException, CryptoException {
        String asset = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long current = 1L;
        Long size = 10L;
        String archived = "";
        Long recvWindow = 5000L;
        ApiResponse<GetMarginBorrowLoanInterestHistoryResponse> response =
                api.getMarginBorrowLoanInterestHistory(
                        asset, startTime, endTime, current, size, archived, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "asset=&startTime=1623319461670&endTime=1641782889000&current=1&size=10&archived=&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "cb5c81e7f3db5f0931fdd5cd3b8289f0c9dd4f3094e785c83ee401b0621646f1",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/margin/marginInterestHistory", actualRequest.url().encodedPath());
    }

    /**
     * Get UM Account Detail(USER_DATA)
     *
     * <p>Get current UM account asset and position information. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getUmAccountDetailTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<GetUmAccountDetailResponse> response = api.getUmAccountDetail(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/account", actualRequest.url().encodedPath());
    }

    /**
     * Get UM Account Detail V2(USER_DATA)
     *
     * <p>Get current UM account asset and position information. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getUmAccountDetailV2Test() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<GetUmAccountDetailV2Response> response = api.getUmAccountDetailV2(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v2/um/account", actualRequest.url().encodedPath());
    }

    /**
     * Get UM Current Position Mode(USER_DATA)
     *
     * <p>Get user&#39;s position mode (Hedge Mode or One-way Mode ) on EVERY symbol in UM Weight:
     * 30
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getUmCurrentPositionModeTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<GetUmCurrentPositionModeResponse> response =
                api.getUmCurrentPositionMode(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/positionSide/dual", actualRequest.url().encodedPath());
    }

    /**
     * Get UM Futures Order Download Link by Id(USER_DATA)
     *
     * <p>Get UM futures order download link by Id * Download link expiration: 24h Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getUmFuturesOrderDownloadLinkByIdTest() throws ApiException, CryptoException {
        String downloadId = "1";
        Long recvWindow = 5000L;
        ApiResponse<GetUmFuturesOrderDownloadLinkByIdResponse> response =
                api.getUmFuturesOrderDownloadLinkById(downloadId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "downloadId=1&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "4947fe463a17e3ec0b50fc22b21afc2aafddf3da892fa0c8dfd1b9c50af87349",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/order/asyn/id", actualRequest.url().encodedPath());
    }

    /**
     * Get UM Futures Trade Download Link by Id(USER_DATA)
     *
     * <p>Get UM futures trade download link by Id * Download link expiration: 24h Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getUmFuturesTradeDownloadLinkByIdTest() throws ApiException, CryptoException {
        String downloadId = "1";
        Long recvWindow = 5000L;
        ApiResponse<GetUmFuturesTradeDownloadLinkByIdResponse> response =
                api.getUmFuturesTradeDownloadLinkById(downloadId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "downloadId=1&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "4947fe463a17e3ec0b50fc22b21afc2aafddf3da892fa0c8dfd1b9c50af87349",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/trade/asyn/id", actualRequest.url().encodedPath());
    }

    /**
     * Get UM Futures Transaction Download Link by Id(USER_DATA)
     *
     * <p>Get UM futures Transaction download link by Id * Download link expiration: 24h Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getUmFuturesTransactionDownloadLinkByIdTest() throws ApiException, CryptoException {
        String downloadId = "1";
        Long recvWindow = 5000L;
        ApiResponse<GetUmFuturesTransactionDownloadLinkByIdResponse> response =
                api.getUmFuturesTransactionDownloadLinkById(downloadId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "downloadId=1&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "4947fe463a17e3ec0b50fc22b21afc2aafddf3da892fa0c8dfd1b9c50af87349",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/income/asyn/id", actualRequest.url().encodedPath());
    }

    /**
     * Get UM Income History(USER_DATA)
     *
     * <p>Get UM Income History * If neither &#x60;startTime&#x60; nor &#x60;endTime&#x60; is sent,
     * the recent 7-day data will be returned. * If &#x60;incomeType&#x60; is not sent, all kinds of
     * flow will be returned * \&quot;trandId\&quot; is unique in the same incomeType for a user *
     * Income history only contains data for the last three months Weight: 30
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getUmIncomeHistoryTest() throws ApiException, CryptoException {
        String symbol = "";
        String incomeType = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long page = 0L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<GetUmIncomeHistoryResponse> response =
                api.getUmIncomeHistory(
                        symbol, incomeType, startTime, endTime, page, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&incomeType=&startTime=1623319461670&endTime=1641782889000&page=0&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "05f9946fedf735df42817e55ffdc78ca315f60a95c723d2f957b7ce76546ef2e",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/income", actualRequest.url().encodedPath());
    }

    /**
     * Get User Commission Rate for CM(USER_DATA)
     *
     * <p>Get User Commission Rate for CM Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getUserCommissionRateForCmTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<GetUserCommissionRateForCmResponse> response =
                api.getUserCommissionRateForCm(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/commissionRate", actualRequest.url().encodedPath());
    }

    /**
     * Get User Commission Rate for UM(USER_DATA)
     *
     * <p>Get User Commission Rate for UM Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getUserCommissionRateForUmTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<GetUserCommissionRateForUmResponse> response =
                api.getUserCommissionRateForUm(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/commissionRate", actualRequest.url().encodedPath());
    }

    /**
     * Margin Max Borrow(USER_DATA)
     *
     * <p>Query margin max borrow Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void marginMaxBorrowTest() throws ApiException, CryptoException {
        String asset = "";
        Long recvWindow = 5000L;
        ApiResponse<MarginMaxBorrowResponse> response = api.marginMaxBorrow(asset, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("asset=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "a8610b861691761550acea81c71e6fe676ac39bd2020c66ff1115710eaf265a4",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/margin/maxBorrowable", actualRequest.url().encodedPath());
    }

    /**
     * Portfolio Margin UM Trading Quantitative Rules Indicators(USER_DATA)
     *
     * <p>Portfolio Margin UM Trading Quantitative Rules Indicators Weight: 1 for a single symbol 10
     * when the symbol parameter is omitted
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void portfolioMarginUmTradingQuantitativeRulesIndicatorsTest()
            throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<PortfolioMarginUmTradingQuantitativeRulesIndicatorsResponse> response =
                api.portfolioMarginUmTradingQuantitativeRulesIndicators(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/apiTradingStatus", actualRequest.url().encodedPath());
    }

    /**
     * Query CM Position Information(USER_DATA)
     *
     * <p>Get current CM position information. * If neither &#x60;marginAsset&#x60; nor
     * &#x60;pair&#x60; is sent, positions of all symbols with &#x60;TRADING&#x60; status will be
     * returned. * for One-way Mode user, the response will only show the \&quot;BOTH\&quot;
     * positions * for Hedge Mode user, the response will show \&quot;LONG\&quot;, and
     * \&quot;SHORT\&quot; positions. * Please use with user data stream &#x60;ACCOUNT_UPDATE&#x60;
     * to meet your timeliness and accuracy needs. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryCmPositionInformationTest() throws ApiException, CryptoException {
        String marginAsset = "";
        String pair = "";
        Long recvWindow = 5000L;
        ApiResponse<QueryCmPositionInformationResponse> response =
                api.queryCmPositionInformation(marginAsset, pair, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "marginAsset=&pair=&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "7c340d46d6a73bb7697e05d5340862028b59650df2e5526d761180495c98e012",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/cm/positionRisk", actualRequest.url().encodedPath());
    }

    /**
     * Query Margin Loan Record(USER_DATA)
     *
     * <p>Query margin loan record * txId or startTime must be sent. txId takes precedence. *
     * Response in descending order * The max interval between &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; is 30 days. * If &#x60;startTime&#x60; and &#x60;endTime&#x60; not sent,
     * return records of the last 7 days by default * Set &#x60;archived&#x60; to &#x60;true&#x60;
     * to query data from 6 months ago Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryMarginLoanRecordTest() throws ApiException, CryptoException {
        String asset = "";
        Long txId = 1L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long current = 1L;
        Long size = 10L;
        String archived = "";
        Long recvWindow = 5000L;
        ApiResponse<QueryMarginLoanRecordResponse> response =
                api.queryMarginLoanRecord(
                        asset, txId, startTime, endTime, current, size, archived, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "asset=&txId=1&startTime=1623319461670&endTime=1641782889000&current=1&size=10&archived=&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "31118d378725e0dd919f1e39010f6e9f5e13f36ee04c30710dea40608234d063",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/margin/marginLoan", actualRequest.url().encodedPath());
    }

    /**
     * Query Margin Max Withdraw(USER_DATA)
     *
     * <p>Query Margin Max Withdraw Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryMarginMaxWithdrawTest() throws ApiException, CryptoException {
        String asset = "";
        Long recvWindow = 5000L;
        ApiResponse<QueryMarginMaxWithdrawResponse> response =
                api.queryMarginMaxWithdraw(asset, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("asset=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "a8610b861691761550acea81c71e6fe676ac39bd2020c66ff1115710eaf265a4",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/margin/maxWithdraw", actualRequest.url().encodedPath());
    }

    /**
     * Query Margin repay Record(USER_DATA)
     *
     * <p>Query margin repay record. * txId or startTime must be sent. txId takes precedence. *
     * Response in descending order * The max interval between &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; is 30 days. * If &#x60;startTime&#x60; and &#x60;endTime&#x60; not sent,
     * return records of the last 7 days by default * Set &#x60;archived&#x60; to &#x60;true&#x60;
     * to query data from 6 months ago Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryMarginRepayRecordTest() throws ApiException, CryptoException {
        String asset = "";
        Long txId = 1L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long current = 1L;
        Long size = 10L;
        String archived = "";
        Long recvWindow = 5000L;
        ApiResponse<QueryMarginRepayRecordResponse> response =
                api.queryMarginRepayRecord(
                        asset, txId, startTime, endTime, current, size, archived, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "asset=&txId=1&startTime=1623319461670&endTime=1641782889000&current=1&size=10&archived=&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "31118d378725e0dd919f1e39010f6e9f5e13f36ee04c30710dea40608234d063",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/margin/repayLoan", actualRequest.url().encodedPath());
    }

    /**
     * Query Portfolio Margin Negative Balance Interest History(USER_DATA)
     *
     * <p>Query interest history of negative balance for portfolio margin. * Response in descending
     * order * The max interval between startTime and endTime is 30 days. It is a MUST to ensure
     * data correctness. * If &#x60;startTime&#x60; and &#x60;endTime&#x60; not sent, return records
     * of the last 7 days by default * If &#x60;startTime&#x60; is sent and &#x60;endTime&#x60; is
     * not sent, the records from &#x60;startTime&#x60; to the present will be returned; if
     * &#x60;startTime&#x60; is more than 30 days ago, the records of the past 30 days will be
     * returned. * If &#x60;startTime&#x60; is not sent and &#x60;endTime&#x60; is sent, the records
     * of the 7 days before &#x60;endTime&#x60; is returned. Weight: 50
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryPortfolioMarginNegativeBalanceInterestHistoryTest()
            throws ApiException, CryptoException {
        String asset = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<QueryPortfolioMarginNegativeBalanceInterestHistoryResponse> response =
                api.queryPortfolioMarginNegativeBalanceInterestHistory(
                        asset, startTime, endTime, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "asset=&startTime=1623319461670&endTime=1641782889000&size=10&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "08f5e5a6f9b5d64dcf3e4057c1196835facab312d474221a75a08bcfee1c2c0e",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/portfolio/interest-history", actualRequest.url().encodedPath());
    }

    /**
     * Query UM Position Information(USER_DATA)
     *
     * <p>Get current UM position information. * Please use with user data stream
     * &#x60;ACCOUNT_UPDATE&#x60; to meet your timeliness and accuracy needs. * for One-way Mode
     * user, the response will only show the \&quot;BOTH\&quot; positions * for Hedge Mode user, the
     * response will show \&quot;LONG\&quot;, and \&quot;SHORT\&quot; positions. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryUmPositionInformationTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<QueryUmPositionInformationResponse> response =
                api.queryUmPositionInformation(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/positionRisk", actualRequest.url().encodedPath());
    }

    /**
     * Query User Negative Balance Auto Exchange Record (USER_DATA)
     *
     * <p>Query user negative balance auto exchange record * Response in descending order * The max
     * interval between &#x60;startTime&#x60; and &#x60;endTime&#x60; is 3 months. Weight: 100
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryUserNegativeBalanceAutoExchangeRecordTest()
            throws ApiException, CryptoException {
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long recvWindow = 5000L;
        ApiResponse<QueryUserNegativeBalanceAutoExchangeRecordResponse> response =
                api.queryUserNegativeBalanceAutoExchangeRecord(startTime, endTime, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "startTime=1623319461670&endTime=1641782889000&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "812caedbe8f349196a4532c2050ff706ed2569fed185039c7b60a78cd84bc718",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/papi/v1/portfolio/negative-balance-exchange-record",
                actualRequest.url().encodedPath());
    }

    /**
     * Query User Rate Limit (USER_DATA)
     *
     * <p>Query User Rate Limit Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryUserRateLimitTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<QueryUserRateLimitResponse> response = api.queryUserRateLimit(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/rateLimit/order", actualRequest.url().encodedPath());
    }

    /**
     * Repay futures Negative Balance(USER_DATA)
     *
     * <p>Repay futures Negative Balance Weight: 750
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void repayFuturesNegativeBalanceTest() throws ApiException, CryptoException {
        RepayFuturesNegativeBalanceRequest repayFuturesNegativeBalanceRequest =
                new RepayFuturesNegativeBalanceRequest();

        ApiResponse<RepayFuturesNegativeBalanceResponse> response =
                api.repayFuturesNegativeBalance(repayFuturesNegativeBalanceRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "53668e00dc92eb93de0b253c301e9fc0c20042b13db384a0ad94b38688a5a84c",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/repay-futures-negative-balance", actualRequest.url().encodedPath());
    }

    /**
     * UM Futures Account Configuration(USER_DATA)
     *
     * <p>Query UM Futures account configuration Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void umFuturesAccountConfigurationTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<UmFuturesAccountConfigurationResponse> response =
                api.umFuturesAccountConfiguration(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/accountConfig", actualRequest.url().encodedPath());
    }

    /**
     * UM Futures Symbol Configuration(USER_DATA)
     *
     * <p>Get current UM account symbol configuration. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void umFuturesSymbolConfigurationTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<UmFuturesSymbolConfigurationResponse> response =
                api.umFuturesSymbolConfiguration(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/symbolConfig", actualRequest.url().encodedPath());
    }

    /**
     * UM Notional and Leverage Brackets (USER_DATA)
     *
     * <p>Query UM notional and leverage brackets Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void umNotionalAndLeverageBracketsTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<UmNotionalAndLeverageBracketsResponse> response =
                api.umNotionalAndLeverageBrackets(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/papi/v1/um/leverageBracket", actualRequest.url().encodedPath());
    }
}
