/*
 * Binance Derivatives Trading USDS Futures WebSocket Market Streams
 * OpenAPI Specification for the Binance Derivatives Trading USDS Futures WebSocket Market Streams
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.api;

import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.exception.ConstraintViolationException;
import com.binance.connector.client.common.websocket.adapter.stream.StreamConnectionInterface;
import com.binance.connector.client.common.websocket.dtos.RequestWrapperDTO;
import com.binance.connector.client.common.websocket.service.StreamBlockingQueue;
import com.binance.connector.client.common.websocket.service.StreamBlockingQueueWrapper;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.AggregateTradeStreamsRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.AggregateTradeStreamsResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.AllBookTickersStreamRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.AllBookTickersStreamResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.AllMarketLiquidationOrderStreamsRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.AllMarketLiquidationOrderStreamsResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.AllMarketMiniTickersStreamRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.AllMarketMiniTickersStreamResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.AllMarketTickersStreamsRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.AllMarketTickersStreamsResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.CompositeIndexSymbolInformationStreamsRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.CompositeIndexSymbolInformationStreamsResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.ContinuousContractKlineCandlestickStreamsRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.ContinuousContractKlineCandlestickStreamsResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.ContractInfoStreamRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.ContractInfoStreamResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.DiffBookDepthStreamsRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.DiffBookDepthStreamsResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.IndividualSymbolBookTickerStreamsRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.IndividualSymbolBookTickerStreamsResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.IndividualSymbolMiniTickerStreamRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.IndividualSymbolMiniTickerStreamResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.IndividualSymbolTickerStreamsRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.IndividualSymbolTickerStreamsResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.KlineCandlestickStreamsRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.KlineCandlestickStreamsResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.LiquidationOrderStreamsRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.LiquidationOrderStreamsResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.MarkPriceStreamForAllMarketRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.MarkPriceStreamForAllMarketResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.MarkPriceStreamRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.MarkPriceStreamResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.MultiAssetsModeAssetIndexRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.MultiAssetsModeAssetIndexResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.PartialBookDepthStreamsRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.stream.model.PartialBookDepthStreamsResponse;
import com.google.gson.reflect.TypeToken;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.constraints.*;
import java.util.Collections;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator;

public class WebsocketMarketStreamsApi {
    private StreamConnectionInterface connection;

    public WebsocketMarketStreamsApi() {}

    public WebsocketMarketStreamsApi(StreamConnectionInterface connection) {
        this.connection = connection;
    }

    /**
     * Aggregate Trade Streams The Aggregate Trade Streams push market trade information that is
     * aggregated for fills with same price and taking side every 100 milliseconds. Only market
     * trades will be aggregated, which means the insurance fund trades and ADL trades won&#39;t be
     * aggregated. Update Speed: 100ms
     *
     * @param aggregateTradeStreamsRequest (required)
     * @return AggregateTradeStreamsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Aggregate Trade Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Aggregate-Trade-Streams">Aggregate
     *     Trade Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<AggregateTradeStreamsResponse> aggregateTradeStreams(
            AggregateTradeStreamsRequest aggregateTradeStreamsRequest) throws ApiException {
        StreamBlockingQueue<String> queue = aggregateTradeStreamsRaw(aggregateTradeStreamsRequest);

        TypeToken<AggregateTradeStreamsResponse> typeToken =
                new TypeToken<AggregateTradeStreamsResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> aggregateTradeStreamsRaw(
            AggregateTradeStreamsRequest aggregateTradeStreamsRequest) throws ApiException {
        aggregateTradeStreamsValidateBeforeCall(aggregateTradeStreamsRequest);

        String methodName =
                "/<symbol>@aggTrade"
                        .substring(1)
                        .replace(
                                "<id>",
                                aggregateTradeStreamsRequest.getId() != null
                                        ? aggregateTradeStreamsRequest.getId().toString()
                                        : "")
                        .replace(
                                "<symbol>",
                                aggregateTradeStreamsRequest.getSymbol() != null
                                        ? aggregateTradeStreamsRequest.getSymbol().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void aggregateTradeStreamsValidateBeforeCall(
            AggregateTradeStreamsRequest aggregateTradeStreamsRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<AggregateTradeStreamsRequest>> violations =
                    validator.validate(aggregateTradeStreamsRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * All Book Tickers Stream Pushes any update to the best bid or ask&#39;s price or quantity in
     * real-time for all symbols. Update Speed: 5s
     *
     * @param allBookTickersStreamRequest (required)
     * @return AllBookTickersStreamResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> All Book Tickers Stream </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-Book-Tickers-Stream">All
     *     Book Tickers Stream Documentation</a>
     */
    public StreamBlockingQueueWrapper<AllBookTickersStreamResponse> allBookTickersStream(
            AllBookTickersStreamRequest allBookTickersStreamRequest) throws ApiException {
        StreamBlockingQueue<String> queue = allBookTickersStreamRaw(allBookTickersStreamRequest);

        TypeToken<AllBookTickersStreamResponse> typeToken =
                new TypeToken<AllBookTickersStreamResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> allBookTickersStreamRaw(
            AllBookTickersStreamRequest allBookTickersStreamRequest) throws ApiException {
        allBookTickersStreamValidateBeforeCall(allBookTickersStreamRequest);

        String methodName =
                "/!bookTicker"
                        .substring(1)
                        .replace(
                                "<id>",
                                allBookTickersStreamRequest.getId() != null
                                        ? allBookTickersStreamRequest.getId().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void allBookTickersStreamValidateBeforeCall(
            AllBookTickersStreamRequest allBookTickersStreamRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<AllBookTickersStreamRequest>> violations =
                    validator.validate(allBookTickersStreamRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * All Market Liquidation Order Streams The All Liquidation Order Snapshot Streams push force
     * liquidation order information for all symbols in the market. For each symbol，only the latest
     * one liquidation order within 1000ms will be pushed as the snapshot. If no liquidation happens
     * in the interval of 1000ms, no stream will be pushed. Update Speed: 1000ms
     *
     * @param allMarketLiquidationOrderStreamsRequest (required)
     * @return AllMarketLiquidationOrderStreamsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> All Market Liquidation Order Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-Market-Liquidation-Order-Streams">All
     *     Market Liquidation Order Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<AllMarketLiquidationOrderStreamsResponse>
            allMarketLiquidationOrderStreams(
                    AllMarketLiquidationOrderStreamsRequest allMarketLiquidationOrderStreamsRequest)
                    throws ApiException {
        StreamBlockingQueue<String> queue =
                allMarketLiquidationOrderStreamsRaw(allMarketLiquidationOrderStreamsRequest);

        TypeToken<AllMarketLiquidationOrderStreamsResponse> typeToken =
                new TypeToken<AllMarketLiquidationOrderStreamsResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> allMarketLiquidationOrderStreamsRaw(
            AllMarketLiquidationOrderStreamsRequest allMarketLiquidationOrderStreamsRequest)
            throws ApiException {
        allMarketLiquidationOrderStreamsValidateBeforeCall(allMarketLiquidationOrderStreamsRequest);

        String methodName =
                "/!forceOrder@arr"
                        .substring(1)
                        .replace(
                                "<id>",
                                allMarketLiquidationOrderStreamsRequest.getId() != null
                                        ? allMarketLiquidationOrderStreamsRequest.getId().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void allMarketLiquidationOrderStreamsValidateBeforeCall(
            AllMarketLiquidationOrderStreamsRequest allMarketLiquidationOrderStreamsRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<AllMarketLiquidationOrderStreamsRequest>> violations =
                    validator.validate(allMarketLiquidationOrderStreamsRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * All Market Mini Tickers Stream 24hr rolling window mini-ticker statistics for all symbols.
     * These are NOT the statistics of the UTC day, but a 24hr rolling window from requestTime to
     * 24hrs before. Note that only tickers that have changed will be present in the array. Update
     * Speed: 1000ms
     *
     * @param allMarketMiniTickersStreamRequest (required)
     * @return AllMarketMiniTickersStreamResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> All Market Mini Tickers Stream </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-Market-Mini-Tickers-Stream">All
     *     Market Mini Tickers Stream Documentation</a>
     */
    public StreamBlockingQueueWrapper<AllMarketMiniTickersStreamResponse>
            allMarketMiniTickersStream(
                    AllMarketMiniTickersStreamRequest allMarketMiniTickersStreamRequest)
                    throws ApiException {
        StreamBlockingQueue<String> queue =
                allMarketMiniTickersStreamRaw(allMarketMiniTickersStreamRequest);

        TypeToken<AllMarketMiniTickersStreamResponse> typeToken =
                new TypeToken<AllMarketMiniTickersStreamResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> allMarketMiniTickersStreamRaw(
            AllMarketMiniTickersStreamRequest allMarketMiniTickersStreamRequest)
            throws ApiException {
        allMarketMiniTickersStreamValidateBeforeCall(allMarketMiniTickersStreamRequest);

        String methodName =
                "/!miniTicker@arr"
                        .substring(1)
                        .replace(
                                "<id>",
                                allMarketMiniTickersStreamRequest.getId() != null
                                        ? allMarketMiniTickersStreamRequest.getId().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void allMarketMiniTickersStreamValidateBeforeCall(
            AllMarketMiniTickersStreamRequest allMarketMiniTickersStreamRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<AllMarketMiniTickersStreamRequest>> violations =
                    validator.validate(allMarketMiniTickersStreamRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * All Market Tickers Streams 24hr rolling window ticker statistics for all symbols. These are
     * NOT the statistics of the UTC day, but a 24hr rolling window from requestTime to 24hrs
     * before. Note that only tickers that have changed will be present in the array. Update Speed:
     * 1000ms
     *
     * @param allMarketTickersStreamsRequest (required)
     * @return AllMarketTickersStreamsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> All Market Tickers Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/All-Market-Tickers-Streams">All
     *     Market Tickers Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<AllMarketTickersStreamsResponse> allMarketTickersStreams(
            AllMarketTickersStreamsRequest allMarketTickersStreamsRequest) throws ApiException {
        StreamBlockingQueue<String> queue =
                allMarketTickersStreamsRaw(allMarketTickersStreamsRequest);

        TypeToken<AllMarketTickersStreamsResponse> typeToken =
                new TypeToken<AllMarketTickersStreamsResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> allMarketTickersStreamsRaw(
            AllMarketTickersStreamsRequest allMarketTickersStreamsRequest) throws ApiException {
        allMarketTickersStreamsValidateBeforeCall(allMarketTickersStreamsRequest);

        String methodName =
                "/!ticker@arr"
                        .substring(1)
                        .replace(
                                "<id>",
                                allMarketTickersStreamsRequest.getId() != null
                                        ? allMarketTickersStreamsRequest.getId().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void allMarketTickersStreamsValidateBeforeCall(
            AllMarketTickersStreamsRequest allMarketTickersStreamsRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<AllMarketTickersStreamsRequest>> violations =
                    validator.validate(allMarketTickersStreamsRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Composite Index Symbol Information Streams Composite index information for index symbols
     * pushed every second. Update Speed: 1000ms
     *
     * @param compositeIndexSymbolInformationStreamsRequest (required)
     * @return CompositeIndexSymbolInformationStreamsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Composite Index Symbol Information Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Composite-Index-Symbol-Information-Streams">Composite
     *     Index Symbol Information Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<CompositeIndexSymbolInformationStreamsResponse>
            compositeIndexSymbolInformationStreams(
                    CompositeIndexSymbolInformationStreamsRequest
                            compositeIndexSymbolInformationStreamsRequest)
                    throws ApiException {
        StreamBlockingQueue<String> queue =
                compositeIndexSymbolInformationStreamsRaw(
                        compositeIndexSymbolInformationStreamsRequest);

        TypeToken<CompositeIndexSymbolInformationStreamsResponse> typeToken =
                new TypeToken<CompositeIndexSymbolInformationStreamsResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> compositeIndexSymbolInformationStreamsRaw(
            CompositeIndexSymbolInformationStreamsRequest
                    compositeIndexSymbolInformationStreamsRequest)
            throws ApiException {
        compositeIndexSymbolInformationStreamsValidateBeforeCall(
                compositeIndexSymbolInformationStreamsRequest);

        String methodName =
                "/<symbol>@compositeIndex"
                        .substring(1)
                        .replace(
                                "<id>",
                                compositeIndexSymbolInformationStreamsRequest.getId() != null
                                        ? compositeIndexSymbolInformationStreamsRequest
                                                .getId()
                                                .toString()
                                        : "")
                        .replace(
                                "<symbol>",
                                compositeIndexSymbolInformationStreamsRequest.getSymbol() != null
                                        ? compositeIndexSymbolInformationStreamsRequest
                                                .getSymbol()
                                                .toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void compositeIndexSymbolInformationStreamsValidateBeforeCall(
            CompositeIndexSymbolInformationStreamsRequest
                    compositeIndexSymbolInformationStreamsRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<CompositeIndexSymbolInformationStreamsRequest>> violations =
                    validator.validate(compositeIndexSymbolInformationStreamsRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Continuous Contract Kline/Candlestick Streams Update Speed: 250ms
     *
     * @param continuousContractKlineCandlestickStreamsRequest (required)
     * @return ContinuousContractKlineCandlestickStreamsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Continuous Contract Kline/Candlestick Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Continuous-Contract-Kline-Candlestick-Streams">Continuous
     *     Contract Kline/Candlestick Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<ContinuousContractKlineCandlestickStreamsResponse>
            continuousContractKlineCandlestickStreams(
                    ContinuousContractKlineCandlestickStreamsRequest
                            continuousContractKlineCandlestickStreamsRequest)
                    throws ApiException {
        StreamBlockingQueue<String> queue =
                continuousContractKlineCandlestickStreamsRaw(
                        continuousContractKlineCandlestickStreamsRequest);

        TypeToken<ContinuousContractKlineCandlestickStreamsResponse> typeToken =
                new TypeToken<ContinuousContractKlineCandlestickStreamsResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> continuousContractKlineCandlestickStreamsRaw(
            ContinuousContractKlineCandlestickStreamsRequest
                    continuousContractKlineCandlestickStreamsRequest)
            throws ApiException {
        continuousContractKlineCandlestickStreamsValidateBeforeCall(
                continuousContractKlineCandlestickStreamsRequest);

        String methodName =
                "/<pair>_<contractType>@continuousKline_<interval>"
                        .substring(1)
                        .replace(
                                "<id>",
                                continuousContractKlineCandlestickStreamsRequest.getId() != null
                                        ? continuousContractKlineCandlestickStreamsRequest
                                                .getId()
                                                .toString()
                                        : "")
                        .replace(
                                "<pair>",
                                continuousContractKlineCandlestickStreamsRequest.getPair() != null
                                        ? continuousContractKlineCandlestickStreamsRequest
                                                .getPair()
                                                .toString()
                                        : "")
                        .replace(
                                "<contractType>",
                                continuousContractKlineCandlestickStreamsRequest.getContractType()
                                                != null
                                        ? continuousContractKlineCandlestickStreamsRequest
                                                .getContractType()
                                                .toString()
                                        : "")
                        .replace(
                                "<interval>",
                                continuousContractKlineCandlestickStreamsRequest.getInterval()
                                                != null
                                        ? continuousContractKlineCandlestickStreamsRequest
                                                .getInterval()
                                                .toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void continuousContractKlineCandlestickStreamsValidateBeforeCall(
            ContinuousContractKlineCandlestickStreamsRequest
                    continuousContractKlineCandlestickStreamsRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<ContinuousContractKlineCandlestickStreamsRequest>> violations =
                    validator.validate(continuousContractKlineCandlestickStreamsRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Contract Info Stream ContractInfo stream pushes when contract info
     * updates(listing/settlement/contract bracket update). &#x60;bks&#x60; field only shows up when
     * bracket gets updated. Update Speed: Real-time
     *
     * @param contractInfoStreamRequest (required)
     * @return ContractInfoStreamResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Contract Info Stream </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Contract-Info-Stream">Contract
     *     Info Stream Documentation</a>
     */
    public StreamBlockingQueueWrapper<ContractInfoStreamResponse> contractInfoStream(
            ContractInfoStreamRequest contractInfoStreamRequest) throws ApiException {
        StreamBlockingQueue<String> queue = contractInfoStreamRaw(contractInfoStreamRequest);

        TypeToken<ContractInfoStreamResponse> typeToken =
                new TypeToken<ContractInfoStreamResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> contractInfoStreamRaw(
            ContractInfoStreamRequest contractInfoStreamRequest) throws ApiException {
        contractInfoStreamValidateBeforeCall(contractInfoStreamRequest);

        String methodName =
                "/!contractInfo"
                        .substring(1)
                        .replace(
                                "<id>",
                                contractInfoStreamRequest.getId() != null
                                        ? contractInfoStreamRequest.getId().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void contractInfoStreamValidateBeforeCall(
            ContractInfoStreamRequest contractInfoStreamRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<ContractInfoStreamRequest>> violations =
                    validator.validate(contractInfoStreamRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Diff. Book Depth Streams Bids and asks, pushed every 250 milliseconds, 500 milliseconds, 100
     * milliseconds (if existing) Update Speed: 250ms, 500ms, 100ms
     *
     * @param diffBookDepthStreamsRequest (required)
     * @return DiffBookDepthStreamsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Diff. Book Depth Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Diff-Book-Depth-Streams">Diff.
     *     Book Depth Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<DiffBookDepthStreamsResponse> diffBookDepthStreams(
            DiffBookDepthStreamsRequest diffBookDepthStreamsRequest) throws ApiException {
        StreamBlockingQueue<String> queue = diffBookDepthStreamsRaw(diffBookDepthStreamsRequest);

        TypeToken<DiffBookDepthStreamsResponse> typeToken =
                new TypeToken<DiffBookDepthStreamsResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> diffBookDepthStreamsRaw(
            DiffBookDepthStreamsRequest diffBookDepthStreamsRequest) throws ApiException {
        diffBookDepthStreamsValidateBeforeCall(diffBookDepthStreamsRequest);

        String methodName =
                "/<symbol>@depth@<updateSpeed>"
                        .substring(1)
                        .replace(
                                "<id>",
                                diffBookDepthStreamsRequest.getId() != null
                                        ? diffBookDepthStreamsRequest.getId().toString()
                                        : "")
                        .replace(
                                "<symbol>",
                                diffBookDepthStreamsRequest.getSymbol() != null
                                        ? diffBookDepthStreamsRequest.getSymbol().toString()
                                        : "")
                        .replace(
                                "<updateSpeed>",
                                diffBookDepthStreamsRequest.getUpdateSpeed() != null
                                        ? diffBookDepthStreamsRequest.getUpdateSpeed().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void diffBookDepthStreamsValidateBeforeCall(
            DiffBookDepthStreamsRequest diffBookDepthStreamsRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<DiffBookDepthStreamsRequest>> violations =
                    validator.validate(diffBookDepthStreamsRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Individual Symbol Book Ticker Streams Pushes any update to the best bid or ask&#39;s price or
     * quantity in real-time for a specified symbol. Update Speed: Real-time
     *
     * @param individualSymbolBookTickerStreamsRequest (required)
     * @return IndividualSymbolBookTickerStreamsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Individual Symbol Book Ticker Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Individual-Symbol-Book-Ticker-Streams">Individual
     *     Symbol Book Ticker Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<IndividualSymbolBookTickerStreamsResponse>
            individualSymbolBookTickerStreams(
                    IndividualSymbolBookTickerStreamsRequest
                            individualSymbolBookTickerStreamsRequest)
                    throws ApiException {
        StreamBlockingQueue<String> queue =
                individualSymbolBookTickerStreamsRaw(individualSymbolBookTickerStreamsRequest);

        TypeToken<IndividualSymbolBookTickerStreamsResponse> typeToken =
                new TypeToken<IndividualSymbolBookTickerStreamsResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> individualSymbolBookTickerStreamsRaw(
            IndividualSymbolBookTickerStreamsRequest individualSymbolBookTickerStreamsRequest)
            throws ApiException {
        individualSymbolBookTickerStreamsValidateBeforeCall(
                individualSymbolBookTickerStreamsRequest);

        String methodName =
                "/<symbol>@bookTicker"
                        .substring(1)
                        .replace(
                                "<id>",
                                individualSymbolBookTickerStreamsRequest.getId() != null
                                        ? individualSymbolBookTickerStreamsRequest
                                                .getId()
                                                .toString()
                                        : "")
                        .replace(
                                "<symbol>",
                                individualSymbolBookTickerStreamsRequest.getSymbol() != null
                                        ? individualSymbolBookTickerStreamsRequest
                                                .getSymbol()
                                                .toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void individualSymbolBookTickerStreamsValidateBeforeCall(
            IndividualSymbolBookTickerStreamsRequest individualSymbolBookTickerStreamsRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<IndividualSymbolBookTickerStreamsRequest>> violations =
                    validator.validate(individualSymbolBookTickerStreamsRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Individual Symbol Mini Ticker Stream 24hr rolling window mini-ticker statistics for a single
     * symbol. These are NOT the statistics of the UTC day, but a 24hr rolling window from
     * requestTime to 24hrs before. Update Speed: 2s
     *
     * @param individualSymbolMiniTickerStreamRequest (required)
     * @return IndividualSymbolMiniTickerStreamResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Individual Symbol Mini Ticker Stream </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Individual-Symbol-Mini-Ticker-Stream">Individual
     *     Symbol Mini Ticker Stream Documentation</a>
     */
    public StreamBlockingQueueWrapper<IndividualSymbolMiniTickerStreamResponse>
            individualSymbolMiniTickerStream(
                    IndividualSymbolMiniTickerStreamRequest individualSymbolMiniTickerStreamRequest)
                    throws ApiException {
        StreamBlockingQueue<String> queue =
                individualSymbolMiniTickerStreamRaw(individualSymbolMiniTickerStreamRequest);

        TypeToken<IndividualSymbolMiniTickerStreamResponse> typeToken =
                new TypeToken<IndividualSymbolMiniTickerStreamResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> individualSymbolMiniTickerStreamRaw(
            IndividualSymbolMiniTickerStreamRequest individualSymbolMiniTickerStreamRequest)
            throws ApiException {
        individualSymbolMiniTickerStreamValidateBeforeCall(individualSymbolMiniTickerStreamRequest);

        String methodName =
                "/<symbol>@miniTicker"
                        .substring(1)
                        .replace(
                                "<id>",
                                individualSymbolMiniTickerStreamRequest.getId() != null
                                        ? individualSymbolMiniTickerStreamRequest.getId().toString()
                                        : "")
                        .replace(
                                "<symbol>",
                                individualSymbolMiniTickerStreamRequest.getSymbol() != null
                                        ? individualSymbolMiniTickerStreamRequest
                                                .getSymbol()
                                                .toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void individualSymbolMiniTickerStreamValidateBeforeCall(
            IndividualSymbolMiniTickerStreamRequest individualSymbolMiniTickerStreamRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<IndividualSymbolMiniTickerStreamRequest>> violations =
                    validator.validate(individualSymbolMiniTickerStreamRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Individual Symbol Ticker Streams 24hr rolling window ticker statistics for a single symbol.
     * These are NOT the statistics of the UTC day, but a 24hr rolling window from requestTime to
     * 24hrs before. Update Speed: 2000ms
     *
     * @param individualSymbolTickerStreamsRequest (required)
     * @return IndividualSymbolTickerStreamsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Individual Symbol Ticker Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Individual-Symbol-Ticker-Streams">Individual
     *     Symbol Ticker Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<IndividualSymbolTickerStreamsResponse>
            individualSymbolTickerStreams(
                    IndividualSymbolTickerStreamsRequest individualSymbolTickerStreamsRequest)
                    throws ApiException {
        StreamBlockingQueue<String> queue =
                individualSymbolTickerStreamsRaw(individualSymbolTickerStreamsRequest);

        TypeToken<IndividualSymbolTickerStreamsResponse> typeToken =
                new TypeToken<IndividualSymbolTickerStreamsResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> individualSymbolTickerStreamsRaw(
            IndividualSymbolTickerStreamsRequest individualSymbolTickerStreamsRequest)
            throws ApiException {
        individualSymbolTickerStreamsValidateBeforeCall(individualSymbolTickerStreamsRequest);

        String methodName =
                "/<symbol>@ticker"
                        .substring(1)
                        .replace(
                                "<id>",
                                individualSymbolTickerStreamsRequest.getId() != null
                                        ? individualSymbolTickerStreamsRequest.getId().toString()
                                        : "")
                        .replace(
                                "<symbol>",
                                individualSymbolTickerStreamsRequest.getSymbol() != null
                                        ? individualSymbolTickerStreamsRequest
                                                .getSymbol()
                                                .toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void individualSymbolTickerStreamsValidateBeforeCall(
            IndividualSymbolTickerStreamsRequest individualSymbolTickerStreamsRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<IndividualSymbolTickerStreamsRequest>> violations =
                    validator.validate(individualSymbolTickerStreamsRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Kline/Candlestick Streams The Kline/Candlestick Stream push updates to the current
     * klines/candlestick every 250 milliseconds (if existing). Update Speed: 250ms
     *
     * @param klineCandlestickStreamsRequest (required)
     * @return KlineCandlestickStreamsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Kline/Candlestick Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Kline-Candlestick-Streams">Kline/Candlestick
     *     Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<KlineCandlestickStreamsResponse> klineCandlestickStreams(
            KlineCandlestickStreamsRequest klineCandlestickStreamsRequest) throws ApiException {
        StreamBlockingQueue<String> queue =
                klineCandlestickStreamsRaw(klineCandlestickStreamsRequest);

        TypeToken<KlineCandlestickStreamsResponse> typeToken =
                new TypeToken<KlineCandlestickStreamsResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> klineCandlestickStreamsRaw(
            KlineCandlestickStreamsRequest klineCandlestickStreamsRequest) throws ApiException {
        klineCandlestickStreamsValidateBeforeCall(klineCandlestickStreamsRequest);

        String methodName =
                "/<symbol>@kline_<interval>"
                        .substring(1)
                        .replace(
                                "<id>",
                                klineCandlestickStreamsRequest.getId() != null
                                        ? klineCandlestickStreamsRequest.getId().toString()
                                        : "")
                        .replace(
                                "<symbol>",
                                klineCandlestickStreamsRequest.getSymbol() != null
                                        ? klineCandlestickStreamsRequest.getSymbol().toString()
                                        : "")
                        .replace(
                                "<interval>",
                                klineCandlestickStreamsRequest.getInterval() != null
                                        ? klineCandlestickStreamsRequest.getInterval().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void klineCandlestickStreamsValidateBeforeCall(
            KlineCandlestickStreamsRequest klineCandlestickStreamsRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<KlineCandlestickStreamsRequest>> violations =
                    validator.validate(klineCandlestickStreamsRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Liquidation Order Streams The Liquidation Order Snapshot Streams push force liquidation order
     * information for specific symbol. For each symbol，only the latest one liquidation order within
     * 1000ms will be pushed as the snapshot. If no liquidation happens in the interval of 1000ms,
     * no stream will be pushed. Update Speed: 1000ms
     *
     * @param liquidationOrderStreamsRequest (required)
     * @return LiquidationOrderStreamsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Liquidation Order Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Liquidation-Order-Streams">Liquidation
     *     Order Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<LiquidationOrderStreamsResponse> liquidationOrderStreams(
            LiquidationOrderStreamsRequest liquidationOrderStreamsRequest) throws ApiException {
        StreamBlockingQueue<String> queue =
                liquidationOrderStreamsRaw(liquidationOrderStreamsRequest);

        TypeToken<LiquidationOrderStreamsResponse> typeToken =
                new TypeToken<LiquidationOrderStreamsResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> liquidationOrderStreamsRaw(
            LiquidationOrderStreamsRequest liquidationOrderStreamsRequest) throws ApiException {
        liquidationOrderStreamsValidateBeforeCall(liquidationOrderStreamsRequest);

        String methodName =
                "/<symbol>@forceOrder"
                        .substring(1)
                        .replace(
                                "<id>",
                                liquidationOrderStreamsRequest.getId() != null
                                        ? liquidationOrderStreamsRequest.getId().toString()
                                        : "")
                        .replace(
                                "<symbol>",
                                liquidationOrderStreamsRequest.getSymbol() != null
                                        ? liquidationOrderStreamsRequest.getSymbol().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void liquidationOrderStreamsValidateBeforeCall(
            LiquidationOrderStreamsRequest liquidationOrderStreamsRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<LiquidationOrderStreamsRequest>> violations =
                    validator.validate(liquidationOrderStreamsRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Mark Price Stream Mark price and funding rate for a single symbol pushed every 3 seconds or
     * every second. Update Speed: 3000ms or 1000ms
     *
     * @param markPriceStreamRequest (required)
     * @return MarkPriceStreamResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Mark Price Stream </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Mark-Price-Stream">Mark
     *     Price Stream Documentation</a>
     */
    public StreamBlockingQueueWrapper<MarkPriceStreamResponse> markPriceStream(
            MarkPriceStreamRequest markPriceStreamRequest) throws ApiException {
        StreamBlockingQueue<String> queue = markPriceStreamRaw(markPriceStreamRequest);

        TypeToken<MarkPriceStreamResponse> typeToken = new TypeToken<MarkPriceStreamResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> markPriceStreamRaw(
            MarkPriceStreamRequest markPriceStreamRequest) throws ApiException {
        markPriceStreamValidateBeforeCall(markPriceStreamRequest);

        String methodName =
                "/<symbol>@markPrice@<updateSpeed>"
                        .substring(1)
                        .replace(
                                "<id>",
                                markPriceStreamRequest.getId() != null
                                        ? markPriceStreamRequest.getId().toString()
                                        : "")
                        .replace(
                                "<symbol>",
                                markPriceStreamRequest.getSymbol() != null
                                        ? markPriceStreamRequest.getSymbol().toString()
                                        : "")
                        .replace(
                                "<updateSpeed>",
                                markPriceStreamRequest.getUpdateSpeed() != null
                                        ? markPriceStreamRequest.getUpdateSpeed().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void markPriceStreamValidateBeforeCall(MarkPriceStreamRequest markPriceStreamRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<MarkPriceStreamRequest>> violations =
                    validator.validate(markPriceStreamRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Mark Price Stream for All market Mark price and funding rate for all symbols pushed every 3
     * seconds or every second. Update Speed: 3000ms or 1000ms
     *
     * @param markPriceStreamForAllMarketRequest (required)
     * @return MarkPriceStreamForAllMarketResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Mark Price Stream for All market </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Mark-Price-Stream-for-All-market">Mark
     *     Price Stream for All market Documentation</a>
     */
    public StreamBlockingQueueWrapper<MarkPriceStreamForAllMarketResponse>
            markPriceStreamForAllMarket(
                    MarkPriceStreamForAllMarketRequest markPriceStreamForAllMarketRequest)
                    throws ApiException {
        StreamBlockingQueue<String> queue =
                markPriceStreamForAllMarketRaw(markPriceStreamForAllMarketRequest);

        TypeToken<MarkPriceStreamForAllMarketResponse> typeToken =
                new TypeToken<MarkPriceStreamForAllMarketResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> markPriceStreamForAllMarketRaw(
            MarkPriceStreamForAllMarketRequest markPriceStreamForAllMarketRequest)
            throws ApiException {
        markPriceStreamForAllMarketValidateBeforeCall(markPriceStreamForAllMarketRequest);

        String methodName =
                "/!markPrice@arr@<updateSpeed>"
                        .substring(1)
                        .replace(
                                "<id>",
                                markPriceStreamForAllMarketRequest.getId() != null
                                        ? markPriceStreamForAllMarketRequest.getId().toString()
                                        : "")
                        .replace(
                                "<updateSpeed>",
                                markPriceStreamForAllMarketRequest.getUpdateSpeed() != null
                                        ? markPriceStreamForAllMarketRequest
                                                .getUpdateSpeed()
                                                .toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void markPriceStreamForAllMarketValidateBeforeCall(
            MarkPriceStreamForAllMarketRequest markPriceStreamForAllMarketRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<MarkPriceStreamForAllMarketRequest>> violations =
                    validator.validate(markPriceStreamForAllMarketRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Multi-Assets Mode Asset Index Asset index for multi-assets mode user Update Speed: 1s
     *
     * @param multiAssetsModeAssetIndexRequest (required)
     * @return MultiAssetsModeAssetIndexResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Multi-Assets Mode Asset Index </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Multi-Assets-Mode-Asset-Index">Multi-Assets
     *     Mode Asset Index Documentation</a>
     */
    public StreamBlockingQueueWrapper<MultiAssetsModeAssetIndexResponse> multiAssetsModeAssetIndex(
            MultiAssetsModeAssetIndexRequest multiAssetsModeAssetIndexRequest) throws ApiException {
        StreamBlockingQueue<String> queue =
                multiAssetsModeAssetIndexRaw(multiAssetsModeAssetIndexRequest);

        TypeToken<MultiAssetsModeAssetIndexResponse> typeToken =
                new TypeToken<MultiAssetsModeAssetIndexResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> multiAssetsModeAssetIndexRaw(
            MultiAssetsModeAssetIndexRequest multiAssetsModeAssetIndexRequest) throws ApiException {
        multiAssetsModeAssetIndexValidateBeforeCall(multiAssetsModeAssetIndexRequest);

        String methodName =
                "/!assetIndex@arr"
                        .substring(1)
                        .replace(
                                "<id>",
                                multiAssetsModeAssetIndexRequest.getId() != null
                                        ? multiAssetsModeAssetIndexRequest.getId().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void multiAssetsModeAssetIndexValidateBeforeCall(
            MultiAssetsModeAssetIndexRequest multiAssetsModeAssetIndexRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<MultiAssetsModeAssetIndexRequest>> violations =
                    validator.validate(multiAssetsModeAssetIndexRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Partial Book Depth Streams Top **&lt;levels\\&gt;** bids and asks, Valid **&lt;levels\\&gt;**
     * are 5, 10, or 20. Update Speed: 250ms, 500ms or 100ms
     *
     * @param partialBookDepthStreamsRequest (required)
     * @return PartialBookDepthStreamsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Partial Book Depth Streams </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-market-streams/Partial-Book-Depth-Streams">Partial
     *     Book Depth Streams Documentation</a>
     */
    public StreamBlockingQueueWrapper<PartialBookDepthStreamsResponse> partialBookDepthStreams(
            PartialBookDepthStreamsRequest partialBookDepthStreamsRequest) throws ApiException {
        StreamBlockingQueue<String> queue =
                partialBookDepthStreamsRaw(partialBookDepthStreamsRequest);

        TypeToken<PartialBookDepthStreamsResponse> typeToken =
                new TypeToken<PartialBookDepthStreamsResponse>() {};

        return new StreamBlockingQueueWrapper<>(queue, typeToken);
    }

    public StreamBlockingQueue<String> partialBookDepthStreamsRaw(
            PartialBookDepthStreamsRequest partialBookDepthStreamsRequest) throws ApiException {
        partialBookDepthStreamsValidateBeforeCall(partialBookDepthStreamsRequest);

        String methodName =
                "/<symbol>@depth<levels>@<updateSpeed>"
                        .substring(1)
                        .replace(
                                "<id>",
                                partialBookDepthStreamsRequest.getId() != null
                                        ? partialBookDepthStreamsRequest.getId().toString()
                                        : "")
                        .replace(
                                "<symbol>",
                                partialBookDepthStreamsRequest.getSymbol() != null
                                        ? partialBookDepthStreamsRequest.getSymbol().toString()
                                        : "")
                        .replace(
                                "<levels>",
                                partialBookDepthStreamsRequest.getLevels() != null
                                        ? partialBookDepthStreamsRequest.getLevels().toString()
                                        : "")
                        .replace(
                                "<updateSpeed>",
                                partialBookDepthStreamsRequest.getUpdateSpeed() != null
                                        ? partialBookDepthStreamsRequest.getUpdateSpeed().toString()
                                        : "");
        if ("@".equals(methodName.substring(methodName.length() - 1))) {
            methodName = methodName.substring(0, methodName.length() - 1);
        }

        RequestWrapperDTO<Set<String>, Object> requestWrapperDTO =
                new RequestWrapperDTO.Builder<Set<String>, Object>()
                        .id(getRequestID())
                        .method("SUBSCRIBE")
                        .params(Collections.singleton(methodName))
                        .build();
        Map<String, StreamBlockingQueue<String>> queuesMap =
                connection.subscribe(requestWrapperDTO);
        return queuesMap.get(methodName);
    }

    @SuppressWarnings("rawtypes")
    private void partialBookDepthStreamsValidateBeforeCall(
            PartialBookDepthStreamsRequest partialBookDepthStreamsRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<PartialBookDepthStreamsRequest>> violations =
                    validator.validate(partialBookDepthStreamsRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    public String getRequestID() {
        return UUID.randomUUID().toString();
    }
}
