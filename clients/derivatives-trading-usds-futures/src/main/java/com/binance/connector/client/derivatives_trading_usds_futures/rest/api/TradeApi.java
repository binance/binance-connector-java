/*
 * Binance Derivatives Trading USDS Futures REST API
 * OpenAPI Specification for the Binance Derivatives Trading USDS Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_usds_futures.rest.api;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.DecimalFormatter;
import com.binance.connector.client.common.JSON;
import com.binance.connector.client.common.Pair;
import com.binance.connector.client.common.SystemUtil;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.exception.ConstraintViolationException;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.AccountTradeListResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.AllOrdersResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.AutoCancelAllOpenOrdersRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.AutoCancelAllOpenOrdersResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.AutoCloseType;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.CancelAllOpenOrdersResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.CancelMultipleOrdersResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.CancelOrderResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ChangeInitialLeverageRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ChangeInitialLeverageResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ChangeMarginTypeRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ChangeMarginTypeResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ChangeMultiAssetsModeRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ChangeMultiAssetsModeResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ChangePositionModeRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ChangePositionModeResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.CurrentAllOpenOrdersResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.GetOrderModifyHistoryResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.GetPositionMarginChangeHistoryResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ModifyIsolatedPositionMarginRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ModifyIsolatedPositionMarginResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ModifyMultipleOrdersRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ModifyMultipleOrdersResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ModifyOrderRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ModifyOrderResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.NewOrderRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.NewOrderResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.OrderIdList;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.OrigClientOrderIdList;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.PlaceMultipleOrdersRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.PlaceMultipleOrdersResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.PositionAdlQuantileEstimationResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.PositionInformationV2Response;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.PositionInformationV3Response;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.QueryCurrentOpenOrderResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.QueryOrderResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.TestOrderRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.TestOrderResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.UsersForceOrdersResponse;
import com.google.gson.reflect.TypeToken;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Valid;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.constraints.*;
import jakarta.validation.executable.ExecutableValidator;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator;

public class TradeApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    private static final String USER_AGENT =
            String.format(
                    "binance-derivatives-trading-usds-futures/6.0.0 (Java/%s; %s; %s)",
                    SystemUtil.getJavaVersion(), SystemUtil.getOs(), SystemUtil.getArch());
    private static final boolean HAS_TIME_UNIT = false;

    public TradeApi(ClientConfiguration clientConfiguration) {
        this(new ApiClient(clientConfiguration));
    }

    public TradeApi(ApiClient apiClient) {
        apiClient.setUserAgent(USER_AGENT);
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for accountTradeList
     *
     * @param symbol (required)
     * @param orderId (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param fromId ID to get aggregate trades from INCLUSIVE. (optional)
     * @param limit Default 100; max 1000 (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Account Trade List </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Account-Trade-List">Account
     *     Trade List (USER_DATA) Documentation</a>
     */
    private okhttp3.Call accountTradeListCall(
            String symbol,
            Long orderId,
            Long startTime,
            Long endTime,
            Long fromId,
            Long limit,
            Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/userTrades";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (orderId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderId", orderId));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (fromId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromId", fromId));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call accountTradeListValidateBeforeCall(
            String symbol,
            Long orderId,
            Long startTime,
            Long endTime,
            Long fromId,
            Long limit,
            Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {
                symbol, orderId, startTime, endTime, fromId, limit, recvWindow
            };
            Method method =
                    this.getClass()
                            .getMethod(
                                    "accountTradeList",
                                    String.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return accountTradeListCall(
                        symbol, orderId, startTime, endTime, fromId, limit, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Account Trade List (USER_DATA) Get trades for a specific account and symbol. * If
     * &#x60;startTime&#x60; and &#x60;endTime&#x60; are both not sent, then the last 7 days&#39;
     * data will be returned. * The time between &#x60;startTime&#x60; and &#x60;endTime&#x60;
     * cannot be longer than 7 days. * The parameter &#x60;fromId&#x60; cannot be sent with
     * &#x60;startTime&#x60; or &#x60;endTime&#x60;. * Only support querying trade in the past 6
     * months Weight: 5
     *
     * @param symbol (required)
     * @param orderId (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param fromId ID to get aggregate trades from INCLUSIVE. (optional)
     * @param limit Default 100; max 1000 (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;AccountTradeListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Account Trade List </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Account-Trade-List">Account
     *     Trade List (USER_DATA) Documentation</a>
     */
    public ApiResponse<AccountTradeListResponse> accountTradeList(
            @NotNull String symbol,
            Long orderId,
            Long startTime,
            Long endTime,
            Long fromId,
            Long limit,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                accountTradeListValidateBeforeCall(
                        symbol, orderId, startTime, endTime, fromId, limit, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<AccountTradeListResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for allOrders
     *
     * @param symbol (required)
     * @param orderId (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> All Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/All-Orders">All
     *     Orders (USER_DATA) Documentation</a>
     */
    private okhttp3.Call allOrdersCall(
            String symbol, Long orderId, Long startTime, Long endTime, Long limit, Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/allOrders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (orderId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderId", orderId));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call allOrdersValidateBeforeCall(
            String symbol, Long orderId, Long startTime, Long endTime, Long limit, Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, orderId, startTime, endTime, limit, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "allOrders",
                                    String.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return allOrdersCall(symbol, orderId, startTime, endTime, limit, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * All Orders (USER_DATA) Get all account orders; active, canceled, or filled. * These orders
     * will not be found: * order status is &#x60;CANCELED&#x60; or &#x60;EXPIRED&#x60; **AND**
     * order has NO filled trade **AND** created time + 3 days &lt; current time * order create time
     * + 90 days &lt; current time * If &#x60;orderId&#x60; is set, it will get orders &gt;&#x3D;
     * that &#x60;orderId&#x60;. Otherwise most recent orders are returned. * The query time period
     * must be less then 7 days( default as the recent 7 days). Weight: 5
     *
     * @param symbol (required)
     * @param orderId (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;AllOrdersResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> All Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/All-Orders">All
     *     Orders (USER_DATA) Documentation</a>
     */
    public ApiResponse<AllOrdersResponse> allOrders(
            @NotNull String symbol,
            Long orderId,
            Long startTime,
            Long endTime,
            Long limit,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                allOrdersValidateBeforeCall(symbol, orderId, startTime, endTime, limit, recvWindow);
        java.lang.reflect.Type localVarReturnType = new TypeToken<AllOrdersResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for autoCancelAllOpenOrders
     *
     * @param autoCancelAllOpenOrdersRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Auto-Cancel All Open Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Auto-Cancel-All-Open-Orders">Auto-Cancel
     *     All Open Orders (TRADE) Documentation</a>
     */
    private okhttp3.Call autoCancelAllOpenOrdersCall(
            AutoCancelAllOpenOrdersRequest autoCancelAllOpenOrdersRequest) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/countdownCancelAll";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (autoCancelAllOpenOrdersRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", autoCancelAllOpenOrdersRequest.getSymbol());
        }

        if (autoCancelAllOpenOrdersRequest.getCountdownTime() != null) {
            localVarFormParams.put(
                    "countdownTime", autoCancelAllOpenOrdersRequest.getCountdownTime());
        }

        if (autoCancelAllOpenOrdersRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", autoCancelAllOpenOrdersRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call autoCancelAllOpenOrdersValidateBeforeCall(
            AutoCancelAllOpenOrdersRequest autoCancelAllOpenOrdersRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {autoCancelAllOpenOrdersRequest};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "autoCancelAllOpenOrders",
                                    AutoCancelAllOpenOrdersRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return autoCancelAllOpenOrdersCall(autoCancelAllOpenOrdersRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Auto-Cancel All Open Orders (TRADE) Cancel all open orders of the specified symbol at the end
     * of the specified countdown. The endpoint should be called repeatedly as heartbeats so that
     * the existing countdown time can be canceled and replaced by a new one. * Example usage: Call
     * this endpoint at 30s intervals with an countdownTime of 120000 (120s). If this endpoint is
     * not called within 120 seconds, all your orders of the specified symbol will be automatically
     * canceled. If this endpoint is called with an countdownTime of 0, the countdown timer will be
     * stopped. The system will check all countdowns **approximately every 10 milliseconds**, so
     * please note that sufficient redundancy should be considered when using this function. We do
     * not recommend setting the countdown time to be too precise or too small. Weight: 10
     *
     * @param autoCancelAllOpenOrdersRequest (required)
     * @return ApiResponse&lt;AutoCancelAllOpenOrdersResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Auto-Cancel All Open Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Auto-Cancel-All-Open-Orders">Auto-Cancel
     *     All Open Orders (TRADE) Documentation</a>
     */
    public ApiResponse<AutoCancelAllOpenOrdersResponse> autoCancelAllOpenOrders(
            @Valid @NotNull AutoCancelAllOpenOrdersRequest autoCancelAllOpenOrdersRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                autoCancelAllOpenOrdersValidateBeforeCall(autoCancelAllOpenOrdersRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<AutoCancelAllOpenOrdersResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for cancelAllOpenOrders
     *
     * @param symbol (required)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cancel All Open Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Cancel-All-Open-Orders">Cancel
     *     All Open Orders (TRADE) Documentation</a>
     */
    private okhttp3.Call cancelAllOpenOrdersCall(String symbol, Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/allOpenOrders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "DELETE",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cancelAllOpenOrdersValidateBeforeCall(String symbol, Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, recvWindow};
            Method method =
                    this.getClass().getMethod("cancelAllOpenOrders", String.class, Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return cancelAllOpenOrdersCall(symbol, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Cancel All Open Orders (TRADE) Cancel All Open Orders Weight: 1
     *
     * @param symbol (required)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;CancelAllOpenOrdersResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cancel All Open Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Cancel-All-Open-Orders">Cancel
     *     All Open Orders (TRADE) Documentation</a>
     */
    public ApiResponse<CancelAllOpenOrdersResponse> cancelAllOpenOrders(
            @NotNull String symbol, Long recvWindow) throws ApiException {
        okhttp3.Call localVarCall = cancelAllOpenOrdersValidateBeforeCall(symbol, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<CancelAllOpenOrdersResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for cancelMultipleOrders
     *
     * @param symbol (required)
     * @param orderIdList max length 10 &lt;br /&gt; e.g. [1234567,2345678] (optional)
     * @param origClientOrderIdList max length 10&lt;br /&gt; e.g.
     *     [\&quot;my_id_1\&quot;,\&quot;my_id_2\&quot;], encode the double quotes. No space after
     *     comma. (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cancel Multiple Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Cancel-Multiple-Orders">Cancel
     *     Multiple Orders (TRADE) Documentation</a>
     */
    private okhttp3.Call cancelMultipleOrdersCall(
            String symbol,
            OrderIdList orderIdList,
            OrigClientOrderIdList origClientOrderIdList,
            Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/batchOrders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (orderIdList != null) {
            String json = JSON.getGson().toJson(orderIdList);
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderIdList", json));
        }

        if (origClientOrderIdList != null) {
            String json = JSON.getGson().toJson(origClientOrderIdList);
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("origClientOrderIdList", json));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "DELETE",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cancelMultipleOrdersValidateBeforeCall(
            String symbol,
            OrderIdList orderIdList,
            OrigClientOrderIdList origClientOrderIdList,
            Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, orderIdList, origClientOrderIdList, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "cancelMultipleOrders",
                                    String.class,
                                    OrderIdList.class,
                                    OrigClientOrderIdList.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return cancelMultipleOrdersCall(
                        symbol, orderIdList, origClientOrderIdList, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Cancel Multiple Orders (TRADE) Cancel Multiple Orders * Either &#x60;orderIdList&#x60; or
     * &#x60;origClientOrderIdList &#x60; must be sent. Weight: 1
     *
     * @param symbol (required)
     * @param orderIdList max length 10 &lt;br /&gt; e.g. [1234567,2345678] (optional)
     * @param origClientOrderIdList max length 10&lt;br /&gt; e.g.
     *     [\&quot;my_id_1\&quot;,\&quot;my_id_2\&quot;], encode the double quotes. No space after
     *     comma. (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;CancelMultipleOrdersResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cancel Multiple Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Cancel-Multiple-Orders">Cancel
     *     Multiple Orders (TRADE) Documentation</a>
     */
    public ApiResponse<CancelMultipleOrdersResponse> cancelMultipleOrders(
            @NotNull String symbol,
            OrderIdList orderIdList,
            OrigClientOrderIdList origClientOrderIdList,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                cancelMultipleOrdersValidateBeforeCall(
                        symbol, orderIdList, origClientOrderIdList, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<CancelMultipleOrdersResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for cancelOrder
     *
     * @param symbol (required)
     * @param orderId (optional)
     * @param origClientOrderId (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cancel Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Cancel-Order">Cancel
     *     Order (TRADE) Documentation</a>
     */
    private okhttp3.Call cancelOrderCall(
            String symbol, Long orderId, String origClientOrderId, Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/order";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (orderId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderId", orderId));
        }

        if (origClientOrderId != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("origClientOrderId", origClientOrderId));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "DELETE",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cancelOrderValidateBeforeCall(
            String symbol, Long orderId, String origClientOrderId, Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, orderId, origClientOrderId, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "cancelOrder",
                                    String.class,
                                    Long.class,
                                    String.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return cancelOrderCall(symbol, orderId, origClientOrderId, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Cancel Order (TRADE) Cancel an active order. * Either &#x60;orderId&#x60; or
     * &#x60;origClientOrderId&#x60; must be sent. Weight: 1
     *
     * @param symbol (required)
     * @param orderId (optional)
     * @param origClientOrderId (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;CancelOrderResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cancel Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Cancel-Order">Cancel
     *     Order (TRADE) Documentation</a>
     */
    public ApiResponse<CancelOrderResponse> cancelOrder(
            @NotNull String symbol, Long orderId, String origClientOrderId, Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                cancelOrderValidateBeforeCall(symbol, orderId, origClientOrderId, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<CancelOrderResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for changeInitialLeverage
     *
     * @param changeInitialLeverageRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Change Initial Leverage </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Change-Initial-Leverage">Change
     *     Initial Leverage(TRADE) Documentation</a>
     */
    private okhttp3.Call changeInitialLeverageCall(
            ChangeInitialLeverageRequest changeInitialLeverageRequest) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/leverage";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (changeInitialLeverageRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", changeInitialLeverageRequest.getSymbol());
        }

        if (changeInitialLeverageRequest.getLeverage() != null) {
            localVarFormParams.put("leverage", changeInitialLeverageRequest.getLeverage());
        }

        if (changeInitialLeverageRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", changeInitialLeverageRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call changeInitialLeverageValidateBeforeCall(
            ChangeInitialLeverageRequest changeInitialLeverageRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {changeInitialLeverageRequest};
            Method method =
                    this.getClass()
                            .getMethod("changeInitialLeverage", ChangeInitialLeverageRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return changeInitialLeverageCall(changeInitialLeverageRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Change Initial Leverage(TRADE) Change user&#39;s initial leverage of specific symbol market.
     * Weight: 1
     *
     * @param changeInitialLeverageRequest (required)
     * @return ApiResponse&lt;ChangeInitialLeverageResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Change Initial Leverage </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Change-Initial-Leverage">Change
     *     Initial Leverage(TRADE) Documentation</a>
     */
    public ApiResponse<ChangeInitialLeverageResponse> changeInitialLeverage(
            @Valid @NotNull ChangeInitialLeverageRequest changeInitialLeverageRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                changeInitialLeverageValidateBeforeCall(changeInitialLeverageRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<ChangeInitialLeverageResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for changeMarginType
     *
     * @param changeMarginTypeRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Change Margin Type </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Change-Margin-Type">Change
     *     Margin Type(TRADE) Documentation</a>
     */
    private okhttp3.Call changeMarginTypeCall(ChangeMarginTypeRequest changeMarginTypeRequest)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/marginType";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (changeMarginTypeRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", changeMarginTypeRequest.getSymbol());
        }

        if (changeMarginTypeRequest.getMarginType() != null) {
            localVarFormParams.put("marginType", changeMarginTypeRequest.getMarginType());
        }

        if (changeMarginTypeRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", changeMarginTypeRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call changeMarginTypeValidateBeforeCall(
            ChangeMarginTypeRequest changeMarginTypeRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {changeMarginTypeRequest};
            Method method =
                    this.getClass().getMethod("changeMarginType", ChangeMarginTypeRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return changeMarginTypeCall(changeMarginTypeRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Change Margin Type(TRADE) Change symbol level margin type Weight: 1
     *
     * @param changeMarginTypeRequest (required)
     * @return ApiResponse&lt;ChangeMarginTypeResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Change Margin Type </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Change-Margin-Type">Change
     *     Margin Type(TRADE) Documentation</a>
     */
    public ApiResponse<ChangeMarginTypeResponse> changeMarginType(
            @Valid @NotNull ChangeMarginTypeRequest changeMarginTypeRequest) throws ApiException {
        okhttp3.Call localVarCall = changeMarginTypeValidateBeforeCall(changeMarginTypeRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<ChangeMarginTypeResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for changeMultiAssetsMode
     *
     * @param changeMultiAssetsModeRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Change Multi-Assets Mode </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Change-Multi-Assets-Mode">Change
     *     Multi-Assets Mode (TRADE) Documentation</a>
     */
    private okhttp3.Call changeMultiAssetsModeCall(
            ChangeMultiAssetsModeRequest changeMultiAssetsModeRequest) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/multiAssetsMargin";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (changeMultiAssetsModeRequest.getMultiAssetsMargin() != null) {
            localVarFormParams.put(
                    "multiAssetsMargin", changeMultiAssetsModeRequest.getMultiAssetsMargin());
        }

        if (changeMultiAssetsModeRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", changeMultiAssetsModeRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call changeMultiAssetsModeValidateBeforeCall(
            ChangeMultiAssetsModeRequest changeMultiAssetsModeRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {changeMultiAssetsModeRequest};
            Method method =
                    this.getClass()
                            .getMethod("changeMultiAssetsMode", ChangeMultiAssetsModeRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return changeMultiAssetsModeCall(changeMultiAssetsModeRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Change Multi-Assets Mode (TRADE) Change user&#39;s Multi-Assets mode (Multi-Assets Mode or
     * Single-Asset Mode) on ***Every symbol*** Weight: 1
     *
     * @param changeMultiAssetsModeRequest (required)
     * @return ApiResponse&lt;ChangeMultiAssetsModeResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Change Multi-Assets Mode </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Change-Multi-Assets-Mode">Change
     *     Multi-Assets Mode (TRADE) Documentation</a>
     */
    public ApiResponse<ChangeMultiAssetsModeResponse> changeMultiAssetsMode(
            @Valid @NotNull ChangeMultiAssetsModeRequest changeMultiAssetsModeRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                changeMultiAssetsModeValidateBeforeCall(changeMultiAssetsModeRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<ChangeMultiAssetsModeResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for changePositionMode
     *
     * @param changePositionModeRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Change Position Mode </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Change-Position-Mode">Change
     *     Position Mode(TRADE) Documentation</a>
     */
    private okhttp3.Call changePositionModeCall(ChangePositionModeRequest changePositionModeRequest)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/positionSide/dual";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (changePositionModeRequest.getDualSidePosition() != null) {
            localVarFormParams.put(
                    "dualSidePosition", changePositionModeRequest.getDualSidePosition());
        }

        if (changePositionModeRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", changePositionModeRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call changePositionModeValidateBeforeCall(
            ChangePositionModeRequest changePositionModeRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {changePositionModeRequest};
            Method method =
                    this.getClass()
                            .getMethod("changePositionMode", ChangePositionModeRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return changePositionModeCall(changePositionModeRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Change Position Mode(TRADE) Change user&#39;s position mode (Hedge Mode or One-way Mode ) on
     * ***EVERY symbol*** Weight: 1
     *
     * @param changePositionModeRequest (required)
     * @return ApiResponse&lt;ChangePositionModeResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Change Position Mode </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Change-Position-Mode">Change
     *     Position Mode(TRADE) Documentation</a>
     */
    public ApiResponse<ChangePositionModeResponse> changePositionMode(
            @Valid @NotNull ChangePositionModeRequest changePositionModeRequest)
            throws ApiException {
        okhttp3.Call localVarCall = changePositionModeValidateBeforeCall(changePositionModeRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<ChangePositionModeResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for currentAllOpenOrders
     *
     * @param symbol (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Current All Open Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Current-All-Open-Orders">Current
     *     All Open Orders (USER_DATA) Documentation</a>
     */
    private okhttp3.Call currentAllOpenOrdersCall(String symbol, Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/openOrders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call currentAllOpenOrdersValidateBeforeCall(String symbol, Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, recvWindow};
            Method method =
                    this.getClass().getMethod("currentAllOpenOrders", String.class, Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return currentAllOpenOrdersCall(symbol, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Current All Open Orders (USER_DATA) Get all open orders on a symbol. * If the symbol is not
     * sent, orders for all symbols will be returned in an array. Weight: 1 for a single symbol; 40
     * when the symbol parameter is omitted Careful when accessing this with no symbol.
     *
     * @param symbol (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;CurrentAllOpenOrdersResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Current All Open Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Current-All-Open-Orders">Current
     *     All Open Orders (USER_DATA) Documentation</a>
     */
    public ApiResponse<CurrentAllOpenOrdersResponse> currentAllOpenOrders(
            String symbol, Long recvWindow) throws ApiException {
        okhttp3.Call localVarCall = currentAllOpenOrdersValidateBeforeCall(symbol, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<CurrentAllOpenOrdersResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for getOrderModifyHistory
     *
     * @param symbol (required)
     * @param orderId (optional)
     * @param origClientOrderId (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Get Order Modify History </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Get-Order-Modify-History">Get
     *     Order Modify History (USER_DATA) Documentation</a>
     */
    private okhttp3.Call getOrderModifyHistoryCall(
            String symbol,
            Long orderId,
            String origClientOrderId,
            Long startTime,
            Long endTime,
            Long limit,
            Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/orderAmendment";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (orderId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderId", orderId));
        }

        if (origClientOrderId != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("origClientOrderId", origClientOrderId));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getOrderModifyHistoryValidateBeforeCall(
            String symbol,
            Long orderId,
            String origClientOrderId,
            Long startTime,
            Long endTime,
            Long limit,
            Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {
                symbol, orderId, origClientOrderId, startTime, endTime, limit, recvWindow
            };
            Method method =
                    this.getClass()
                            .getMethod(
                                    "getOrderModifyHistory",
                                    String.class,
                                    Long.class,
                                    String.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return getOrderModifyHistoryCall(
                        symbol, orderId, origClientOrderId, startTime, endTime, limit, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Get Order Modify History (USER_DATA) Get order modification history * Either
     * &#x60;orderId&#x60; or &#x60;origClientOrderId&#x60; must be sent, and the
     * &#x60;orderId&#x60; will prevail if both are sent. * Order modify history longer than 3 month
     * is not avaliable Weight: 1
     *
     * @param symbol (required)
     * @param orderId (optional)
     * @param origClientOrderId (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;GetOrderModifyHistoryResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Get Order Modify History </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Get-Order-Modify-History">Get
     *     Order Modify History (USER_DATA) Documentation</a>
     */
    public ApiResponse<GetOrderModifyHistoryResponse> getOrderModifyHistory(
            @NotNull String symbol,
            Long orderId,
            String origClientOrderId,
            Long startTime,
            Long endTime,
            Long limit,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                getOrderModifyHistoryValidateBeforeCall(
                        symbol, orderId, origClientOrderId, startTime, endTime, limit, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<GetOrderModifyHistoryResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for getPositionMarginChangeHistory
     *
     * @param symbol (required)
     * @param type 1: Add position margin2: Reduce position margin (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Get Position Margin Change History </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Get-Position-Margin-Change-History">Get
     *     Position Margin Change History (TRADE) Documentation</a>
     */
    private okhttp3.Call getPositionMarginChangeHistoryCall(
            String symbol, String type, Long startTime, Long endTime, Long limit, Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/positionMargin/history";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (type != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("type", type));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPositionMarginChangeHistoryValidateBeforeCall(
            String symbol, String type, Long startTime, Long endTime, Long limit, Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, type, startTime, endTime, limit, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "getPositionMarginChangeHistory",
                                    String.class,
                                    String.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return getPositionMarginChangeHistoryCall(
                        symbol, type, startTime, endTime, limit, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Get Position Margin Change History (TRADE) Get Position Margin Change History * Support
     * querying future histories that are not older than 30 days * The time between
     * &#x60;startTime&#x60; and &#x60;endTime&#x60;can&#39;t be more than 30 days Weight: 1
     *
     * @param symbol (required)
     * @param type 1: Add position margin2: Reduce position margin (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;GetPositionMarginChangeHistoryResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Get Position Margin Change History </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Get-Position-Margin-Change-History">Get
     *     Position Margin Change History (TRADE) Documentation</a>
     */
    public ApiResponse<GetPositionMarginChangeHistoryResponse> getPositionMarginChangeHistory(
            @NotNull String symbol,
            String type,
            Long startTime,
            Long endTime,
            Long limit,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                getPositionMarginChangeHistoryValidateBeforeCall(
                        symbol, type, startTime, endTime, limit, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<GetPositionMarginChangeHistoryResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for modifyIsolatedPositionMargin
     *
     * @param modifyIsolatedPositionMarginRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Modify Isolated Position Margin </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Modify-Isolated-Position-Margin">Modify
     *     Isolated Position Margin(TRADE) Documentation</a>
     */
    private okhttp3.Call modifyIsolatedPositionMarginCall(
            ModifyIsolatedPositionMarginRequest modifyIsolatedPositionMarginRequest)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/positionMargin";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (modifyIsolatedPositionMarginRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", modifyIsolatedPositionMarginRequest.getSymbol());
        }

        if (modifyIsolatedPositionMarginRequest.getPositionSide() != null) {
            localVarFormParams.put(
                    "positionSide", modifyIsolatedPositionMarginRequest.getPositionSide());
        }

        if (modifyIsolatedPositionMarginRequest.getAmount() != null) {
            localVarFormParams.put(
                    "amount",
                    DecimalFormatter.getFormatter()
                            .format(modifyIsolatedPositionMarginRequest.getAmount()));
        }

        if (modifyIsolatedPositionMarginRequest.getType() != null) {
            localVarFormParams.put("type", modifyIsolatedPositionMarginRequest.getType());
        }

        if (modifyIsolatedPositionMarginRequest.getRecvWindow() != null) {
            localVarFormParams.put(
                    "recvWindow", modifyIsolatedPositionMarginRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call modifyIsolatedPositionMarginValidateBeforeCall(
            ModifyIsolatedPositionMarginRequest modifyIsolatedPositionMarginRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {modifyIsolatedPositionMarginRequest};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "modifyIsolatedPositionMargin",
                                    ModifyIsolatedPositionMarginRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return modifyIsolatedPositionMarginCall(modifyIsolatedPositionMarginRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Modify Isolated Position Margin(TRADE) Modify Isolated Position Margin * Only for isolated
     * symbol Weight: 1
     *
     * @param modifyIsolatedPositionMarginRequest (required)
     * @return ApiResponse&lt;ModifyIsolatedPositionMarginResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Modify Isolated Position Margin </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Modify-Isolated-Position-Margin">Modify
     *     Isolated Position Margin(TRADE) Documentation</a>
     */
    public ApiResponse<ModifyIsolatedPositionMarginResponse> modifyIsolatedPositionMargin(
            @Valid @NotNull ModifyIsolatedPositionMarginRequest modifyIsolatedPositionMarginRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                modifyIsolatedPositionMarginValidateBeforeCall(modifyIsolatedPositionMarginRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<ModifyIsolatedPositionMarginResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for modifyMultipleOrders
     *
     * @param modifyMultipleOrdersRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Modify Multiple Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Modify-Multiple-Orders">Modify
     *     Multiple Orders(TRADE) Documentation</a>
     */
    private okhttp3.Call modifyMultipleOrdersCall(
            ModifyMultipleOrdersRequest modifyMultipleOrdersRequest) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/batchOrders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (modifyMultipleOrdersRequest.getBatchOrders() != null) {
            String json = JSON.getGson().toJson(modifyMultipleOrdersRequest.getBatchOrders());
            localVarFormParams.put("batchOrders", json);
        }

        if (modifyMultipleOrdersRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", modifyMultipleOrdersRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "PUT",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call modifyMultipleOrdersValidateBeforeCall(
            ModifyMultipleOrdersRequest modifyMultipleOrdersRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {modifyMultipleOrdersRequest};
            Method method =
                    this.getClass()
                            .getMethod("modifyMultipleOrders", ModifyMultipleOrdersRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return modifyMultipleOrdersCall(modifyMultipleOrdersRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Modify Multiple Orders(TRADE) Modify Multiple Orders (TRADE) * Parameter rules are same with
     * &#x60;Modify Order&#x60; * Batch modify orders are processed concurrently, and the order of
     * matching is not guaranteed. * The order of returned contents for batch modify orders is the
     * same as the order of the order list. * One order can only be modfied for less than 10000
     * times Weight: 5 on 10s order rate limit(X-MBX-ORDER-COUNT-10S); 1 on 1min order rate
     * limit(X-MBX-ORDER-COUNT-1M); 5 on IP rate limit(x-mbx-used-weight-1m);
     *
     * @param modifyMultipleOrdersRequest (required)
     * @return ApiResponse&lt;ModifyMultipleOrdersResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Modify Multiple Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Modify-Multiple-Orders">Modify
     *     Multiple Orders(TRADE) Documentation</a>
     */
    public ApiResponse<ModifyMultipleOrdersResponse> modifyMultipleOrders(
            @Valid @NotNull ModifyMultipleOrdersRequest modifyMultipleOrdersRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                modifyMultipleOrdersValidateBeforeCall(modifyMultipleOrdersRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<ModifyMultipleOrdersResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for modifyOrder
     *
     * @param modifyOrderRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Modify Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Modify-Order">Modify
     *     Order (TRADE) Documentation</a>
     */
    private okhttp3.Call modifyOrderCall(ModifyOrderRequest modifyOrderRequest)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/order";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (modifyOrderRequest.getOrderId() != null) {
            localVarFormParams.put("orderId", modifyOrderRequest.getOrderId());
        }

        if (modifyOrderRequest.getOrigClientOrderId() != null) {
            localVarFormParams.put("origClientOrderId", modifyOrderRequest.getOrigClientOrderId());
        }

        if (modifyOrderRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", modifyOrderRequest.getSymbol());
        }

        if (modifyOrderRequest.getSide() != null) {
            localVarFormParams.put("side", modifyOrderRequest.getSide());
        }

        if (modifyOrderRequest.getQuantity() != null) {
            localVarFormParams.put(
                    "quantity",
                    DecimalFormatter.getFormatter().format(modifyOrderRequest.getQuantity()));
        }

        if (modifyOrderRequest.getPrice() != null) {
            localVarFormParams.put(
                    "price", DecimalFormatter.getFormatter().format(modifyOrderRequest.getPrice()));
        }

        if (modifyOrderRequest.getPriceMatch() != null) {
            localVarFormParams.put("priceMatch", modifyOrderRequest.getPriceMatch());
        }

        if (modifyOrderRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", modifyOrderRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "PUT",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call modifyOrderValidateBeforeCall(ModifyOrderRequest modifyOrderRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {modifyOrderRequest};
            Method method = this.getClass().getMethod("modifyOrder", ModifyOrderRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return modifyOrderCall(modifyOrderRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Modify Order (TRADE) Order modify function, currently only LIMIT order modification is
     * supported, modified orders will be reordered in the match queue * Either &#x60;orderId&#x60;
     * or &#x60;origClientOrderId&#x60; must be sent, and the &#x60;orderId&#x60; will prevail if
     * both are sent. * Both &#x60;quantity&#x60; and &#x60;price&#x60; must be sent, which is
     * different from dapi modify order endpoint. * When the new &#x60;quantity&#x60; or
     * &#x60;price&#x60; doesn&#39;t satisfy PRICE_FILTER / PERCENT_FILTER / LOT_SIZE, amendment
     * will be rejected and the order will stay as it is. * However the order will be cancelled by
     * the amendment in the following situations: * when the order is in partially filled status and
     * the new &#x60;quantity&#x60; &lt;&#x3D; &#x60;executedQty&#x60; * When the order is
     * &#x60;GTX&#x60; and the new price will cause it to be executed immediately * One order can
     * only be modfied for less than 10000 times Weight: 1 on 10s order rate
     * limit(X-MBX-ORDER-COUNT-10S); 1 on 1min order rate limit(X-MBX-ORDER-COUNT-1M); 0 on IP rate
     * limit(x-mbx-used-weight-1m)
     *
     * @param modifyOrderRequest (required)
     * @return ApiResponse&lt;ModifyOrderResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Modify Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Modify-Order">Modify
     *     Order (TRADE) Documentation</a>
     */
    public ApiResponse<ModifyOrderResponse> modifyOrder(
            @Valid @NotNull ModifyOrderRequest modifyOrderRequest) throws ApiException {
        okhttp3.Call localVarCall = modifyOrderValidateBeforeCall(modifyOrderRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<ModifyOrderResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for newOrder
     *
     * @param newOrderRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> New Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/New-Order">New
     *     Order(TRADE) Documentation</a>
     */
    private okhttp3.Call newOrderCall(NewOrderRequest newOrderRequest) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/order";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (newOrderRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", newOrderRequest.getSymbol());
        }

        if (newOrderRequest.getSide() != null) {
            localVarFormParams.put("side", newOrderRequest.getSide());
        }

        if (newOrderRequest.getPositionSide() != null) {
            localVarFormParams.put("positionSide", newOrderRequest.getPositionSide());
        }

        if (newOrderRequest.getType() != null) {
            localVarFormParams.put("type", newOrderRequest.getType());
        }

        if (newOrderRequest.getTimeInForce() != null) {
            localVarFormParams.put("timeInForce", newOrderRequest.getTimeInForce());
        }

        if (newOrderRequest.getQuantity() != null) {
            localVarFormParams.put(
                    "quantity",
                    DecimalFormatter.getFormatter().format(newOrderRequest.getQuantity()));
        }

        if (newOrderRequest.getReduceOnly() != null) {
            localVarFormParams.put("reduceOnly", newOrderRequest.getReduceOnly());
        }

        if (newOrderRequest.getPrice() != null) {
            localVarFormParams.put(
                    "price", DecimalFormatter.getFormatter().format(newOrderRequest.getPrice()));
        }

        if (newOrderRequest.getNewClientOrderId() != null) {
            localVarFormParams.put("newClientOrderId", newOrderRequest.getNewClientOrderId());
        }

        if (newOrderRequest.getStopPrice() != null) {
            localVarFormParams.put(
                    "stopPrice",
                    DecimalFormatter.getFormatter().format(newOrderRequest.getStopPrice()));
        }

        if (newOrderRequest.getClosePosition() != null) {
            localVarFormParams.put("closePosition", newOrderRequest.getClosePosition());
        }

        if (newOrderRequest.getActivationPrice() != null) {
            localVarFormParams.put(
                    "activationPrice",
                    DecimalFormatter.getFormatter().format(newOrderRequest.getActivationPrice()));
        }

        if (newOrderRequest.getCallbackRate() != null) {
            localVarFormParams.put(
                    "callbackRate",
                    DecimalFormatter.getFormatter().format(newOrderRequest.getCallbackRate()));
        }

        if (newOrderRequest.getWorkingType() != null) {
            localVarFormParams.put("workingType", newOrderRequest.getWorkingType());
        }

        if (newOrderRequest.getPriceProtect() != null) {
            localVarFormParams.put("priceProtect", newOrderRequest.getPriceProtect());
        }

        if (newOrderRequest.getNewOrderRespType() != null) {
            localVarFormParams.put("newOrderRespType", newOrderRequest.getNewOrderRespType());
        }

        if (newOrderRequest.getPriceMatch() != null) {
            localVarFormParams.put("priceMatch", newOrderRequest.getPriceMatch());
        }

        if (newOrderRequest.getSelfTradePreventionMode() != null) {
            localVarFormParams.put(
                    "selfTradePreventionMode", newOrderRequest.getSelfTradePreventionMode());
        }

        if (newOrderRequest.getGoodTillDate() != null) {
            localVarFormParams.put("goodTillDate", newOrderRequest.getGoodTillDate());
        }

        if (newOrderRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", newOrderRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call newOrderValidateBeforeCall(NewOrderRequest newOrderRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {newOrderRequest};
            Method method = this.getClass().getMethod("newOrder", NewOrderRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return newOrderCall(newOrderRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * New Order(TRADE) Send in a new order. * Order with type &#x60;STOP&#x60;, parameter
     * &#x60;timeInForce&#x60; can be sent ( default &#x60;GTC&#x60;). * Order with type
     * &#x60;TAKE_PROFIT&#x60;, parameter &#x60;timeInForce&#x60; can be sent ( default
     * &#x60;GTC&#x60;). * Condition orders will be triggered when: * If
     * parameter&#x60;priceProtect&#x60;is sent as true: * when price reaches the
     * &#x60;stopPrice&#x60; the difference rate between \&quot;MARK_PRICE\&quot; and
     * \&quot;CONTRACT_PRICE\&quot; cannot be larger than the \&quot;triggerProtect\&quot; of the
     * symbol * \&quot;triggerProtect\&quot; of a symbol can be got from &#x60;GET
     * /fapi/v1/exchangeInfo&#x60; * &#x60;STOP&#x60;, &#x60;STOP_MARKET&#x60;: * BUY: latest price
     * (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &gt;&#x3D; &#x60;stopPrice&#x60; *
     * SELL: latest price (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &lt;&#x3D;
     * &#x60;stopPrice&#x60; * &#x60;TAKE_PROFIT&#x60;, &#x60;TAKE_PROFIT_MARKET&#x60;: * BUY:
     * latest price (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &lt;&#x3D;
     * &#x60;stopPrice&#x60; * SELL: latest price (\&quot;MARK_PRICE\&quot; or
     * \&quot;CONTRACT_PRICE\&quot;) &gt;&#x3D; &#x60;stopPrice&#x60; *
     * &#x60;TRAILING_STOP_MARKET&#x60;: * BUY: the lowest price after order placed &#x60;&lt;&#x3D;
     * &#x60;activationPrice&#x60;, and the latest price &gt;&#x60;&#x3D; the lowest price * (1 +
     * &#x60;callbackRate&#x60;) * SELL: the highest price after order placed &gt;&#x3D;
     * &#x60;activationPrice&#x60;, and the latest price &lt;&#x3D; the highest price * (1 -
     * &#x60;callbackRate&#x60;) * For &#x60;TRAILING_STOP_MARKET&#x60;, if you got such error code.
     * &#x60;&#x60;{\&quot;code\&quot;: -2021, \&quot;msg\&quot;: \&quot;Order would immediately
     * trigger.\&quot;}&#x60;&#x60; means that the parameters you send do not meet the following
     * requirements: * BUY: &#x60;activationPrice&#x60; should be smaller than latest price. * SELL:
     * &#x60;activationPrice&#x60; should be larger than latest price. * If &#x60;newOrderRespType
     * &#x60; is sent as &#x60;RESULT&#x60; : * &#x60;MARKET&#x60; order: the final FILLED result of
     * the order will be return directly. * &#x60;LIMIT&#x60; order with special
     * &#x60;timeInForce&#x60;: the final status result of the order(FILLED or EXPIRED) will be
     * returned directly. * &#x60;STOP_MARKET&#x60;, &#x60;TAKE_PROFIT_MARKET&#x60; with
     * &#x60;closePosition&#x60;&#x3D;&#x60;true&#x60;: * Follow the same rules for condition
     * orders. * If triggered**close all** current long position( if &#x60;SELL&#x60;) or current
     * short position( if &#x60;BUY&#x60;). * Cannot be used with &#x60;quantity&#x60; paremeter *
     * Cannot be used with &#x60;reduceOnly&#x60; parameter * In Hedge Mode,cannot be used with
     * &#x60;BUY&#x60; orders in &#x60;LONG&#x60; position side. and cannot be used with
     * &#x60;SELL&#x60; orders in &#x60;SHORT&#x60; position side *
     * &#x60;selfTradePreventionMode&#x60; is only effective when &#x60;timeInForce&#x60; set to
     * &#x60;IOC&#x60; or &#x60;GTC&#x60; or &#x60;GTD&#x60;. * In extreme market conditions,
     * timeInForce &#x60;GTD&#x60; order auto cancel time might be delayed comparing to
     * &#x60;goodTillDate&#x60; Weight: 1 on 10s order rate limit(X-MBX-ORDER-COUNT-10S); 1 on 1min
     * order rate limit(X-MBX-ORDER-COUNT-1M); 0 on IP rate limit(x-mbx-used-weight-1m)
     *
     * @param newOrderRequest (required)
     * @return ApiResponse&lt;NewOrderResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> New Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/New-Order">New
     *     Order(TRADE) Documentation</a>
     */
    public ApiResponse<NewOrderResponse> newOrder(@Valid @NotNull NewOrderRequest newOrderRequest)
            throws ApiException {
        okhttp3.Call localVarCall = newOrderValidateBeforeCall(newOrderRequest);
        java.lang.reflect.Type localVarReturnType = new TypeToken<NewOrderResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for placeMultipleOrders
     *
     * @param placeMultipleOrdersRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Place Multiple Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Place-Multiple-Orders">Place
     *     Multiple Orders(TRADE) Documentation</a>
     */
    private okhttp3.Call placeMultipleOrdersCall(
            PlaceMultipleOrdersRequest placeMultipleOrdersRequest) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/batchOrders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (placeMultipleOrdersRequest.getBatchOrders() != null) {
            String json = JSON.getGson().toJson(placeMultipleOrdersRequest.getBatchOrders());
            localVarFormParams.put("batchOrders", json);
        }

        if (placeMultipleOrdersRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", placeMultipleOrdersRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call placeMultipleOrdersValidateBeforeCall(
            PlaceMultipleOrdersRequest placeMultipleOrdersRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {placeMultipleOrdersRequest};
            Method method =
                    this.getClass()
                            .getMethod("placeMultipleOrders", PlaceMultipleOrdersRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return placeMultipleOrdersCall(placeMultipleOrdersRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Place Multiple Orders(TRADE) Place Multiple Orders * Paremeter rules are same with &#x60;New
     * Order&#x60; * Batch orders are processed concurrently, and the order of matching is not
     * guaranteed. * The order of returned contents for batch orders is the same as the order of the
     * order list. Weight: 5 on 10s order rate limit(X-MBX-ORDER-COUNT-10S); 1 on 1min order rate
     * limit(X-MBX-ORDER-COUNT-1M); 5 on IP rate limit(x-mbx-used-weight-1m);
     *
     * @param placeMultipleOrdersRequest (required)
     * @return ApiResponse&lt;PlaceMultipleOrdersResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Place Multiple Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Place-Multiple-Orders">Place
     *     Multiple Orders(TRADE) Documentation</a>
     */
    public ApiResponse<PlaceMultipleOrdersResponse> placeMultipleOrders(
            @Valid @NotNull PlaceMultipleOrdersRequest placeMultipleOrdersRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                placeMultipleOrdersValidateBeforeCall(placeMultipleOrdersRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<PlaceMultipleOrdersResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for positionAdlQuantileEstimation
     *
     * @param symbol (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Position ADL Quantile Estimation </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Position-ADL-Quantile-Estimation">Position
     *     ADL Quantile Estimation(USER_DATA) Documentation</a>
     */
    private okhttp3.Call positionAdlQuantileEstimationCall(String symbol, Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/adlQuantile";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call positionAdlQuantileEstimationValidateBeforeCall(
            String symbol, Long recvWindow) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod("positionAdlQuantileEstimation", String.class, Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return positionAdlQuantileEstimationCall(symbol, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Position ADL Quantile Estimation(USER_DATA) Position ADL Quantile Estimation * Values update
     * every 30s. * Values 0, 1, 2, 3, 4 shows the queue position and possibility of ADL from low to
     * high. * For positions of the symbol are in One-way Mode or isolated margined in Hedge Mode,
     * \&quot;LONG\&quot;, \&quot;SHORT\&quot;, and \&quot;BOTH\&quot; will be returned to show the
     * positions&#39; adl quantiles of different position sides. * If the positions of the symbol
     * are crossed margined in Hedge Mode: * \&quot;HEDGE\&quot; as a sign will be returned instead
     * of \&quot;BOTH\&quot;; * A same value caculated on unrealized pnls on long and short
     * sides&#39; positions will be shown for \&quot;LONG\&quot; and \&quot;SHORT\&quot; when there
     * are positions in both of long and short sides. Weight: 5
     *
     * @param symbol (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;PositionAdlQuantileEstimationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Position ADL Quantile Estimation </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Position-ADL-Quantile-Estimation">Position
     *     ADL Quantile Estimation(USER_DATA) Documentation</a>
     */
    public ApiResponse<PositionAdlQuantileEstimationResponse> positionAdlQuantileEstimation(
            String symbol, Long recvWindow) throws ApiException {
        okhttp3.Call localVarCall =
                positionAdlQuantileEstimationValidateBeforeCall(symbol, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<PositionAdlQuantileEstimationResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for positionInformationV2
     *
     * @param symbol (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Position Information V2 </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Position-Information-V2">Position
     *     Information V2 (USER_DATA) Documentation</a>
     */
    private okhttp3.Call positionInformationV2Call(String symbol, Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v2/positionRisk";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call positionInformationV2ValidateBeforeCall(String symbol, Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, recvWindow};
            Method method =
                    this.getClass().getMethod("positionInformationV2", String.class, Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return positionInformationV2Call(symbol, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Position Information V2 (USER_DATA) Get current position information. Please use with user
     * data stream &#x60;ACCOUNT_UPDATE&#x60; to meet your timeliness and accuracy needs. Weight: 5
     *
     * @param symbol (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;PositionInformationV2Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Position Information V2 </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Position-Information-V2">Position
     *     Information V2 (USER_DATA) Documentation</a>
     */
    public ApiResponse<PositionInformationV2Response> positionInformationV2(
            String symbol, Long recvWindow) throws ApiException {
        okhttp3.Call localVarCall = positionInformationV2ValidateBeforeCall(symbol, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<PositionInformationV2Response>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for positionInformationV3
     *
     * @param symbol (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Position Information V3 </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Position-Information-V3">Position
     *     Information V3 (USER_DATA) Documentation</a>
     */
    private okhttp3.Call positionInformationV3Call(String symbol, Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v3/positionRisk";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call positionInformationV3ValidateBeforeCall(String symbol, Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, recvWindow};
            Method method =
                    this.getClass().getMethod("positionInformationV3", String.class, Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return positionInformationV3Call(symbol, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Position Information V3 (USER_DATA) Get current position information(only symbol that has
     * position or open orders will be returned). Please use with user data stream
     * &#x60;ACCOUNT_UPDATE&#x60; to meet your timeliness and accuracy needs. Weight: 5
     *
     * @param symbol (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;PositionInformationV3Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Position Information V3 </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Position-Information-V3">Position
     *     Information V3 (USER_DATA) Documentation</a>
     */
    public ApiResponse<PositionInformationV3Response> positionInformationV3(
            String symbol, Long recvWindow) throws ApiException {
        okhttp3.Call localVarCall = positionInformationV3ValidateBeforeCall(symbol, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<PositionInformationV3Response>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for queryCurrentOpenOrder
     *
     * @param symbol (required)
     * @param orderId (optional)
     * @param origClientOrderId (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Current Open Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Query-Current-Open-Order">Query
     *     Current Open Order (USER_DATA) Documentation</a>
     */
    private okhttp3.Call queryCurrentOpenOrderCall(
            String symbol, Long orderId, String origClientOrderId, Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/openOrder";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (orderId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderId", orderId));
        }

        if (origClientOrderId != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("origClientOrderId", origClientOrderId));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryCurrentOpenOrderValidateBeforeCall(
            String symbol, Long orderId, String origClientOrderId, Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, orderId, origClientOrderId, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "queryCurrentOpenOrder",
                                    String.class,
                                    Long.class,
                                    String.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return queryCurrentOpenOrderCall(symbol, orderId, origClientOrderId, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Query Current Open Order (USER_DATA) Query open order * Either&#x60;orderId&#x60; or
     * &#x60;origClientOrderId&#x60; must be sent * If the queried order has been filled or
     * cancelled, the error message \&quot;Order does not exist\&quot; will be returned. Weight: 1
     *
     * @param symbol (required)
     * @param orderId (optional)
     * @param origClientOrderId (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;QueryCurrentOpenOrderResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Current Open Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Query-Current-Open-Order">Query
     *     Current Open Order (USER_DATA) Documentation</a>
     */
    public ApiResponse<QueryCurrentOpenOrderResponse> queryCurrentOpenOrder(
            @NotNull String symbol, Long orderId, String origClientOrderId, Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                queryCurrentOpenOrderValidateBeforeCall(
                        symbol, orderId, origClientOrderId, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<QueryCurrentOpenOrderResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for queryOrder
     *
     * @param symbol (required)
     * @param orderId (optional)
     * @param origClientOrderId (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Query-Order">Query
     *     Order (USER_DATA) Documentation</a>
     */
    private okhttp3.Call queryOrderCall(
            String symbol, Long orderId, String origClientOrderId, Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/order";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (orderId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderId", orderId));
        }

        if (origClientOrderId != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("origClientOrderId", origClientOrderId));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryOrderValidateBeforeCall(
            String symbol, Long orderId, String origClientOrderId, Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, orderId, origClientOrderId, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "queryOrder",
                                    String.class,
                                    Long.class,
                                    String.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return queryOrderCall(symbol, orderId, origClientOrderId, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Query Order (USER_DATA) Check an order&#39;s status. * These orders will not be found: *
     * order status is &#x60;CANCELED&#x60; or &#x60;EXPIRED&#x60; **AND** order has NO filled trade
     * **AND** created time + 3 days &lt; current time * order create time + 90 days &lt; current
     * time * Either &#x60;orderId&#x60; or &#x60;origClientOrderId&#x60; must be sent. *
     * &#x60;orderId&#x60; is self-increment for each specific &#x60;symbol&#x60; Weight: 1
     *
     * @param symbol (required)
     * @param orderId (optional)
     * @param origClientOrderId (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;QueryOrderResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Query-Order">Query
     *     Order (USER_DATA) Documentation</a>
     */
    public ApiResponse<QueryOrderResponse> queryOrder(
            @NotNull String symbol, Long orderId, String origClientOrderId, Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                queryOrderValidateBeforeCall(symbol, orderId, origClientOrderId, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<QueryOrderResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for testOrder
     *
     * @param testOrderRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Test Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/New-Order-Test">Test
     *     Order(TRADE) Documentation</a>
     */
    private okhttp3.Call testOrderCall(TestOrderRequest testOrderRequest) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/order/test";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (testOrderRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", testOrderRequest.getSymbol());
        }

        if (testOrderRequest.getSide() != null) {
            localVarFormParams.put("side", testOrderRequest.getSide());
        }

        if (testOrderRequest.getPositionSide() != null) {
            localVarFormParams.put("positionSide", testOrderRequest.getPositionSide());
        }

        if (testOrderRequest.getType() != null) {
            localVarFormParams.put("type", testOrderRequest.getType());
        }

        if (testOrderRequest.getTimeInForce() != null) {
            localVarFormParams.put("timeInForce", testOrderRequest.getTimeInForce());
        }

        if (testOrderRequest.getQuantity() != null) {
            localVarFormParams.put(
                    "quantity",
                    DecimalFormatter.getFormatter().format(testOrderRequest.getQuantity()));
        }

        if (testOrderRequest.getReduceOnly() != null) {
            localVarFormParams.put("reduceOnly", testOrderRequest.getReduceOnly());
        }

        if (testOrderRequest.getPrice() != null) {
            localVarFormParams.put(
                    "price", DecimalFormatter.getFormatter().format(testOrderRequest.getPrice()));
        }

        if (testOrderRequest.getNewClientOrderId() != null) {
            localVarFormParams.put("newClientOrderId", testOrderRequest.getNewClientOrderId());
        }

        if (testOrderRequest.getStopPrice() != null) {
            localVarFormParams.put(
                    "stopPrice",
                    DecimalFormatter.getFormatter().format(testOrderRequest.getStopPrice()));
        }

        if (testOrderRequest.getClosePosition() != null) {
            localVarFormParams.put("closePosition", testOrderRequest.getClosePosition());
        }

        if (testOrderRequest.getActivationPrice() != null) {
            localVarFormParams.put(
                    "activationPrice",
                    DecimalFormatter.getFormatter().format(testOrderRequest.getActivationPrice()));
        }

        if (testOrderRequest.getCallbackRate() != null) {
            localVarFormParams.put(
                    "callbackRate",
                    DecimalFormatter.getFormatter().format(testOrderRequest.getCallbackRate()));
        }

        if (testOrderRequest.getWorkingType() != null) {
            localVarFormParams.put("workingType", testOrderRequest.getWorkingType());
        }

        if (testOrderRequest.getPriceProtect() != null) {
            localVarFormParams.put("priceProtect", testOrderRequest.getPriceProtect());
        }

        if (testOrderRequest.getNewOrderRespType() != null) {
            localVarFormParams.put("newOrderRespType", testOrderRequest.getNewOrderRespType());
        }

        if (testOrderRequest.getPriceMatch() != null) {
            localVarFormParams.put("priceMatch", testOrderRequest.getPriceMatch());
        }

        if (testOrderRequest.getSelfTradePreventionMode() != null) {
            localVarFormParams.put(
                    "selfTradePreventionMode", testOrderRequest.getSelfTradePreventionMode());
        }

        if (testOrderRequest.getGoodTillDate() != null) {
            localVarFormParams.put("goodTillDate", testOrderRequest.getGoodTillDate());
        }

        if (testOrderRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", testOrderRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call testOrderValidateBeforeCall(TestOrderRequest testOrderRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {testOrderRequest};
            Method method = this.getClass().getMethod("testOrder", TestOrderRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return testOrderCall(testOrderRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Test Order(TRADE) Testing order request, this order will not be submitted to matching engine
     * * Order with type &#x60;STOP&#x60;, parameter &#x60;timeInForce&#x60; can be sent ( default
     * &#x60;GTC&#x60;). * Order with type &#x60;TAKE_PROFIT&#x60;, parameter
     * &#x60;timeInForce&#x60; can be sent ( default &#x60;GTC&#x60;). * Condition orders will be
     * triggered when: * If parameter&#x60;priceProtect&#x60;is sent as true: * when price reaches
     * the &#x60;stopPrice&#x60; the difference rate between \&quot;MARK_PRICE\&quot; and
     * \&quot;CONTRACT_PRICE\&quot; cannot be larger than the \&quot;triggerProtect\&quot; of the
     * symbol * \&quot;triggerProtect\&quot; of a symbol can be got from &#x60;GET
     * /fapi/v1/exchangeInfo&#x60; * &#x60;STOP&#x60;, &#x60;STOP_MARKET&#x60;: * BUY: latest price
     * (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &gt;&#x3D; &#x60;stopPrice&#x60; *
     * SELL: latest price (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &lt;&#x3D;
     * &#x60;stopPrice&#x60; * &#x60;TAKE_PROFIT&#x60;, &#x60;TAKE_PROFIT_MARKET&#x60;: * BUY:
     * latest price (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &lt;&#x3D;
     * &#x60;stopPrice&#x60; * SELL: latest price (\&quot;MARK_PRICE\&quot; or
     * \&quot;CONTRACT_PRICE\&quot;) &gt;&#x3D; &#x60;stopPrice&#x60; *
     * &#x60;TRAILING_STOP_MARKET&#x60;: * BUY: the lowest price after order placed &#x60;&lt;&#x3D;
     * &#x60;activationPrice&#x60;, and the latest price &gt;&#x60;&#x3D; the lowest price * (1 +
     * &#x60;callbackRate&#x60;) * SELL: the highest price after order placed &gt;&#x3D;
     * &#x60;activationPrice&#x60;, and the latest price &lt;&#x3D; the highest price * (1 -
     * &#x60;callbackRate&#x60;) * For &#x60;TRAILING_STOP_MARKET&#x60;, if you got such error code.
     * &#x60;&#x60;{\&quot;code\&quot;: -2021, \&quot;msg\&quot;: \&quot;Order would immediately
     * trigger.\&quot;}&#x60;&#x60; means that the parameters you send do not meet the following
     * requirements: * BUY: &#x60;activationPrice&#x60; should be smaller than latest price. * SELL:
     * &#x60;activationPrice&#x60; should be larger than latest price. * If &#x60;newOrderRespType
     * &#x60; is sent as &#x60;RESULT&#x60; : * &#x60;MARKET&#x60; order: the final FILLED result of
     * the order will be return directly. * &#x60;LIMIT&#x60; order with special
     * &#x60;timeInForce&#x60;: the final status result of the order(FILLED or EXPIRED) will be
     * returned directly. * &#x60;STOP_MARKET&#x60;, &#x60;TAKE_PROFIT_MARKET&#x60; with
     * &#x60;closePosition&#x60;&#x3D;&#x60;true&#x60;: * Follow the same rules for condition
     * orders. * If triggered**close all** current long position( if &#x60;SELL&#x60;) or current
     * short position( if &#x60;BUY&#x60;). * Cannot be used with &#x60;quantity&#x60; paremeter *
     * Cannot be used with &#x60;reduceOnly&#x60; parameter * In Hedge Mode,cannot be used with
     * &#x60;BUY&#x60; orders in &#x60;LONG&#x60; position side. and cannot be used with
     * &#x60;SELL&#x60; orders in &#x60;SHORT&#x60; position side *
     * &#x60;selfTradePreventionMode&#x60; is only effective when &#x60;timeInForce&#x60; set to
     * &#x60;IOC&#x60; or &#x60;GTC&#x60; or &#x60;GTD&#x60;. * In extreme market conditions,
     * timeInForce &#x60;GTD&#x60; order auto cancel time might be delayed comparing to
     * &#x60;goodTillDate&#x60; Weight: 0
     *
     * @param testOrderRequest (required)
     * @return ApiResponse&lt;TestOrderResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Test Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/New-Order-Test">Test
     *     Order(TRADE) Documentation</a>
     */
    public ApiResponse<TestOrderResponse> testOrder(
            @Valid @NotNull TestOrderRequest testOrderRequest) throws ApiException {
        okhttp3.Call localVarCall = testOrderValidateBeforeCall(testOrderRequest);
        java.lang.reflect.Type localVarReturnType = new TypeToken<TestOrderResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for usersForceOrders
     *
     * @param symbol (optional)
     * @param autoCloseType \&quot;LIQUIDATION\&quot; for liquidation orders, \&quot;ADL\&quot; for
     *     ADL orders. (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User&#39;s Force Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Users-Force-Orders">User&#39;s
     *     Force Orders (USER_DATA) Documentation</a>
     */
    private okhttp3.Call usersForceOrdersCall(
            String symbol,
            AutoCloseType autoCloseType,
            Long startTime,
            Long endTime,
            Long limit,
            Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/forceOrders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (autoCloseType != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("autoCloseType", autoCloseType));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        localVarAuthNames.add("binanceSignature");
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call usersForceOrdersValidateBeforeCall(
            String symbol,
            AutoCloseType autoCloseType,
            Long startTime,
            Long endTime,
            Long limit,
            Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {
                symbol, autoCloseType, startTime, endTime, limit, recvWindow
            };
            Method method =
                    this.getClass()
                            .getMethod(
                                    "usersForceOrders",
                                    String.class,
                                    AutoCloseType.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return usersForceOrdersCall(
                        symbol, autoCloseType, startTime, endTime, limit, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * User&#39;s Force Orders (USER_DATA) Query user&#39;s Force Orders * If
     * \&quot;autoCloseType\&quot; is not sent, orders with both of the types will be returned * If
     * \&quot;startTime\&quot; is not sent, data within 7 days before \&quot;endTime\&quot; can be
     * queried Weight: 20 with symbol, 50 without symbol
     *
     * @param symbol (optional)
     * @param autoCloseType \&quot;LIQUIDATION\&quot; for liquidation orders, \&quot;ADL\&quot; for
     *     ADL orders. (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;UsersForceOrdersResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User&#39;s Force Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Users-Force-Orders">User&#39;s
     *     Force Orders (USER_DATA) Documentation</a>
     */
    public ApiResponse<UsersForceOrdersResponse> usersForceOrders(
            String symbol,
            AutoCloseType autoCloseType,
            Long startTime,
            Long endTime,
            Long limit,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                usersForceOrdersValidateBeforeCall(
                        symbol, autoCloseType, startTime, endTime, limit, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<UsersForceOrdersResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }
}
