/*
 * Binance Derivatives Trading USDS Futures WebSocket API
 * OpenAPI Specification for the Binance Derivatives Trading USDS Futures WebSocket API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.api;

import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.exception.ConstraintViolationException;
import com.binance.connector.client.common.websocket.adapter.ConnectionInterface;
import com.binance.connector.client.common.websocket.dtos.ApiRequestWrapperDTO;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.OrderBookRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.OrderBookResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.SymbolOrderBookTickerRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.SymbolOrderBookTickerResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.SymbolPriceTickerRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.SymbolPriceTickerResponse;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.constraints.*;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator;

public class MarketDataApi {
    private ConnectionInterface connection;

    public MarketDataApi() {}

    public MarketDataApi(ConnectionInterface connection) {
        this.connection = connection;
    }

    /**
     * Order Book Get current order book. Note that this request returns limited market depth. If
     * you need to continuously monitor order book updates, please consider using Websocket Market
     * Streams: * &#x60;&lt;symbol&gt;@depth&lt;levels&gt;&#x60; * &#x60;&lt;symbol&gt;@depth&#x60;
     * You can use &#x60;depth&#x60; request together with &#x60;&lt;symbol&gt;@depth&#x60; streams
     * to maintain a local order book. Weight: Adjusted based on the limit: | Limit | Weight | |
     * ------------- | ------ | | 5, 10, 20, 50 | 2 | | 100 | 5 | | 500 | 10 | | 1000 | 20 |
     *
     * @param orderBookRequest (required)
     * @return OrderBookResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Order Book </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/websocket-api/Order-Book">Order
     *     Book Documentation</a>
     */
    public CompletableFuture<OrderBookResponse> orderBook(OrderBookRequest orderBookRequest)
            throws ApiException {
        orderBookValidateBeforeCall(orderBookRequest);
        String methodName = "/depth".substring(1);
        ApiRequestWrapperDTO<OrderBookRequest, OrderBookResponse> build =
                new ApiRequestWrapperDTO.Builder<OrderBookRequest, OrderBookResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(orderBookRequest)
                        .responseType(OrderBookResponse.class)
                        .signed(false)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void orderBookValidateBeforeCall(OrderBookRequest orderBookRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<OrderBookRequest>> violations =
                    validator.validate(orderBookRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Symbol Order Book Ticker Best price/qty on the order book for a symbol or symbols. * If the
     * symbol is not sent, bookTickers for all symbols will be returned in an array. * The field
     * &#x60;X-MBX-USED-WEIGHT-1M&#x60; in response header is not accurate from this endpoint,
     * please ignore. Weight: 2 for a single symbol; 5 when the symbol parameter is omitted
     *
     * @param symbolOrderBookTickerRequest (required)
     * @return SymbolOrderBookTickerResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Symbol Order Book Ticker </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/websocket-api/Symbol-Order-Book-Ticker">Symbol
     *     Order Book Ticker Documentation</a>
     */
    public CompletableFuture<SymbolOrderBookTickerResponse> symbolOrderBookTicker(
            SymbolOrderBookTickerRequest symbolOrderBookTickerRequest) throws ApiException {
        symbolOrderBookTickerValidateBeforeCall(symbolOrderBookTickerRequest);
        String methodName = "/ticker.book".substring(1);
        ApiRequestWrapperDTO<SymbolOrderBookTickerRequest, SymbolOrderBookTickerResponse> build =
                new ApiRequestWrapperDTO.Builder<
                                SymbolOrderBookTickerRequest, SymbolOrderBookTickerResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(symbolOrderBookTickerRequest)
                        .responseType(SymbolOrderBookTickerResponse.class)
                        .signed(false)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void symbolOrderBookTickerValidateBeforeCall(
            SymbolOrderBookTickerRequest symbolOrderBookTickerRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<SymbolOrderBookTickerRequest>> violations =
                    validator.validate(symbolOrderBookTickerRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Symbol Price Ticker Latest price for a symbol or symbols. * If the symbol is not sent, prices
     * for all symbols will be returned in an array. Weight: 1 for a single symbol; 2 when the
     * symbol parameter is omitted
     *
     * @param symbolPriceTickerRequest (required)
     * @return SymbolPriceTickerResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Symbol Price Ticker </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/websocket-api/Symbol-Price-Ticker">Symbol
     *     Price Ticker Documentation</a>
     */
    public CompletableFuture<SymbolPriceTickerResponse> symbolPriceTicker(
            SymbolPriceTickerRequest symbolPriceTickerRequest) throws ApiException {
        symbolPriceTickerValidateBeforeCall(symbolPriceTickerRequest);
        String methodName = "/ticker.price".substring(1);
        ApiRequestWrapperDTO<SymbolPriceTickerRequest, SymbolPriceTickerResponse> build =
                new ApiRequestWrapperDTO.Builder<
                                SymbolPriceTickerRequest, SymbolPriceTickerResponse>()
                        .id(getRequestID())
                        .method(methodName)
                        .params(symbolPriceTickerRequest)
                        .responseType(SymbolPriceTickerResponse.class)
                        .signed(false)
                        .build();

        try {
            connection.send(build);
        } catch (InterruptedException e) {
            throw new ApiException(e);
        }
        return build.getResponseCallback();
    }

    @SuppressWarnings("rawtypes")
    private void symbolPriceTickerValidateBeforeCall(
            SymbolPriceTickerRequest symbolPriceTickerRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();

            Set<ConstraintViolation<SymbolPriceTickerRequest>> violations =
                    validator.validate(symbolPriceTickerRequest);

            if (!violations.isEmpty()) {
                throw new ConstraintViolationException(violations);
            }
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    public String getRequestID() {
        return UUID.randomUUID().toString();
    }
}
