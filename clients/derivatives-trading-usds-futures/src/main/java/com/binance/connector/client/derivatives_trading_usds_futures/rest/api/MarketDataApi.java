/*
 * Binance Derivatives Trading USDS Futures REST API
 * OpenAPI Specification for the Binance Derivatives Trading USDS Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_usds_futures.rest.api;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.Pair;
import com.binance.connector.client.common.SystemUtil;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.exception.ConstraintViolationException;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.BasisResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.CheckServerTimeResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.CompositeIndexSymbolInformationResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.CompressedAggregateTradesListResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ContinuousContractKlineCandlestickDataResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ContractType;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ExchangeInformationResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.GetFundingRateHistoryResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.GetFundingRateInfoResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.IndexPriceKlineCandlestickDataResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.Interval;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.KlineCandlestickDataResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.LongShortRatioResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.MarkPriceKlineCandlestickDataResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.MarkPriceResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.MultiAssetsModeAssetIndexResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.OldTradesLookupResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.OpenInterestResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.OpenInterestStatisticsResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.OrderBookResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.Period;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.PremiumIndexKlineDataResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.QuarterlyContractSettlementPriceResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.QueryIndexPriceConstituentsResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.QueryInsuranceFundBalanceSnapshotResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.RecentTradesListResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.SymbolOrderBookTickerResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.SymbolPriceTickerResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.SymbolPriceTickerV2Response;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.TakerBuySellVolumeResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.Ticker24hrPriceChangeStatisticsResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.TopTraderLongShortRatioAccountsResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.TopTraderLongShortRatioPositionsResponse;
import com.google.gson.reflect.TypeToken;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.constraints.*;
import jakarta.validation.executable.ExecutableValidator;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator;

public class MarketDataApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    private static final String USER_AGENT =
            String.format(
                    "binance-derivatives-trading-usds-futures/6.0.0 (Java/%s; %s; %s)",
                    SystemUtil.getJavaVersion(), SystemUtil.getOs(), SystemUtil.getArch());
    private static final boolean HAS_TIME_UNIT = false;

    public MarketDataApi(ClientConfiguration clientConfiguration) {
        this(new ApiClient(clientConfiguration));
    }

    public MarketDataApi(ApiClient apiClient) {
        apiClient.setUserAgent(USER_AGENT);
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for basis
     *
     * @param pair (required)
     * @param contractType (required)
     * @param period
     *     \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot;
     *     (required)
     * @param limit Default 30,Max 500 (required)
     * @param startTime (optional)
     * @param endTime (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Basis </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Basis">Basis
     *     Documentation</a>
     */
    private okhttp3.Call basisCall(
            String pair,
            ContractType contractType,
            Period period,
            Long limit,
            Long startTime,
            Long endTime)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/futures/data/basis";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (pair != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pair", pair));
        }

        if (contractType != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("contractType", contractType));
        }

        if (period != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("period", period));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call basisValidateBeforeCall(
            String pair,
            ContractType contractType,
            Period period,
            Long limit,
            Long startTime,
            Long endTime)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {pair, contractType, period, limit, startTime, endTime};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "basis",
                                    String.class,
                                    ContractType.class,
                                    Period.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return basisCall(pair, contractType, period, limit, startTime, endTime);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Basis Query future basis * If startTime and endTime are not sent, the most recent data is
     * returned. * Only the data of the latest 30 days is available. Weight: 0
     *
     * @param pair (required)
     * @param contractType (required)
     * @param period
     *     \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot;
     *     (required)
     * @param limit Default 30,Max 500 (required)
     * @param startTime (optional)
     * @param endTime (optional)
     * @return ApiResponse&lt;BasisResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Basis </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Basis">Basis
     *     Documentation</a>
     */
    public ApiResponse<BasisResponse> basis(
            @NotNull String pair,
            @NotNull ContractType contractType,
            @NotNull Period period,
            @NotNull Long limit,
            Long startTime,
            Long endTime)
            throws ApiException {
        okhttp3.Call localVarCall =
                basisValidateBeforeCall(pair, contractType, period, limit, startTime, endTime);
        java.lang.reflect.Type localVarReturnType = new TypeToken<BasisResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for checkServerTime
     *
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Check Server Time </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Check-Server-Time">Check
     *     Server Time Documentation</a>
     */
    private okhttp3.Call checkServerTimeCall() throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/time";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call checkServerTimeValidateBeforeCall() throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {};
            Method method = this.getClass().getMethod("checkServerTime");
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return checkServerTimeCall();
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Check Server Time Test connectivity to the Rest API and get the current server time. Weight:
     * 1
     *
     * @return ApiResponse&lt;CheckServerTimeResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Check Server Time </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Check-Server-Time">Check
     *     Server Time Documentation</a>
     */
    public ApiResponse<CheckServerTimeResponse> checkServerTime() throws ApiException {
        okhttp3.Call localVarCall = checkServerTimeValidateBeforeCall();
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<CheckServerTimeResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for compositeIndexSymbolInformation
     *
     * @param symbol (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Composite Index Symbol Information </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Composite-Index-Symbol-Information">Composite
     *     Index Symbol Information Documentation</a>
     */
    private okhttp3.Call compositeIndexSymbolInformationCall(String symbol) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/indexInfo";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call compositeIndexSymbolInformationValidateBeforeCall(String symbol)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol};
            Method method =
                    this.getClass().getMethod("compositeIndexSymbolInformation", String.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return compositeIndexSymbolInformationCall(symbol);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Composite Index Symbol Information Query composite index symbol information * Only for
     * composite index symbols Weight: 1
     *
     * @param symbol (optional)
     * @return ApiResponse&lt;CompositeIndexSymbolInformationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Composite Index Symbol Information </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Composite-Index-Symbol-Information">Composite
     *     Index Symbol Information Documentation</a>
     */
    public ApiResponse<CompositeIndexSymbolInformationResponse> compositeIndexSymbolInformation(
            String symbol) throws ApiException {
        okhttp3.Call localVarCall = compositeIndexSymbolInformationValidateBeforeCall(symbol);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<CompositeIndexSymbolInformationResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for compressedAggregateTradesList
     *
     * @param symbol (required)
     * @param fromId ID to get aggregate trades from INCLUSIVE. (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Compressed/Aggregate Trades List </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Compressed-Aggregate-Trades-List">Compressed/Aggregate
     *     Trades List Documentation</a>
     */
    private okhttp3.Call compressedAggregateTradesListCall(
            String symbol, Long fromId, Long startTime, Long endTime, Long limit)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/aggTrades";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (fromId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromId", fromId));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call compressedAggregateTradesListValidateBeforeCall(
            String symbol, Long fromId, Long startTime, Long endTime, Long limit)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, fromId, startTime, endTime, limit};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "compressedAggregateTradesList",
                                    String.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return compressedAggregateTradesListCall(symbol, fromId, startTime, endTime, limit);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Compressed/Aggregate Trades List Get compressed, aggregate market trades. Market trades that
     * fill in 100ms with the same price and the same taking side will have the quantity aggregated.
     * * support querying futures trade histories that are not older than one year * If both
     * &#x60;startTime&#x60; and &#x60;endTime&#x60; are sent, time between &#x60;startTime&#x60;
     * and &#x60;endTime&#x60; must be less than 1 hour. * If &#x60;fromId&#x60;,
     * &#x60;startTime&#x60;, and &#x60;endTime&#x60; are not sent, the most recent aggregate trades
     * will be returned. * Only market trades will be aggregated and returned, which means the
     * insurance fund trades and ADL trades won&#39;t be aggregated. * Sending both
     * &#x60;startTime&#x60;/&#x60;endTime&#x60; and &#x60;fromId&#x60; might cause response
     * timeout, please send either &#x60;fromId&#x60; or &#x60;startTime&#x60;/&#x60;endTime&#x60;
     * Weight: 20
     *
     * @param symbol (required)
     * @param fromId ID to get aggregate trades from INCLUSIVE. (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @return ApiResponse&lt;CompressedAggregateTradesListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Compressed/Aggregate Trades List </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Compressed-Aggregate-Trades-List">Compressed/Aggregate
     *     Trades List Documentation</a>
     */
    public ApiResponse<CompressedAggregateTradesListResponse> compressedAggregateTradesList(
            @NotNull String symbol, Long fromId, Long startTime, Long endTime, Long limit)
            throws ApiException {
        okhttp3.Call localVarCall =
                compressedAggregateTradesListValidateBeforeCall(
                        symbol, fromId, startTime, endTime, limit);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<CompressedAggregateTradesListResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for continuousContractKlineCandlestickData
     *
     * @param pair (required)
     * @param contractType (required)
     * @param interval (required)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Continuous Contract Kline/Candlestick Data </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Continuous-Contract-Kline-Candlestick-Data">Continuous
     *     Contract Kline/Candlestick Data Documentation</a>
     */
    private okhttp3.Call continuousContractKlineCandlestickDataCall(
            String pair,
            ContractType contractType,
            Interval interval,
            Long startTime,
            Long endTime,
            Long limit)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/continuousKlines";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (pair != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pair", pair));
        }

        if (contractType != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("contractType", contractType));
        }

        if (interval != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("interval", interval));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call continuousContractKlineCandlestickDataValidateBeforeCall(
            String pair,
            ContractType contractType,
            Interval interval,
            Long startTime,
            Long endTime,
            Long limit)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {pair, contractType, interval, startTime, endTime, limit};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "continuousContractKlineCandlestickData",
                                    String.class,
                                    ContractType.class,
                                    Interval.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return continuousContractKlineCandlestickDataCall(
                        pair, contractType, interval, startTime, endTime, limit);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Continuous Contract Kline/Candlestick Data Kline/candlestick bars for a specific contract
     * type. Klines are uniquely identified by their open time. * If startTime and endTime are not
     * sent, the most recent klines are returned. * Contract type: * PERPETUAL * CURRENT_QUARTER *
     * NEXT_QUARTER Weight: based on parameter LIMIT | LIMIT | weight | | ----------- | ------ | |
     * [1,100) | 1 | | [100, 500) | 2 | | [500, 1000] | 5 | | &gt; 1000 | 10 |
     *
     * @param pair (required)
     * @param contractType (required)
     * @param interval (required)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @return ApiResponse&lt;ContinuousContractKlineCandlestickDataResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Continuous Contract Kline/Candlestick Data </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Continuous-Contract-Kline-Candlestick-Data">Continuous
     *     Contract Kline/Candlestick Data Documentation</a>
     */
    public ApiResponse<ContinuousContractKlineCandlestickDataResponse>
            continuousContractKlineCandlestickData(
                    @NotNull String pair,
                    @NotNull ContractType contractType,
                    @NotNull Interval interval,
                    Long startTime,
                    Long endTime,
                    Long limit)
                    throws ApiException {
        okhttp3.Call localVarCall =
                continuousContractKlineCandlestickDataValidateBeforeCall(
                        pair, contractType, interval, startTime, endTime, limit);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<ContinuousContractKlineCandlestickDataResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for exchangeInformation
     *
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Exchange Information </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Exchange-Information">Exchange
     *     Information Documentation</a>
     */
    private okhttp3.Call exchangeInformationCall() throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/exchangeInfo";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call exchangeInformationValidateBeforeCall() throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {};
            Method method = this.getClass().getMethod("exchangeInformation");
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return exchangeInformationCall();
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Exchange Information Current exchange trading rules and symbol information Weight: 1
     *
     * @return ApiResponse&lt;ExchangeInformationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Exchange Information </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Exchange-Information">Exchange
     *     Information Documentation</a>
     */
    public ApiResponse<ExchangeInformationResponse> exchangeInformation() throws ApiException {
        okhttp3.Call localVarCall = exchangeInformationValidateBeforeCall();
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<ExchangeInformationResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for getFundingRateHistory
     *
     * @param symbol (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Get Funding Rate History </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Get-Funding-Rate-History">Get
     *     Funding Rate History Documentation</a>
     */
    private okhttp3.Call getFundingRateHistoryCall(
            String symbol, Long startTime, Long endTime, Long limit) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/fundingRate";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFundingRateHistoryValidateBeforeCall(
            String symbol, Long startTime, Long endTime, Long limit) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, startTime, endTime, limit};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "getFundingRateHistory",
                                    String.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return getFundingRateHistoryCall(symbol, startTime, endTime, limit);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Get Funding Rate History Get Funding Rate History * If &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; are not sent, the most recent 200 records are returned. * If the number
     * of data between &#x60;startTime&#x60; and &#x60;endTime&#x60; is larger than
     * &#x60;limit&#x60;, return as &#x60;startTime&#x60; + &#x60;limit&#x60;. * In ascending order.
     * Weight: share 500/5min/IP rate limit with GET /fapi/v1/fundingInfo
     *
     * @param symbol (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @return ApiResponse&lt;GetFundingRateHistoryResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Get Funding Rate History </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Get-Funding-Rate-History">Get
     *     Funding Rate History Documentation</a>
     */
    public ApiResponse<GetFundingRateHistoryResponse> getFundingRateHistory(
            String symbol, Long startTime, Long endTime, Long limit) throws ApiException {
        okhttp3.Call localVarCall =
                getFundingRateHistoryValidateBeforeCall(symbol, startTime, endTime, limit);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<GetFundingRateHistoryResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for getFundingRateInfo
     *
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Get Funding Rate Info </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Get-Funding-Rate-Info">Get
     *     Funding Rate Info Documentation</a>
     */
    private okhttp3.Call getFundingRateInfoCall() throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/fundingInfo";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFundingRateInfoValidateBeforeCall() throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {};
            Method method = this.getClass().getMethod("getFundingRateInfo");
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return getFundingRateInfoCall();
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Get Funding Rate Info Query funding rate info for symbols that had FundingRateCap/
     * FundingRateFloor / fundingIntervalHours adjustment Weight: 0 share 500/5min/IP rate limit
     * with GET /fapi/v1/fundingInfo
     *
     * @return ApiResponse&lt;GetFundingRateInfoResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Get Funding Rate Info </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Get-Funding-Rate-Info">Get
     *     Funding Rate Info Documentation</a>
     */
    public ApiResponse<GetFundingRateInfoResponse> getFundingRateInfo() throws ApiException {
        okhttp3.Call localVarCall = getFundingRateInfoValidateBeforeCall();
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<GetFundingRateInfoResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for indexPriceKlineCandlestickData
     *
     * @param pair (required)
     * @param interval (required)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Index Price Kline/Candlestick Data </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Index-Price-Kline-Candlestick-Data">Index
     *     Price Kline/Candlestick Data Documentation</a>
     */
    private okhttp3.Call indexPriceKlineCandlestickDataCall(
            String pair, Interval interval, Long startTime, Long endTime, Long limit)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/indexPriceKlines";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (pair != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pair", pair));
        }

        if (interval != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("interval", interval));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call indexPriceKlineCandlestickDataValidateBeforeCall(
            String pair, Interval interval, Long startTime, Long endTime, Long limit)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {pair, interval, startTime, endTime, limit};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "indexPriceKlineCandlestickData",
                                    String.class,
                                    Interval.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return indexPriceKlineCandlestickDataCall(
                        pair, interval, startTime, endTime, limit);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Index Price Kline/Candlestick Data Kline/candlestick bars for the index price of a pair.
     * Klines are uniquely identified by their open time. * If startTime and endTime are not sent,
     * the most recent klines are returned. Weight: based on parameter LIMIT | LIMIT | weight | |
     * ----------- | ------ | | [1,100) | 1 | | [100, 500) | 2 | | [500, 1000] | 5 | | &gt; 1000 |
     * 10 |
     *
     * @param pair (required)
     * @param interval (required)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @return ApiResponse&lt;IndexPriceKlineCandlestickDataResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Index Price Kline/Candlestick Data </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Index-Price-Kline-Candlestick-Data">Index
     *     Price Kline/Candlestick Data Documentation</a>
     */
    public ApiResponse<IndexPriceKlineCandlestickDataResponse> indexPriceKlineCandlestickData(
            @NotNull String pair,
            @NotNull Interval interval,
            Long startTime,
            Long endTime,
            Long limit)
            throws ApiException {
        okhttp3.Call localVarCall =
                indexPriceKlineCandlestickDataValidateBeforeCall(
                        pair, interval, startTime, endTime, limit);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<IndexPriceKlineCandlestickDataResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for klineCandlestickData
     *
     * @param symbol (required)
     * @param interval (required)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Kline/Candlestick Data </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Kline-Candlestick-Data">Kline/Candlestick
     *     Data Documentation</a>
     */
    private okhttp3.Call klineCandlestickDataCall(
            String symbol, Interval interval, Long startTime, Long endTime, Long limit)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/klines";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (interval != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("interval", interval));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call klineCandlestickDataValidateBeforeCall(
            String symbol, Interval interval, Long startTime, Long endTime, Long limit)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, interval, startTime, endTime, limit};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "klineCandlestickData",
                                    String.class,
                                    Interval.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return klineCandlestickDataCall(symbol, interval, startTime, endTime, limit);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Kline/Candlestick Data Kline/candlestick bars for a symbol. Klines are uniquely identified by
     * their open time. * If startTime and endTime are not sent, the most recent klines are
     * returned. Weight: based on parameter LIMIT | LIMIT | weight | | ----------- | ------ | |
     * [1,100) | 1 | | [100, 500) | 2 | | [500, 1000] | 5 | | &gt; 1000 | 10 |
     *
     * @param symbol (required)
     * @param interval (required)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @return ApiResponse&lt;KlineCandlestickDataResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Kline/Candlestick Data </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Kline-Candlestick-Data">Kline/Candlestick
     *     Data Documentation</a>
     */
    public ApiResponse<KlineCandlestickDataResponse> klineCandlestickData(
            @NotNull String symbol,
            @NotNull Interval interval,
            Long startTime,
            Long endTime,
            Long limit)
            throws ApiException {
        okhttp3.Call localVarCall =
                klineCandlestickDataValidateBeforeCall(symbol, interval, startTime, endTime, limit);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<KlineCandlestickDataResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for longShortRatio
     *
     * @param symbol (required)
     * @param period
     *     \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot;
     *     (required)
     * @param limit Default 100; max 1000 (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Long/Short Ratio </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Long-Short-Ratio">Long/Short
     *     Ratio Documentation</a>
     */
    private okhttp3.Call longShortRatioCall(
            String symbol, Period period, Long limit, Long startTime, Long endTime)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/futures/data/globalLongShortAccountRatio";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (period != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("period", period));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call longShortRatioValidateBeforeCall(
            String symbol, Period period, Long limit, Long startTime, Long endTime)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, period, limit, startTime, endTime};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "longShortRatio",
                                    String.class,
                                    Period.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return longShortRatioCall(symbol, period, limit, startTime, endTime);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Long/Short Ratio Query symbol Long/Short Ratio * If startTime and endTime are not sent, the
     * most recent data is returned. * Only the data of the latest 30 days is available. * IP rate
     * limit 1000 requests/5min Weight: 0
     *
     * @param symbol (required)
     * @param period
     *     \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot;
     *     (required)
     * @param limit Default 100; max 1000 (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @return ApiResponse&lt;LongShortRatioResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Long/Short Ratio </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Long-Short-Ratio">Long/Short
     *     Ratio Documentation</a>
     */
    public ApiResponse<LongShortRatioResponse> longShortRatio(
            @NotNull String symbol,
            @NotNull Period period,
            Long limit,
            Long startTime,
            Long endTime)
            throws ApiException {
        okhttp3.Call localVarCall =
                longShortRatioValidateBeforeCall(symbol, period, limit, startTime, endTime);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<LongShortRatioResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for markPrice
     *
     * @param symbol (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Mark Price </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Mark-Price">Mark
     *     Price Documentation</a>
     */
    private okhttp3.Call markPriceCall(String symbol) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/premiumIndex";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call markPriceValidateBeforeCall(String symbol) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol};
            Method method = this.getClass().getMethod("markPrice", String.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return markPriceCall(symbol);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Mark Price Mark Price and Funding Rate Weight: 1
     *
     * @param symbol (optional)
     * @return ApiResponse&lt;MarkPriceResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Mark Price </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Mark-Price">Mark
     *     Price Documentation</a>
     */
    public ApiResponse<MarkPriceResponse> markPrice(String symbol) throws ApiException {
        okhttp3.Call localVarCall = markPriceValidateBeforeCall(symbol);
        java.lang.reflect.Type localVarReturnType = new TypeToken<MarkPriceResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for markPriceKlineCandlestickData
     *
     * @param symbol (required)
     * @param interval (required)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Mark Price Kline/Candlestick Data </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Mark-Price-Kline-Candlestick-Data">Mark
     *     Price Kline/Candlestick Data Documentation</a>
     */
    private okhttp3.Call markPriceKlineCandlestickDataCall(
            String symbol, Interval interval, Long startTime, Long endTime, Long limit)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/markPriceKlines";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (interval != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("interval", interval));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call markPriceKlineCandlestickDataValidateBeforeCall(
            String symbol, Interval interval, Long startTime, Long endTime, Long limit)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, interval, startTime, endTime, limit};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "markPriceKlineCandlestickData",
                                    String.class,
                                    Interval.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return markPriceKlineCandlestickDataCall(
                        symbol, interval, startTime, endTime, limit);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Mark Price Kline/Candlestick Data Kline/candlestick bars for the mark price of a symbol.
     * Klines are uniquely identified by their open time. * If startTime and endTime are not sent,
     * the most recent klines are returned. Weight: based on parameter LIMIT | LIMIT | weight | |
     * ----------- | ------ | | [1,100) | 1 | | [100, 500) | 2 | | [500, 1000] | 5 | | &gt; 1000 |
     * 10 |
     *
     * @param symbol (required)
     * @param interval (required)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @return ApiResponse&lt;MarkPriceKlineCandlestickDataResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Mark Price Kline/Candlestick Data </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Mark-Price-Kline-Candlestick-Data">Mark
     *     Price Kline/Candlestick Data Documentation</a>
     */
    public ApiResponse<MarkPriceKlineCandlestickDataResponse> markPriceKlineCandlestickData(
            @NotNull String symbol,
            @NotNull Interval interval,
            Long startTime,
            Long endTime,
            Long limit)
            throws ApiException {
        okhttp3.Call localVarCall =
                markPriceKlineCandlestickDataValidateBeforeCall(
                        symbol, interval, startTime, endTime, limit);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<MarkPriceKlineCandlestickDataResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for multiAssetsModeAssetIndex
     *
     * @param symbol (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Multi-Assets Mode Asset Index </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Multi-Assets-Mode-Asset-Index">Multi-Assets
     *     Mode Asset Index Documentation</a>
     */
    private okhttp3.Call multiAssetsModeAssetIndexCall(String symbol) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/assetIndex";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call multiAssetsModeAssetIndexValidateBeforeCall(String symbol)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol};
            Method method = this.getClass().getMethod("multiAssetsModeAssetIndex", String.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return multiAssetsModeAssetIndexCall(symbol);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Multi-Assets Mode Asset Index asset index for Multi-Assets mode Weight: 1 for a single
     * symbol; 10 when the symbol parameter is omitted
     *
     * @param symbol (optional)
     * @return ApiResponse&lt;MultiAssetsModeAssetIndexResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Multi-Assets Mode Asset Index </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Multi-Assets-Mode-Asset-Index">Multi-Assets
     *     Mode Asset Index Documentation</a>
     */
    public ApiResponse<MultiAssetsModeAssetIndexResponse> multiAssetsModeAssetIndex(String symbol)
            throws ApiException {
        okhttp3.Call localVarCall = multiAssetsModeAssetIndexValidateBeforeCall(symbol);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<MultiAssetsModeAssetIndexResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for oldTradesLookup
     *
     * @param symbol (required)
     * @param limit Default 100; max 1000 (optional)
     * @param fromId ID to get aggregate trades from INCLUSIVE. (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Old Trades Lookup </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Old-Trades-Lookup">Old
     *     Trades Lookup (MARKET_DATA) Documentation</a>
     */
    private okhttp3.Call oldTradesLookupCall(String symbol, Long limit, Long fromId)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/historicalTrades";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (fromId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromId", fromId));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call oldTradesLookupValidateBeforeCall(String symbol, Long limit, Long fromId)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, limit, fromId};
            Method method =
                    this.getClass()
                            .getMethod("oldTradesLookup", String.class, Long.class, Long.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return oldTradesLookupCall(symbol, limit, fromId);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Old Trades Lookup (MARKET_DATA) Get older market historical trades. * Market trades means
     * trades filled in the order book. Only market trades will be returned, which means the
     * insurance fund trades and ADL trades won&#39;t be returned. * Only supports data from within
     * the last three months Weight: 20
     *
     * @param symbol (required)
     * @param limit Default 100; max 1000 (optional)
     * @param fromId ID to get aggregate trades from INCLUSIVE. (optional)
     * @return ApiResponse&lt;OldTradesLookupResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Old Trades Lookup </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Old-Trades-Lookup">Old
     *     Trades Lookup (MARKET_DATA) Documentation</a>
     */
    public ApiResponse<OldTradesLookupResponse> oldTradesLookup(
            @NotNull String symbol, Long limit, Long fromId) throws ApiException {
        okhttp3.Call localVarCall = oldTradesLookupValidateBeforeCall(symbol, limit, fromId);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<OldTradesLookupResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for openInterest
     *
     * @param symbol (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Open Interest </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Open-Interest">Open
     *     Interest Documentation</a>
     */
    private okhttp3.Call openInterestCall(String symbol) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/openInterest";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call openInterestValidateBeforeCall(String symbol) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol};
            Method method = this.getClass().getMethod("openInterest", String.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return openInterestCall(symbol);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Open Interest Get present open interest of a specific symbol. Weight: 1
     *
     * @param symbol (required)
     * @return ApiResponse&lt;OpenInterestResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Open Interest </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Open-Interest">Open
     *     Interest Documentation</a>
     */
    public ApiResponse<OpenInterestResponse> openInterest(@NotNull String symbol)
            throws ApiException {
        okhttp3.Call localVarCall = openInterestValidateBeforeCall(symbol);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<OpenInterestResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for openInterestStatistics
     *
     * @param symbol (required)
     * @param period
     *     \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot;
     *     (required)
     * @param limit Default 100; max 1000 (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Open Interest Statistics </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Open-Interest-Statistics">Open
     *     Interest Statistics Documentation</a>
     */
    private okhttp3.Call openInterestStatisticsCall(
            String symbol, Period period, Long limit, Long startTime, Long endTime)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/futures/data/openInterestHist";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (period != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("period", period));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call openInterestStatisticsValidateBeforeCall(
            String symbol, Period period, Long limit, Long startTime, Long endTime)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, period, limit, startTime, endTime};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "openInterestStatistics",
                                    String.class,
                                    Period.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return openInterestStatisticsCall(symbol, period, limit, startTime, endTime);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Open Interest Statistics Open Interest Statistics * If startTime and endTime are not sent,
     * the most recent data is returned. * Only the data of the latest 1 month is available. * IP
     * rate limit 1000 requests/5min Weight: 0
     *
     * @param symbol (required)
     * @param period
     *     \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot;
     *     (required)
     * @param limit Default 100; max 1000 (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @return ApiResponse&lt;OpenInterestStatisticsResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Open Interest Statistics </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Open-Interest-Statistics">Open
     *     Interest Statistics Documentation</a>
     */
    public ApiResponse<OpenInterestStatisticsResponse> openInterestStatistics(
            @NotNull String symbol,
            @NotNull Period period,
            Long limit,
            Long startTime,
            Long endTime)
            throws ApiException {
        okhttp3.Call localVarCall =
                openInterestStatisticsValidateBeforeCall(symbol, period, limit, startTime, endTime);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<OpenInterestStatisticsResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for orderBook
     *
     * @param symbol (required)
     * @param limit Default 100; max 1000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Order Book </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Order-Book">Order
     *     Book Documentation</a>
     */
    private okhttp3.Call orderBookCall(String symbol, Long limit) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/depth";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call orderBookValidateBeforeCall(String symbol, Long limit)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, limit};
            Method method = this.getClass().getMethod("orderBook", String.class, Long.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return orderBookCall(symbol, limit);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Order Book Query symbol orderbook Weight: Adjusted based on the limit: | Limit | Weight | |
     * ------------- | ------ | | 5, 10, 20, 50 | 2 | | 100 | 5 | | 500 | 10 | | 1000 | 20 |
     *
     * @param symbol (required)
     * @param limit Default 100; max 1000 (optional)
     * @return ApiResponse&lt;OrderBookResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Order Book </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Order-Book">Order
     *     Book Documentation</a>
     */
    public ApiResponse<OrderBookResponse> orderBook(@NotNull String symbol, Long limit)
            throws ApiException {
        okhttp3.Call localVarCall = orderBookValidateBeforeCall(symbol, limit);
        java.lang.reflect.Type localVarReturnType = new TypeToken<OrderBookResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for premiumIndexKlineData
     *
     * @param symbol (required)
     * @param interval (required)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Premium index Kline Data </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Premium-index-Kline-Data">Premium
     *     index Kline Data Documentation</a>
     */
    private okhttp3.Call premiumIndexKlineDataCall(
            String symbol, Interval interval, Long startTime, Long endTime, Long limit)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/premiumIndexKlines";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (interval != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("interval", interval));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call premiumIndexKlineDataValidateBeforeCall(
            String symbol, Interval interval, Long startTime, Long endTime, Long limit)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, interval, startTime, endTime, limit};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "premiumIndexKlineData",
                                    String.class,
                                    Interval.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return premiumIndexKlineDataCall(symbol, interval, startTime, endTime, limit);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Premium index Kline Data Premium index kline bars of a symbol. Klines are uniquely identified
     * by their open time. * If startTime and endTime are not sent, the most recent klines are
     * returned. Weight: based on parameter LIMIT | LIMIT | weight | | ----------- | ------ | |
     * [1,100) | 1 | | [100, 500) | 2 | | [500, 1000] | 5 | | &gt; 1000 | 10 |
     *
     * @param symbol (required)
     * @param interval (required)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param limit Default 100; max 1000 (optional)
     * @return ApiResponse&lt;PremiumIndexKlineDataResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Premium index Kline Data </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Premium-index-Kline-Data">Premium
     *     index Kline Data Documentation</a>
     */
    public ApiResponse<PremiumIndexKlineDataResponse> premiumIndexKlineData(
            @NotNull String symbol,
            @NotNull Interval interval,
            Long startTime,
            Long endTime,
            Long limit)
            throws ApiException {
        okhttp3.Call localVarCall =
                premiumIndexKlineDataValidateBeforeCall(
                        symbol, interval, startTime, endTime, limit);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<PremiumIndexKlineDataResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for quarterlyContractSettlementPrice
     *
     * @param pair (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Quarterly Contract Settlement Price </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Delivery-Price">Quarterly
     *     Contract Settlement Price Documentation</a>
     */
    private okhttp3.Call quarterlyContractSettlementPriceCall(String pair) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/futures/data/delivery-price";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (pair != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pair", pair));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call quarterlyContractSettlementPriceValidateBeforeCall(String pair)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {pair};
            Method method =
                    this.getClass().getMethod("quarterlyContractSettlementPrice", String.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return quarterlyContractSettlementPriceCall(pair);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Quarterly Contract Settlement Price Latest price for a symbol or symbols. Weight: 0
     *
     * @param pair (required)
     * @return ApiResponse&lt;QuarterlyContractSettlementPriceResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Quarterly Contract Settlement Price </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Delivery-Price">Quarterly
     *     Contract Settlement Price Documentation</a>
     */
    public ApiResponse<QuarterlyContractSettlementPriceResponse> quarterlyContractSettlementPrice(
            @NotNull String pair) throws ApiException {
        okhttp3.Call localVarCall = quarterlyContractSettlementPriceValidateBeforeCall(pair);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<QuarterlyContractSettlementPriceResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for queryIndexPriceConstituents
     *
     * @param symbol (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Index Price Constituents </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Index-Constituents">Query
     *     Index Price Constituents Documentation</a>
     */
    private okhttp3.Call queryIndexPriceConstituentsCall(String symbol) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/constituents";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryIndexPriceConstituentsValidateBeforeCall(String symbol)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol};
            Method method = this.getClass().getMethod("queryIndexPriceConstituents", String.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return queryIndexPriceConstituentsCall(symbol);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Query Index Price Constituents Query index price constituents Weight: 2
     *
     * @param symbol (required)
     * @return ApiResponse&lt;QueryIndexPriceConstituentsResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Index Price Constituents </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Index-Constituents">Query
     *     Index Price Constituents Documentation</a>
     */
    public ApiResponse<QueryIndexPriceConstituentsResponse> queryIndexPriceConstituents(
            @NotNull String symbol) throws ApiException {
        okhttp3.Call localVarCall = queryIndexPriceConstituentsValidateBeforeCall(symbol);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<QueryIndexPriceConstituentsResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for queryInsuranceFundBalanceSnapshot
     *
     * @param symbol (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Insurance Fund Balance Snapshot </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Query-Insurance-Fund-Balance-Snapshot">Query
     *     Insurance Fund Balance Snapshot Documentation</a>
     */
    private okhttp3.Call queryInsuranceFundBalanceSnapshotCall(String symbol) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/insuranceBalance";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryInsuranceFundBalanceSnapshotValidateBeforeCall(String symbol)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol};
            Method method =
                    this.getClass().getMethod("queryInsuranceFundBalanceSnapshot", String.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return queryInsuranceFundBalanceSnapshotCall(symbol);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Query Insurance Fund Balance Snapshot Query Insurance Fund Balance Snapshot Weight: 1
     *
     * @param symbol (optional)
     * @return ApiResponse&lt;QueryInsuranceFundBalanceSnapshotResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Insurance Fund Balance Snapshot </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Query-Insurance-Fund-Balance-Snapshot">Query
     *     Insurance Fund Balance Snapshot Documentation</a>
     */
    public ApiResponse<QueryInsuranceFundBalanceSnapshotResponse> queryInsuranceFundBalanceSnapshot(
            String symbol) throws ApiException {
        okhttp3.Call localVarCall = queryInsuranceFundBalanceSnapshotValidateBeforeCall(symbol);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<QueryInsuranceFundBalanceSnapshotResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for recentTradesList
     *
     * @param symbol (required)
     * @param limit Default 100; max 1000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Recent Trades List </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Recent-Trades-List">Recent
     *     Trades List Documentation</a>
     */
    private okhttp3.Call recentTradesListCall(String symbol, Long limit) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/trades";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call recentTradesListValidateBeforeCall(String symbol, Long limit)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, limit};
            Method method = this.getClass().getMethod("recentTradesList", String.class, Long.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return recentTradesListCall(symbol, limit);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Recent Trades List Get recent market trades * Market trades means trades filled in the order
     * book. Only market trades will be returned, which means the insurance fund trades and ADL
     * trades won&#39;t be returned. Weight: 5
     *
     * @param symbol (required)
     * @param limit Default 100; max 1000 (optional)
     * @return ApiResponse&lt;RecentTradesListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Recent Trades List </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Recent-Trades-List">Recent
     *     Trades List Documentation</a>
     */
    public ApiResponse<RecentTradesListResponse> recentTradesList(
            @NotNull String symbol, Long limit) throws ApiException {
        okhttp3.Call localVarCall = recentTradesListValidateBeforeCall(symbol, limit);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<RecentTradesListResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for symbolOrderBookTicker
     *
     * @param symbol (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Symbol Order Book Ticker </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Symbol-Order-Book-Ticker">Symbol
     *     Order Book Ticker Documentation</a>
     */
    private okhttp3.Call symbolOrderBookTickerCall(String symbol) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/ticker/bookTicker";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call symbolOrderBookTickerValidateBeforeCall(String symbol)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol};
            Method method = this.getClass().getMethod("symbolOrderBookTicker", String.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return symbolOrderBookTickerCall(symbol);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Symbol Order Book Ticker Best price/qty on the order book for a symbol or symbols. * If the
     * symbol is not sent, bookTickers for all symbols will be returned in an array. * The field
     * &#x60;X-MBX-USED-WEIGHT-1M&#x60; in response header is not accurate from this endpoint,
     * please ignore. Weight: 2 for a single symbol; 5 when the symbol parameter is omitted
     *
     * @param symbol (optional)
     * @return ApiResponse&lt;SymbolOrderBookTickerResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Symbol Order Book Ticker </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Symbol-Order-Book-Ticker">Symbol
     *     Order Book Ticker Documentation</a>
     */
    public ApiResponse<SymbolOrderBookTickerResponse> symbolOrderBookTicker(String symbol)
            throws ApiException {
        okhttp3.Call localVarCall = symbolOrderBookTickerValidateBeforeCall(symbol);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<SymbolOrderBookTickerResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for symbolPriceTicker
     *
     * @param symbol (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Symbol Price Ticker </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Symbol-Price-Ticker">Symbol
     *     Price Ticker(Deprecated) Documentation</a>
     */
    private okhttp3.Call symbolPriceTickerCall(String symbol) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/ticker/price";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call symbolPriceTickerValidateBeforeCall(String symbol) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol};
            Method method = this.getClass().getMethod("symbolPriceTicker", String.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return symbolPriceTickerCall(symbol);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Symbol Price Ticker(Deprecated) Latest price for a symbol or symbols. * If the symbol is not
     * sent, prices for all symbols will be returned in an array. Weight: 1 for a single symbol; 2
     * when the symbol parameter is omitted
     *
     * @param symbol (optional)
     * @return ApiResponse&lt;SymbolPriceTickerResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Symbol Price Ticker </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Symbol-Price-Ticker">Symbol
     *     Price Ticker(Deprecated) Documentation</a>
     */
    public ApiResponse<SymbolPriceTickerResponse> symbolPriceTicker(String symbol)
            throws ApiException {
        okhttp3.Call localVarCall = symbolPriceTickerValidateBeforeCall(symbol);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<SymbolPriceTickerResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for symbolPriceTickerV2
     *
     * @param symbol (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Symbol Price Ticker V2 </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Symbol-Price-Ticker-V2">Symbol
     *     Price Ticker V2 Documentation</a>
     */
    private okhttp3.Call symbolPriceTickerV2Call(String symbol) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v2/ticker/price";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call symbolPriceTickerV2ValidateBeforeCall(String symbol) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol};
            Method method = this.getClass().getMethod("symbolPriceTickerV2", String.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return symbolPriceTickerV2Call(symbol);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Symbol Price Ticker V2 Latest price for a symbol or symbols. * If the symbol is not sent,
     * prices for all symbols will be returned in an array. * The field
     * &#x60;X-MBX-USED-WEIGHT-1M&#x60; in response header is not accurate from this endpoint,
     * please ignore. Weight: 1 for a single symbol; 2 when the symbol parameter is omitted
     *
     * @param symbol (optional)
     * @return ApiResponse&lt;SymbolPriceTickerV2Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Symbol Price Ticker V2 </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Symbol-Price-Ticker-V2">Symbol
     *     Price Ticker V2 Documentation</a>
     */
    public ApiResponse<SymbolPriceTickerV2Response> symbolPriceTickerV2(String symbol)
            throws ApiException {
        okhttp3.Call localVarCall = symbolPriceTickerV2ValidateBeforeCall(symbol);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<SymbolPriceTickerV2Response>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for takerBuySellVolume
     *
     * @param symbol (required)
     * @param period
     *     \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot;
     *     (required)
     * @param limit Default 100; max 1000 (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Taker Buy/Sell Volume </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Taker-BuySell-Volume">Taker
     *     Buy/Sell Volume Documentation</a>
     */
    private okhttp3.Call takerBuySellVolumeCall(
            String symbol, Period period, Long limit, Long startTime, Long endTime)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/futures/data/takerlongshortRatio";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (period != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("period", period));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call takerBuySellVolumeValidateBeforeCall(
            String symbol, Period period, Long limit, Long startTime, Long endTime)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, period, limit, startTime, endTime};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "takerBuySellVolume",
                                    String.class,
                                    Period.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return takerBuySellVolumeCall(symbol, period, limit, startTime, endTime);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Taker Buy/Sell Volume Taker Buy/Sell Volume * If startTime and endTime are not sent, the most
     * recent data is returned. * Only the data of the latest 30 days is available. * IP rate limit
     * 1000 requests/5min Weight: 0
     *
     * @param symbol (required)
     * @param period
     *     \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot;
     *     (required)
     * @param limit Default 100; max 1000 (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @return ApiResponse&lt;TakerBuySellVolumeResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Taker Buy/Sell Volume </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Taker-BuySell-Volume">Taker
     *     Buy/Sell Volume Documentation</a>
     */
    public ApiResponse<TakerBuySellVolumeResponse> takerBuySellVolume(
            @NotNull String symbol,
            @NotNull Period period,
            Long limit,
            Long startTime,
            Long endTime)
            throws ApiException {
        okhttp3.Call localVarCall =
                takerBuySellVolumeValidateBeforeCall(symbol, period, limit, startTime, endTime);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<TakerBuySellVolumeResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for testConnectivity
     *
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Test-Connectivity">Test
     *     Connectivity Documentation</a>
     */
    private okhttp3.Call testConnectivityCall() throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/ping";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call testConnectivityValidateBeforeCall() throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {};
            Method method = this.getClass().getMethod("testConnectivity");
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return testConnectivityCall();
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Test Connectivity Test connectivity to the Rest API. Weight: 1
     *
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Test-Connectivity">Test
     *     Connectivity Documentation</a>
     */
    public ApiResponse<Void> testConnectivity() throws ApiException {
        okhttp3.Call localVarCall = testConnectivityValidateBeforeCall();
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Build call for ticker24hrPriceChangeStatistics
     *
     * @param symbol (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> 24hr Ticker Price Change Statistics </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/24hr-Ticker-Price-Change-Statistics">24hr
     *     Ticker Price Change Statistics Documentation</a>
     */
    private okhttp3.Call ticker24hrPriceChangeStatisticsCall(String symbol) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/fapi/v1/ticker/24hr";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call ticker24hrPriceChangeStatisticsValidateBeforeCall(String symbol)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol};
            Method method =
                    this.getClass().getMethod("ticker24hrPriceChangeStatistics", String.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return ticker24hrPriceChangeStatisticsCall(symbol);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * 24hr Ticker Price Change Statistics 24 hour rolling window price change statistics.
     * **Careful** when accessing this with no symbol. * If the symbol is not sent, tickers for all
     * symbols will be returned in an array. Weight: 1 for a single symbol; 40 when the symbol
     * parameter is omitted
     *
     * @param symbol (optional)
     * @return ApiResponse&lt;Ticker24hrPriceChangeStatisticsResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> 24hr Ticker Price Change Statistics </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/24hr-Ticker-Price-Change-Statistics">24hr
     *     Ticker Price Change Statistics Documentation</a>
     */
    public ApiResponse<Ticker24hrPriceChangeStatisticsResponse> ticker24hrPriceChangeStatistics(
            String symbol) throws ApiException {
        okhttp3.Call localVarCall = ticker24hrPriceChangeStatisticsValidateBeforeCall(symbol);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<Ticker24hrPriceChangeStatisticsResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for topTraderLongShortRatioAccounts
     *
     * @param symbol (required)
     * @param period
     *     \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot;
     *     (required)
     * @param limit Default 100; max 1000 (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Top Trader Long/Short Ratio </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Top-Long-Short-Account-Ratio">Top
     *     Trader Long/Short Ratio (Accounts) Documentation</a>
     */
    private okhttp3.Call topTraderLongShortRatioAccountsCall(
            String symbol, Period period, Long limit, Long startTime, Long endTime)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/futures/data/topLongShortAccountRatio";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (period != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("period", period));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call topTraderLongShortRatioAccountsValidateBeforeCall(
            String symbol, Period period, Long limit, Long startTime, Long endTime)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, period, limit, startTime, endTime};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "topTraderLongShortRatioAccounts",
                                    String.class,
                                    Period.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return topTraderLongShortRatioAccountsCall(
                        symbol, period, limit, startTime, endTime);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Top Trader Long/Short Ratio (Accounts) The proportion of net long and net short accounts to
     * total accounts of the top 20% users with the highest margin balance. Each account is counted
     * once only. Long Account % &#x3D; Accounts of top traders with net long positions / Total
     * accounts of top traders with open positions Short Account % &#x3D; Accounts of top traders
     * with net short positions / Total accounts of top traders with open positions Long/Short Ratio
     * (Accounts) &#x3D; Long Account % / Short Account % * If startTime and endTime are not sent,
     * the most recent data is returned. * Only the data of the latest 30 days is available. * IP
     * rate limit 1000 requests/5min Weight: 0
     *
     * @param symbol (required)
     * @param period
     *     \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot;
     *     (required)
     * @param limit Default 100; max 1000 (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @return ApiResponse&lt;TopTraderLongShortRatioAccountsResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Top Trader Long/Short Ratio </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Top-Long-Short-Account-Ratio">Top
     *     Trader Long/Short Ratio (Accounts) Documentation</a>
     */
    public ApiResponse<TopTraderLongShortRatioAccountsResponse> topTraderLongShortRatioAccounts(
            @NotNull String symbol,
            @NotNull Period period,
            Long limit,
            Long startTime,
            Long endTime)
            throws ApiException {
        okhttp3.Call localVarCall =
                topTraderLongShortRatioAccountsValidateBeforeCall(
                        symbol, period, limit, startTime, endTime);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<TopTraderLongShortRatioAccountsResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for topTraderLongShortRatioPositions
     *
     * @param symbol (required)
     * @param period
     *     \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot;
     *     (required)
     * @param limit Default 100; max 1000 (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Top Trader Long/Short Ratio </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Top-Trader-Long-Short-Ratio">Top
     *     Trader Long/Short Ratio (Positions) Documentation</a>
     */
    private okhttp3.Call topTraderLongShortRatioPositionsCall(
            String symbol, Period period, Long limit, Long startTime, Long endTime)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/futures/data/topLongShortPositionRatio";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (period != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("period", period));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (!localVarFormParams.isEmpty() && localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        Set<String> localVarAuthNames = new HashSet<>();
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call topTraderLongShortRatioPositionsValidateBeforeCall(
            String symbol, Period period, Long limit, Long startTime, Long endTime)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, period, limit, startTime, endTime};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "topTraderLongShortRatioPositions",
                                    String.class,
                                    Period.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<MarketDataApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return topTraderLongShortRatioPositionsCall(
                        symbol, period, limit, startTime, endTime);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Top Trader Long/Short Ratio (Positions) The proportion of net long and net short positions to
     * total open positions of the top 20% users with the highest margin balance. Long Position %
     * &#x3D; Long positions of top traders / Total open positions of top traders Short Position %
     * &#x3D; Short positions of top traders / Total open positions of top traders Long/Short Ratio
     * (Positions) &#x3D; Long Position % / Short Position % * If startTime and endTime are not
     * sent, the most recent data is returned. * Only the data of the latest 30 days is available. *
     * IP rate limit 1000 requests/5min Weight: 0
     *
     * @param symbol (required)
     * @param period
     *     \&quot;5m\&quot;,\&quot;15m\&quot;,\&quot;30m\&quot;,\&quot;1h\&quot;,\&quot;2h\&quot;,\&quot;4h\&quot;,\&quot;6h\&quot;,\&quot;12h\&quot;,\&quot;1d\&quot;
     *     (required)
     * @param limit Default 100; max 1000 (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @return ApiResponse&lt;TopTraderLongShortRatioPositionsResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Top Trader Long/Short Ratio </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Top-Trader-Long-Short-Ratio">Top
     *     Trader Long/Short Ratio (Positions) Documentation</a>
     */
    public ApiResponse<TopTraderLongShortRatioPositionsResponse> topTraderLongShortRatioPositions(
            @NotNull String symbol,
            @NotNull Period period,
            Long limit,
            Long startTime,
            Long endTime)
            throws ApiException {
        okhttp3.Call localVarCall =
                topTraderLongShortRatioPositionsValidateBeforeCall(
                        symbol, period, limit, startTime, endTime);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<TopTraderLongShortRatioPositionsResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }
}
