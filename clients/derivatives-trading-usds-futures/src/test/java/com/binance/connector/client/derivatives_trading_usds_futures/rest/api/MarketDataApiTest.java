/*
 * Binance Derivatives Trading USDS Futures REST API
 * OpenAPI Specification for the Binance Derivatives Trading USDS Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_usds_futures.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.BasisResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.CheckServerTimeResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.CompositeIndexSymbolInformationResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.CompressedAggregateTradesListResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ContinuousContractKlineCandlestickDataResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ContractType;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ExchangeInformationResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.GetFundingRateHistoryResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.GetFundingRateInfoResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.HistoricalBlvtNavKlineCandlestickResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.IndexPriceKlineCandlestickDataResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.Interval;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.KlineCandlestickDataResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.LongShortRatioResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.MarkPriceKlineCandlestickDataResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.MarkPriceResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.MultiAssetsModeAssetIndexResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.OldTradesLookupResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.OpenInterestResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.OpenInterestStatisticsResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.OrderBookResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.Period;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.PremiumIndexKlineDataResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.QuarterlyContractSettlementPriceResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.QueryIndexPriceConstituentsResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.RecentTradesListResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.SymbolOrderBookTickerResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.SymbolPriceTickerResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.SymbolPriceTickerV2Response;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.TakerBuySellVolumeResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.Ticker24hrPriceChangeStatisticsResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.TopTraderLongShortRatioAccountsResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.TopTraderLongShortRatioPositionsResponse;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for MarketDataApi */
public class MarketDataApiTest {

    private MarketDataApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new MarketDataApi(apiClientSpy);
    }

    /**
     * Basis
     *
     * <p>Query future basis * If startTime and endTime are not sent, the most recent data is
     * returned. * Only the data of the latest 30 days is available. Weight: 0
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void basisTest() throws ApiException, CryptoException {
        String pair = "";
        ContractType contractType = ContractType.PERPETUAL;
        Period period = Period.PERIOD_5m;
        Long limit = 30L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        ApiResponse<BasisResponse> response =
                api.basis(pair, contractType, period, limit, startTime, endTime);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/futures/data/basis", actualRequest.url().encodedPath());
    }

    /**
     * Check Server Time
     *
     * <p>Test connectivity to the Rest API and get the current server time. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void checkServerTimeTest() throws ApiException, CryptoException {
        ApiResponse<CheckServerTimeResponse> response = api.checkServerTime();

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/time", actualRequest.url().encodedPath());
    }

    /**
     * Composite Index Symbol Information
     *
     * <p>Query composite index symbol information * Only for composite index symbols Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void compositeIndexSymbolInformationTest() throws ApiException, CryptoException {
        String symbol = "";
        ApiResponse<CompositeIndexSymbolInformationResponse> response =
                api.compositeIndexSymbolInformation(symbol);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/indexInfo", actualRequest.url().encodedPath());
    }

    /**
     * Compressed/Aggregate Trades List
     *
     * <p>Get compressed, aggregate market trades. Market trades that fill in 100ms with the same
     * price and the same taking side will have the quantity aggregated. * support querying futures
     * trade histories that are not older than one year * If both &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; are sent, time between &#x60;startTime&#x60; and &#x60;endTime&#x60; must
     * be less than 1 hour. * If &#x60;fromId&#x60;, &#x60;startTime&#x60;, and &#x60;endTime&#x60;
     * are not sent, the most recent aggregate trades will be returned. * Only market trades will be
     * aggregated and returned, which means the insurance fund trades and ADL trades won&#39;t be
     * aggregated. * Sending both &#x60;startTime&#x60;/&#x60;endTime&#x60; and &#x60;fromId&#x60;
     * might cause response timeout, please send either &#x60;fromId&#x60; or
     * &#x60;startTime&#x60;/&#x60;endTime&#x60; Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void compressedAggregateTradesListTest() throws ApiException, CryptoException {
        String symbol = "";
        Long fromId = 1L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        ApiResponse<CompressedAggregateTradesListResponse> response =
                api.compressedAggregateTradesList(symbol, fromId, startTime, endTime, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/aggTrades", actualRequest.url().encodedPath());
    }

    /**
     * Continuous Contract Kline/Candlestick Data
     *
     * <p>Kline/candlestick bars for a specific contract type. Klines are uniquely identified by
     * their open time. * If startTime and endTime are not sent, the most recent klines are
     * returned. * Contract type: * PERPETUAL * CURRENT_QUARTER * NEXT_QUARTER Weight: based on
     * parameter LIMIT | LIMIT | weight | | ----------- | ------ | | [1,100) | 1 | | [100, 500) | 2
     * | | [500, 1000] | 5 | | &gt; 1000 | 10 |
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void continuousContractKlineCandlestickDataTest() throws ApiException, CryptoException {
        String pair = "";
        ContractType contractType = ContractType.PERPETUAL;
        Interval interval = Interval.INTERVAL_1m;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        ApiResponse<ContinuousContractKlineCandlestickDataResponse> response =
                api.continuousContractKlineCandlestickData(
                        pair, contractType, interval, startTime, endTime, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/continuousKlines", actualRequest.url().encodedPath());
    }

    /**
     * Exchange Information
     *
     * <p>Current exchange trading rules and symbol information Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void exchangeInformationTest() throws ApiException, CryptoException {
        ApiResponse<ExchangeInformationResponse> response = api.exchangeInformation();

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/exchangeInfo", actualRequest.url().encodedPath());
    }

    /**
     * Get Funding Rate History
     *
     * <p>Get Funding Rate History * If &#x60;startTime&#x60; and &#x60;endTime&#x60; are not sent,
     * the most recent &#x60;limit&#x60; datas are returned. * If the number of data between
     * &#x60;startTime&#x60; and &#x60;endTime&#x60; is larger than &#x60;limit&#x60;, return as
     * &#x60;startTime&#x60; + &#x60;limit&#x60;. * In ascending order. Weight: share 500/5min/IP
     * rate limit with GET /fapi/v1/fundingInfo
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFundingRateHistoryTest() throws ApiException, CryptoException {
        String symbol = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        ApiResponse<GetFundingRateHistoryResponse> response =
                api.getFundingRateHistory(symbol, startTime, endTime, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/fundingRate", actualRequest.url().encodedPath());
    }

    /**
     * Get Funding Rate Info
     *
     * <p>Query funding rate info for symbols that had FundingRateCap/ FundingRateFloor /
     * fundingIntervalHours adjustment Weight: 0 share 500/5min/IP rate limit with GET
     * /fapi/v1/fundingInfo
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFundingRateInfoTest() throws ApiException, CryptoException {
        ApiResponse<GetFundingRateInfoResponse> response = api.getFundingRateInfo();

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/fundingInfo", actualRequest.url().encodedPath());
    }

    /**
     * Historical BLVT NAV Kline/Candlestick
     *
     * <p>The BLVT NAV system is based on Binance Futures, so the endpoint is based on fapi Weight:
     * 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void historicalBlvtNavKlineCandlestickTest() throws ApiException, CryptoException {
        String symbol = "";
        Interval interval = Interval.INTERVAL_1m;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        ApiResponse<HistoricalBlvtNavKlineCandlestickResponse> response =
                api.historicalBlvtNavKlineCandlestick(symbol, interval, startTime, endTime, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/lvtKlines", actualRequest.url().encodedPath());
    }

    /**
     * Index Price Kline/Candlestick Data
     *
     * <p>Kline/candlestick bars for the index price of a pair. Klines are uniquely identified by
     * their open time. * If startTime and endTime are not sent, the most recent klines are
     * returned. Weight: based on parameter LIMIT | LIMIT | weight | | ----------- | ------ | |
     * [1,100) | 1 | | [100, 500) | 2 | | [500, 1000] | 5 | | &gt; 1000 | 10 |
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void indexPriceKlineCandlestickDataTest() throws ApiException, CryptoException {
        String pair = "";
        Interval interval = Interval.INTERVAL_1m;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        ApiResponse<IndexPriceKlineCandlestickDataResponse> response =
                api.indexPriceKlineCandlestickData(pair, interval, startTime, endTime, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/indexPriceKlines", actualRequest.url().encodedPath());
    }

    /**
     * Kline/Candlestick Data
     *
     * <p>Kline/candlestick bars for a symbol. Klines are uniquely identified by their open time. *
     * If startTime and endTime are not sent, the most recent klines are returned. Weight: based on
     * parameter LIMIT | LIMIT | weight | | ----------- | ------ | | [1,100) | 1 | | [100, 500) | 2
     * | | [500, 1000] | 5 | | &gt; 1000 | 10 |
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void klineCandlestickDataTest() throws ApiException, CryptoException {
        String symbol = "";
        Interval interval = Interval.INTERVAL_1m;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        ApiResponse<KlineCandlestickDataResponse> response =
                api.klineCandlestickData(symbol, interval, startTime, endTime, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/klines", actualRequest.url().encodedPath());
    }

    /**
     * Long/Short Ratio
     *
     * <p>Query symbol Long/Short Ratio * If startTime and endTime are not sent, the most recent
     * data is returned. * Only the data of the latest 30 days is available. * IP rate limit 1000
     * requests/5min Weight: 0
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void longShortRatioTest() throws ApiException, CryptoException {
        String symbol = "";
        Period period = Period.PERIOD_5m;
        Long limit = 100L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        ApiResponse<LongShortRatioResponse> response =
                api.longShortRatio(symbol, period, limit, startTime, endTime);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/futures/data/globalLongShortAccountRatio", actualRequest.url().encodedPath());
    }

    /**
     * Mark Price
     *
     * <p>Mark Price and Funding Rate Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void markPriceTest() throws ApiException, CryptoException {
        String symbol = "";
        ApiResponse<MarkPriceResponse> response = api.markPrice(symbol);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/premiumIndex", actualRequest.url().encodedPath());
    }

    /**
     * Mark Price Kline/Candlestick Data
     *
     * <p>Kline/candlestick bars for the mark price of a symbol. Klines are uniquely identified by
     * their open time. * If startTime and endTime are not sent, the most recent klines are
     * returned. Weight: based on parameter LIMIT | LIMIT | weight | | ----------- | ------ | |
     * [1,100) | 1 | | [100, 500) | 2 | | [500, 1000] | 5 | | &gt; 1000 | 10 |
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void markPriceKlineCandlestickDataTest() throws ApiException, CryptoException {
        String symbol = "";
        Interval interval = Interval.INTERVAL_1m;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        ApiResponse<MarkPriceKlineCandlestickDataResponse> response =
                api.markPriceKlineCandlestickData(symbol, interval, startTime, endTime, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/markPriceKlines", actualRequest.url().encodedPath());
    }

    /**
     * Multi-Assets Mode Asset Index
     *
     * <p>asset index for Multi-Assets mode Weight: 1 for a single symbol; 10 when the symbol
     * parameter is omitted
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void multiAssetsModeAssetIndexTest() throws ApiException, CryptoException {
        String symbol = "";
        ApiResponse<MultiAssetsModeAssetIndexResponse> response =
                api.multiAssetsModeAssetIndex(symbol);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/assetIndex", actualRequest.url().encodedPath());
    }

    /**
     * Old Trades Lookup (MARKET_DATA)
     *
     * <p>Get older market historical trades. * Market trades means trades filled in the order book.
     * Only market trades will be returned, which means the insurance fund trades and ADL trades
     * won&#39;t be returned. * Only supports data from within the last three months Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void oldTradesLookupTest() throws ApiException, CryptoException {
        String symbol = "";
        Long limit = 100L;
        Long fromId = 1L;
        ApiResponse<OldTradesLookupResponse> response = api.oldTradesLookup(symbol, limit, fromId);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/historicalTrades", actualRequest.url().encodedPath());
    }

    /**
     * Open Interest
     *
     * <p>Get present open interest of a specific symbol. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void openInterestTest() throws ApiException, CryptoException {
        String symbol = "";
        ApiResponse<OpenInterestResponse> response = api.openInterest(symbol);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/openInterest", actualRequest.url().encodedPath());
    }

    /**
     * Open Interest Statistics
     *
     * <p>Open Interest Statistics * If startTime and endTime are not sent, the most recent data is
     * returned. * Only the data of the latest 1 month is available. * IP rate limit 1000
     * requests/5min Weight: 0
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void openInterestStatisticsTest() throws ApiException, CryptoException {
        String symbol = "";
        Period period = Period.PERIOD_5m;
        Long limit = 100L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        ApiResponse<OpenInterestStatisticsResponse> response =
                api.openInterestStatistics(symbol, period, limit, startTime, endTime);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/futures/data/openInterestHist", actualRequest.url().encodedPath());
    }

    /**
     * Order Book
     *
     * <p>Query symbol orderbook Weight: Adjusted based on the limit: | Limit | Weight | |
     * ------------- | ------ | | 5, 10, 20, 50 | 2 | | 100 | 5 | | 500 | 10 | | 1000 | 20 |
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void orderBookTest() throws ApiException, CryptoException {
        String symbol = "";
        Long limit = 100L;
        ApiResponse<OrderBookResponse> response = api.orderBook(symbol, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/depth", actualRequest.url().encodedPath());
    }

    /**
     * Premium index Kline Data
     *
     * <p>Premium index kline bars of a symbol. Klines are uniquely identified by their open time. *
     * If startTime and endTime are not sent, the most recent klines are returned. Weight: based on
     * parameter LIMIT | LIMIT | weight | | ----------- | ------ | | [1,100) | 1 | | [100, 500) | 2
     * | | [500, 1000] | 5 | | &gt; 1000 | 10 |
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void premiumIndexKlineDataTest() throws ApiException, CryptoException {
        String symbol = "";
        Interval interval = Interval.INTERVAL_1m;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        ApiResponse<PremiumIndexKlineDataResponse> response =
                api.premiumIndexKlineData(symbol, interval, startTime, endTime, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/premiumIndexKlines", actualRequest.url().encodedPath());
    }

    /**
     * Quarterly Contract Settlement Price
     *
     * <p>Latest price for a symbol or symbols. Weight: 0
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void quarterlyContractSettlementPriceTest() throws ApiException, CryptoException {
        String pair = "";
        ApiResponse<QuarterlyContractSettlementPriceResponse> response =
                api.quarterlyContractSettlementPrice(pair);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/futures/data/delivery-price", actualRequest.url().encodedPath());
    }

    /**
     * Query Index Price Constituents
     *
     * <p>Query index price constituents Weight: 2
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryIndexPriceConstituentsTest() throws ApiException, CryptoException {
        String symbol = "";
        ApiResponse<QueryIndexPriceConstituentsResponse> response =
                api.queryIndexPriceConstituents(symbol);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/constituents", actualRequest.url().encodedPath());
    }

    /**
     * Recent Trades List
     *
     * <p>Get recent market trades * Market trades means trades filled in the order book. Only
     * market trades will be returned, which means the insurance fund trades and ADL trades
     * won&#39;t be returned. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void recentTradesListTest() throws ApiException, CryptoException {
        String symbol = "";
        Long limit = 100L;
        ApiResponse<RecentTradesListResponse> response = api.recentTradesList(symbol, limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/trades", actualRequest.url().encodedPath());
    }

    /**
     * Symbol Order Book Ticker
     *
     * <p>Best price/qty on the order book for a symbol or symbols. * If the symbol is not sent,
     * bookTickers for all symbols will be returned in an array. * The field
     * &#x60;X-MBX-USED-WEIGHT-1M&#x60; in response header is not accurate from this endpoint,
     * please ignore. Weight: 2 for a single symbol; 5 when the symbol parameter is omitted
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void symbolOrderBookTickerTest() throws ApiException, CryptoException {
        String symbol = "";
        ApiResponse<SymbolOrderBookTickerResponse> response = api.symbolOrderBookTicker(symbol);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/ticker/bookTicker", actualRequest.url().encodedPath());
    }

    /**
     * Symbol Price Ticker
     *
     * <p>Latest price for a symbol or symbols. * If the symbol is not sent, prices for all symbols
     * will be returned in an array. Weight: 1 for a single symbol; 2 when the symbol parameter is
     * omitted
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void symbolPriceTickerTest() throws ApiException, CryptoException {
        String symbol = "";
        ApiResponse<SymbolPriceTickerResponse> response = api.symbolPriceTicker(symbol);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/ticker/price", actualRequest.url().encodedPath());
    }

    /**
     * Symbol Price Ticker V2
     *
     * <p>Latest price for a symbol or symbols. * If the symbol is not sent, prices for all symbols
     * will be returned in an array. * The field &#x60;X-MBX-USED-WEIGHT-1M&#x60; in response header
     * is not accurate from this endpoint, please ignore. Weight: 1 for a single symbol; 2 when the
     * symbol parameter is omitted
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void symbolPriceTickerV2Test() throws ApiException, CryptoException {
        String symbol = "";
        ApiResponse<SymbolPriceTickerV2Response> response = api.symbolPriceTickerV2(symbol);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v2/ticker/price", actualRequest.url().encodedPath());
    }

    /**
     * Taker Buy/Sell Volume
     *
     * <p>Taker Buy/Sell Volume * If startTime and endTime are not sent, the most recent data is
     * returned. * Only the data of the latest 30 days is available. * IP rate limit 1000
     * requests/5min Weight: 0
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void takerBuySellVolumeTest() throws ApiException, CryptoException {
        String symbol = "";
        Period period = Period.PERIOD_5m;
        Long limit = 100L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        ApiResponse<TakerBuySellVolumeResponse> response =
                api.takerBuySellVolume(symbol, period, limit, startTime, endTime);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/futures/data/takerlongshortRatio", actualRequest.url().encodedPath());
    }

    /**
     * Test Connectivity
     *
     * <p>Test connectivity to the Rest API. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void testConnectivityTest() throws ApiException, CryptoException {
        api.testConnectivity();

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy).execute(callArgumentCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/ping", actualRequest.url().encodedPath());
    }

    /**
     * 24hr Ticker Price Change Statistics
     *
     * <p>24 hour rolling window price change statistics. **Careful** when accessing this with no
     * symbol. * If the symbol is not sent, tickers for all symbols will be returned in an array.
     * Weight: 1 for a single symbol; 40 when the symbol parameter is omitted
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void ticker24hrPriceChangeStatisticsTest() throws ApiException, CryptoException {
        String symbol = "";
        ApiResponse<Ticker24hrPriceChangeStatisticsResponse> response =
                api.ticker24hrPriceChangeStatistics(symbol);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/ticker/24hr", actualRequest.url().encodedPath());
    }

    /**
     * Top Trader Long/Short Ratio (Accounts)
     *
     * <p>The proportion of net long and net short accounts to total accounts of the top 20% users
     * with the highest margin balance. Each account is counted once only. Long Account % &#x3D;
     * Accounts of top traders with net long positions / Total accounts of top traders with open
     * positions Short Account % &#x3D; Accounts of top traders with net short positions / Total
     * accounts of top traders with open positions Long/Short Ratio (Accounts) &#x3D; Long Account %
     * / Short Account % * If startTime and endTime are not sent, the most recent data is returned.
     * * Only the data of the latest 30 days is available. * IP rate limit 1000 requests/5min
     * Weight: 0
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void topTraderLongShortRatioAccountsTest() throws ApiException, CryptoException {
        String symbol = "";
        Period period = Period.PERIOD_5m;
        Long limit = 100L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        ApiResponse<TopTraderLongShortRatioAccountsResponse> response =
                api.topTraderLongShortRatioAccounts(symbol, period, limit, startTime, endTime);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/futures/data/topLongShortAccountRatio", actualRequest.url().encodedPath());
    }

    /**
     * Top Trader Long/Short Ratio (Positions)
     *
     * <p>The proportion of net long and net short positions to total open positions of the top 20%
     * users with the highest margin balance. Long Position % &#x3D; Long positions of top traders /
     * Total open positions of top traders Short Position % &#x3D; Short positions of top traders /
     * Total open positions of top traders Long/Short Ratio (Positions) &#x3D; Long Position % /
     * Short Position % * If startTime and endTime are not sent, the most recent data is returned. *
     * Only the data of the latest 30 days is available. * IP rate limit 1000 requests/5min Weight:
     * 0
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void topTraderLongShortRatioPositionsTest() throws ApiException, CryptoException {
        String symbol = "";
        Period period = Period.PERIOD_5m;
        Long limit = 100L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        ApiResponse<TopTraderLongShortRatioPositionsResponse> response =
                api.topTraderLongShortRatioPositions(symbol, period, limit, startTime, endTime);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/futures/data/topLongShortPositionRatio", actualRequest.url().encodedPath());
    }
}
