/*
 * Binance Derivatives Trading USDS Futures REST API
 * OpenAPI Specification for the Binance Derivatives Trading USDS Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_usds_futures.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.AccountTradeListResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.AllOrdersResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.AutoCancelAllOpenOrdersRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.AutoCancelAllOpenOrdersResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.AutoCloseType;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.BatchOrders;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.BatchOrdersPlaceMultipleOrders;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.CancelAllOpenOrdersResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.CancelMultipleOrdersResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.CancelOrderResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ChangeInitialLeverageRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ChangeInitialLeverageResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ChangeMarginTypeRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ChangeMarginTypeResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ChangeMultiAssetsModeRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ChangeMultiAssetsModeResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ChangePositionModeRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ChangePositionModeResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.CurrentAllOpenOrdersResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.GetOrderModifyHistoryResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.GetPositionMarginChangeHistoryResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.MarginType;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ModifyIsolatedPositionMarginRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ModifyIsolatedPositionMarginResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ModifyMultipleOrdersRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ModifyMultipleOrdersResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ModifyOrderRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ModifyOrderResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.NewOrderRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.NewOrderResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.OrderIdList;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.OrigClientOrderIdList;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.PlaceMultipleOrdersRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.PlaceMultipleOrdersResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.PositionAdlQuantileEstimationResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.PositionInformationV2Response;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.PositionInformationV3Response;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.QueryCurrentOpenOrderResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.QueryOrderResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.Side;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.TestOrderRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.TestOrderResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.UsersForceOrdersResponse;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for TradeApi */
public class TradeApiTest {

    private TradeApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new TradeApi(apiClientSpy);
    }

    /**
     * Account Trade List (USER_DATA)
     *
     * <p>Get trades for a specific account and symbol. * If &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; are both not sent, then the last 7 days&#39; data will be returned. * The
     * time between &#x60;startTime&#x60; and &#x60;endTime&#x60; cannot be longer than 7 days. *
     * The parameter &#x60;fromId&#x60; cannot be sent with &#x60;startTime&#x60; or
     * &#x60;endTime&#x60;. * Only support querying trade in the past 6 months Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void accountTradeListTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long fromId = 1L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<AccountTradeListResponse> response =
                api.accountTradeList(
                        symbol, orderId, startTime, endTime, fromId, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&orderId=1&startTime=1623319461670&endTime=1641782889000&fromId=1&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "10058794572cc782968aa3d3e6b73a369146898e471235e8712344dea70cb4d5",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/userTrades", actualRequest.url().encodedPath());
    }

    /**
     * All Orders (USER_DATA)
     *
     * <p>Get all account orders; active, canceled, or filled. * These orders will not be found: *
     * order status is &#x60;CANCELED&#x60; or &#x60;EXPIRED&#x60; **AND** order has NO filled trade
     * **AND** created time + 3 days &lt; current time * order create time + 90 days &lt; current
     * time * If &#x60;orderId&#x60; is set, it will get orders &gt;&#x3D; that &#x60;orderId&#x60;.
     * Otherwise most recent orders are returned. * The query time period must be less then 7 days(
     * default as the recent 7 days). Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void allOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<AllOrdersResponse> response =
                api.allOrders(symbol, orderId, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&orderId=1&startTime=1623319461670&endTime=1641782889000&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "dc0808314025fc813dcde0328cd6754c982d28888760fc74b17e072087eb4895",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/allOrders", actualRequest.url().encodedPath());
    }

    /**
     * Auto-Cancel All Open Orders (TRADE)
     *
     * <p>Cancel all open orders of the specified symbol at the end of the specified countdown. The
     * endpoint should be called repeatedly as heartbeats so that the existing countdown time can be
     * canceled and replaced by a new one. * Example usage: Call this endpoint at 30s intervals with
     * an countdownTime of 120000 (120s). If this endpoint is not called within 120 seconds, all
     * your orders of the specified symbol will be automatically canceled. If this endpoint is
     * called with an countdownTime of 0, the countdown timer will be stopped. The system will check
     * all countdowns **approximately every 10 milliseconds**, so please note that sufficient
     * redundancy should be considered when using this function. We do not recommend setting the
     * countdown time to be too precise or too small. Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void autoCancelAllOpenOrdersTest() throws ApiException, CryptoException {
        AutoCancelAllOpenOrdersRequest autoCancelAllOpenOrdersRequest =
                new AutoCancelAllOpenOrdersRequest();

        autoCancelAllOpenOrdersRequest.symbol("");
        autoCancelAllOpenOrdersRequest.countdownTime(0L);

        ApiResponse<AutoCancelAllOpenOrdersResponse> response =
                api.autoCancelAllOpenOrders(autoCancelAllOpenOrdersRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000symbol=&countdownTime=0", signInputCaptor.getValue());
        assertEquals(
                "42826e2320d45fba6a83c5a5da223ab9f7e622a05303b8d5507c99448d3a0a88",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/countdownCancelAll", actualRequest.url().encodedPath());
    }

    /**
     * Cancel All Open Orders (TRADE)
     *
     * <p>Cancel All Open Orders Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelAllOpenOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<CancelAllOpenOrdersResponse> response =
                api.cancelAllOpenOrders(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/allOpenOrders", actualRequest.url().encodedPath());
    }

    /**
     * Cancel Multiple Orders (TRADE)
     *
     * <p>Cancel Multiple Orders * Either &#x60;orderIdList&#x60; or &#x60;origClientOrderIdList
     * &#x60; must be sent. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelMultipleOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        OrderIdList orderIdList = null;
        OrigClientOrderIdList origClientOrderIdList = null;
        Long recvWindow = 5000L;
        ApiResponse<CancelMultipleOrdersResponse> response =
                api.cancelMultipleOrders(symbol, orderIdList, origClientOrderIdList, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/batchOrders", actualRequest.url().encodedPath());
    }

    /**
     * Cancel Order (TRADE)
     *
     * <p>Cancel an active order. * Either &#x60;orderId&#x60; or &#x60;origClientOrderId&#x60; must
     * be sent. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelOrderTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        String origClientOrderId = "1";
        Long recvWindow = 5000L;
        ApiResponse<CancelOrderResponse> response =
                api.cancelOrder(symbol, orderId, origClientOrderId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&orderId=1&origClientOrderId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "cbec82483be2ad044b893ffb2e6bc0d55370e378eaea0b4b61d95893bd9cc458",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/order", actualRequest.url().encodedPath());
    }

    /**
     * Change Initial Leverage(TRADE)
     *
     * <p>Change user&#39;s initial leverage of specific symbol market. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void changeInitialLeverageTest() throws ApiException, CryptoException {
        ChangeInitialLeverageRequest changeInitialLeverageRequest =
                new ChangeInitialLeverageRequest();

        changeInitialLeverageRequest.symbol("");
        changeInitialLeverageRequest.leverage(0L);

        ApiResponse<ChangeInitialLeverageResponse> response =
                api.changeInitialLeverage(changeInitialLeverageRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000symbol=&leverage=0", signInputCaptor.getValue());
        assertEquals(
                "31c40eeb1a5a52384cff8a195c1c312e32b26a672ad8fb71dc96256a61c4101c",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/leverage", actualRequest.url().encodedPath());
    }

    /**
     * Change Margin Type(TRADE)
     *
     * <p>Change symbol level margin type Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void changeMarginTypeTest() throws ApiException, CryptoException {
        ChangeMarginTypeRequest changeMarginTypeRequest = new ChangeMarginTypeRequest();

        changeMarginTypeRequest.symbol("");
        changeMarginTypeRequest.marginType(MarginType.ISOLATED);

        ApiResponse<ChangeMarginTypeResponse> response =
                api.changeMarginType(changeMarginTypeRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=&marginType=ISOLATED", signInputCaptor.getValue());
        assertEquals(
                "7cedb25e13ff6f8ca5b22d48cb06eaaa3b2a8c7d1f13a1aeb891f6a8125f5399",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/marginType", actualRequest.url().encodedPath());
    }

    /**
     * Change Multi-Assets Mode (TRADE)
     *
     * <p>Change user&#39;s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on ***Every
     * symbol*** Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void changeMultiAssetsModeTest() throws ApiException, CryptoException {
        ChangeMultiAssetsModeRequest changeMultiAssetsModeRequest =
                new ChangeMultiAssetsModeRequest();

        changeMultiAssetsModeRequest.multiAssetsMargin("");

        ApiResponse<ChangeMultiAssetsModeResponse> response =
                api.changeMultiAssetsMode(changeMultiAssetsModeRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000multiAssetsMargin=", signInputCaptor.getValue());
        assertEquals(
                "2bbddd5005c80c60a12618873cdf82e9e364838ddd3cfc74dd620b1bab630db2",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/multiAssetsMargin", actualRequest.url().encodedPath());
    }

    /**
     * Change Position Mode(TRADE)
     *
     * <p>Change user&#39;s position mode (Hedge Mode or One-way Mode ) on ***EVERY symbol***
     * Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void changePositionModeTest() throws ApiException, CryptoException {
        ChangePositionModeRequest changePositionModeRequest = new ChangePositionModeRequest();

        changePositionModeRequest.dualSidePosition("");

        ApiResponse<ChangePositionModeResponse> response =
                api.changePositionMode(changePositionModeRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000dualSidePosition=", signInputCaptor.getValue());
        assertEquals(
                "234d62c8a0356474ae6889f6aee70005b8ded595c0d02364bc91a55e250c6017",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/positionSide/dual", actualRequest.url().encodedPath());
    }

    /**
     * Current All Open Orders (USER_DATA)
     *
     * <p>Get all open orders on a symbol. * If the symbol is not sent, orders for all symbols will
     * be returned in an array. Weight: 1 for a single symbol; 40 when the symbol parameter is
     * omitted Careful when accessing this with no symbol.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void currentAllOpenOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<CurrentAllOpenOrdersResponse> response =
                api.currentAllOpenOrders(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/openOrders", actualRequest.url().encodedPath());
    }

    /**
     * Get Order Modify History (USER_DATA)
     *
     * <p>Get order modification history * Either &#x60;orderId&#x60; or
     * &#x60;origClientOrderId&#x60; must be sent, and the &#x60;orderId&#x60; will prevail if both
     * are sent. * Order modify history longer than 3 month is not avaliable Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getOrderModifyHistoryTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        String origClientOrderId = "1";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<GetOrderModifyHistoryResponse> response =
                api.getOrderModifyHistory(
                        symbol, orderId, origClientOrderId, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&orderId=1&origClientOrderId=1&startTime=1623319461670&endTime=1641782889000&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "8dfcc843fc05f631a3b12c4a0080f9d1f2283472ee0032b3e7e7fd46d855bcde",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/orderAmendment", actualRequest.url().encodedPath());
    }

    /**
     * Get Position Margin Change History (TRADE)
     *
     * <p>Get Position Margin Change History * Support querying future histories that are not older
     * than 30 days * The time between &#x60;startTime&#x60; and &#x60;endTime&#x60;can&#39;t be
     * more than 30 days Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getPositionMarginChangeHistoryTest() throws ApiException, CryptoException {
        String symbol = "";
        String type = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<GetPositionMarginChangeHistoryResponse> response =
                api.getPositionMarginChangeHistory(
                        symbol, type, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&type=&startTime=1623319461670&endTime=1641782889000&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "9993f640a7ff2dec80d1ea367a29578129bbfd1b7dea64f0710fecff16fb887e",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/positionMargin/history", actualRequest.url().encodedPath());
    }

    /**
     * Modify Isolated Position Margin(TRADE)
     *
     * <p>Modify Isolated Position Margin * Only for isolated symbol Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void modifyIsolatedPositionMarginTest() throws ApiException, CryptoException {
        ModifyIsolatedPositionMarginRequest modifyIsolatedPositionMarginRequest =
                new ModifyIsolatedPositionMarginRequest();

        modifyIsolatedPositionMarginRequest.symbol("");
        modifyIsolatedPositionMarginRequest.amount(1d);
        modifyIsolatedPositionMarginRequest.type("");

        ApiResponse<ModifyIsolatedPositionMarginResponse> response =
                api.modifyIsolatedPositionMargin(modifyIsolatedPositionMarginRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000symbol=&amount=1&type=", signInputCaptor.getValue());
        assertEquals(
                "921166da829e0f721b541df55b30dc589552e9b564377ec51db466f94d2e2f8b",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/positionMargin", actualRequest.url().encodedPath());
    }

    /**
     * Modify Multiple Orders(TRADE)
     *
     * <p>Modify Multiple Orders (TRADE) * Parameter rules are same with &#x60;Modify Order&#x60; *
     * Batch modify orders are processed concurrently, and the order of matching is not guaranteed.
     * * The order of returned contents for batch modify orders is the same as the order of the
     * order list. * One order can only be modfied for less than 10000 times Weight: 5 on 10s order
     * rate limit(X-MBX-ORDER-COUNT-10S); 1 on 1min order rate limit(X-MBX-ORDER-COUNT-1M); 5 on IP
     * rate limit(x-mbx-used-weight-1m);
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void modifyMultipleOrdersTest() throws ApiException, CryptoException {
        ModifyMultipleOrdersRequest modifyMultipleOrdersRequest = new ModifyMultipleOrdersRequest();

        modifyMultipleOrdersRequest.batchOrders(new BatchOrders());

        ApiResponse<ModifyMultipleOrdersResponse> response =
                api.modifyMultipleOrders(modifyMultipleOrdersRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000batchOrders=%5B%5D", signInputCaptor.getValue());
        assertEquals(
                "84453de090bb6a9299c2928d3b767e0cd7298a2b7e7a004b22943b9d5990663b",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/batchOrders", actualRequest.url().encodedPath());
    }

    /**
     * Modify Order (TRADE)
     *
     * <p>Order modify function, currently only LIMIT order modification is supported, modified
     * orders will be reordered in the match queue * Either &#x60;orderId&#x60; or
     * &#x60;origClientOrderId&#x60; must be sent, and the &#x60;orderId&#x60; will prevail if both
     * are sent. * Both &#x60;quantity&#x60; and &#x60;price&#x60; must be sent, which is different
     * from dapi modify order endpoint. * When the new &#x60;quantity&#x60; or &#x60;price&#x60;
     * doesn&#39;t satisfy PRICE_FILTER / PERCENT_FILTER / LOT_SIZE, amendment will be rejected and
     * the order will stay as it is. * However the order will be cancelled by the amendment in the
     * following situations: * when the order is in partially filled status and the new
     * &#x60;quantity&#x60; &lt;&#x3D; &#x60;executedQty&#x60; * When the order is &#x60;GTX&#x60;
     * and the new price will cause it to be executed immediately * One order can only be modfied
     * for less than 10000 times * Modify order will set &#x60;selfTradePreventionMode&#x60; to
     * &#x60;NONE&#x60; Weight: 1 on 10s order rate limit(X-MBX-ORDER-COUNT-10S); 1 on 1min order
     * rate limit(X-MBX-ORDER-COUNT-1M); 1 on IP rate limit(x-mbx-used-weight-1m)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void modifyOrderTest() throws ApiException, CryptoException {
        ModifyOrderRequest modifyOrderRequest = new ModifyOrderRequest();

        modifyOrderRequest.symbol("");
        modifyOrderRequest.side(Side.BUY);
        modifyOrderRequest.quantity(1d);
        modifyOrderRequest.price(1d);

        ApiResponse<ModifyOrderResponse> response = api.modifyOrder(modifyOrderRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=&side=BUY&quantity=1&price=1",
                signInputCaptor.getValue());
        assertEquals(
                "5d55a15240b44cfacea70546cc8dc2e0e1394ec0f194ec1bf1e67bfac92cd911",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/order", actualRequest.url().encodedPath());
    }

    /**
     * New Order(TRADE)
     *
     * <p>Send in a new order. * Order with type &#x60;STOP&#x60;, parameter &#x60;timeInForce&#x60;
     * can be sent ( default &#x60;GTC&#x60;). * Order with type &#x60;TAKE_PROFIT&#x60;, parameter
     * &#x60;timeInForce&#x60; can be sent ( default &#x60;GTC&#x60;). * Condition orders will be
     * triggered when: * If parameter&#x60;priceProtect&#x60;is sent as true: * when price reaches
     * the &#x60;stopPrice&#x60; ，the difference rate between \&quot;MARK_PRICE\&quot; and
     * \&quot;CONTRACT_PRICE\&quot; cannot be larger than the \&quot;triggerProtect\&quot; of the
     * symbol * \&quot;triggerProtect\&quot; of a symbol can be got from &#x60;GET
     * /fapi/v1/exchangeInfo&#x60; * &#x60;STOP&#x60;, &#x60;STOP_MARKET&#x60;: * BUY: latest price
     * (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &gt;&#x3D; &#x60;stopPrice&#x60; *
     * SELL: latest price (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &lt;&#x3D;
     * &#x60;stopPrice&#x60; * &#x60;TAKE_PROFIT&#x60;, &#x60;TAKE_PROFIT_MARKET&#x60;: * BUY:
     * latest price (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &lt;&#x3D;
     * &#x60;stopPrice&#x60; * SELL: latest price (\&quot;MARK_PRICE\&quot; or
     * \&quot;CONTRACT_PRICE\&quot;) &gt;&#x3D; &#x60;stopPrice&#x60; *
     * &#x60;TRAILING_STOP_MARKET&#x60;: * BUY: the lowest price after order placed &#x60;&lt;&#x3D;
     * &#x60;activationPrice&#x60;, and the latest price &gt;&#x60;&#x3D; the lowest price * (1 +
     * &#x60;callbackRate&#x60;) * SELL: the highest price after order placed &gt;&#x3D;
     * &#x60;activationPrice&#x60;, and the latest price &lt;&#x3D; the highest price * (1 -
     * &#x60;callbackRate&#x60;) * For &#x60;TRAILING_STOP_MARKET&#x60;, if you got such error code.
     * &#x60;&#x60;{\&quot;code\&quot;: -2021, \&quot;msg\&quot;: \&quot;Order would immediately
     * trigger.\&quot;}&#x60;&#x60; means that the parameters you send do not meet the following
     * requirements: * BUY: &#x60;activationPrice&#x60; should be smaller than latest price. * SELL:
     * &#x60;activationPrice&#x60; should be larger than latest price. * If &#x60;newOrderRespType
     * &#x60; is sent as &#x60;RESULT&#x60; : * &#x60;MARKET&#x60; order: the final FILLED result of
     * the order will be return directly. * &#x60;LIMIT&#x60; order with special
     * &#x60;timeInForce&#x60;: the final status result of the order(FILLED or EXPIRED) will be
     * returned directly. * &#x60;STOP_MARKET&#x60;, &#x60;TAKE_PROFIT_MARKET&#x60; with
     * &#x60;closePosition&#x60;&#x3D;&#x60;true&#x60;: * Follow the same rules for condition
     * orders. * If triggered，**close all** current long position( if &#x60;SELL&#x60;) or current
     * short position( if &#x60;BUY&#x60;). * Cannot be used with &#x60;quantity&#x60; paremeter *
     * Cannot be used with &#x60;reduceOnly&#x60; parameter * In Hedge Mode,cannot be used with
     * &#x60;BUY&#x60; orders in &#x60;LONG&#x60; position side. and cannot be used with
     * &#x60;SELL&#x60; orders in &#x60;SHORT&#x60; position side *
     * &#x60;selfTradePreventionMode&#x60; is only effective when &#x60;timeInForce&#x60; set to
     * &#x60;IOC&#x60; or &#x60;GTC&#x60; or &#x60;GTD&#x60;. * In extreme market conditions,
     * timeInForce &#x60;GTD&#x60; order auto cancel time might be delayed comparing to
     * &#x60;goodTillDate&#x60; Weight: 1 on 10s order rate limit(X-MBX-ORDER-COUNT-10S); 1 on 1min
     * order rate limit(X-MBX-ORDER-COUNT-1M); 0 on IP rate limit(x-mbx-used-weight-1m)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void newOrderTest() throws ApiException, CryptoException {
        NewOrderRequest newOrderRequest = new NewOrderRequest();

        newOrderRequest.symbol("");
        newOrderRequest.side(Side.BUY);
        newOrderRequest.type("");

        ApiResponse<NewOrderResponse> response = api.newOrder(newOrderRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000symbol=&side=BUY&type=", signInputCaptor.getValue());
        assertEquals(
                "fa7ddab4a660903f7305421c43e7705a88aa40d3039a17e6bf6ad242ec379289",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/order", actualRequest.url().encodedPath());
    }

    /**
     * Place Multiple Orders(TRADE)
     *
     * <p>Place Multiple Orders * Paremeter rules are same with &#x60;New Order&#x60; * Batch orders
     * are processed concurrently, and the order of matching is not guaranteed. * The order of
     * returned contents for batch orders is the same as the order of the order list. Weight: 5 on
     * 10s order rate limit(X-MBX-ORDER-COUNT-10S); 1 on 1min order rate
     * limit(X-MBX-ORDER-COUNT-1M); 5 on IP rate limit(x-mbx-used-weight-1m);
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void placeMultipleOrdersTest() throws ApiException, CryptoException {
        PlaceMultipleOrdersRequest placeMultipleOrdersRequest = new PlaceMultipleOrdersRequest();

        placeMultipleOrdersRequest.batchOrders(new BatchOrdersPlaceMultipleOrders());

        ApiResponse<PlaceMultipleOrdersResponse> response =
                api.placeMultipleOrders(placeMultipleOrdersRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000batchOrders=%5B%5D", signInputCaptor.getValue());
        assertEquals(
                "84453de090bb6a9299c2928d3b767e0cd7298a2b7e7a004b22943b9d5990663b",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/batchOrders", actualRequest.url().encodedPath());
    }

    /**
     * Position ADL Quantile Estimation(USER_DATA)
     *
     * <p>Position ADL Quantile Estimation * Values update every 30s. * Values 0, 1, 2, 3, 4 shows
     * the queue position and possibility of ADL from low to high. * For positions of the symbol are
     * in One-way Mode or isolated margined in Hedge Mode, \&quot;LONG\&quot;, \&quot;SHORT\&quot;,
     * and \&quot;BOTH\&quot; will be returned to show the positions&#39; adl quantiles of different
     * position sides. * If the positions of the symbol are crossed margined in Hedge Mode: *
     * \&quot;HEDGE\&quot; as a sign will be returned instead of \&quot;BOTH\&quot;; * A same value
     * caculated on unrealized pnls on long and short sides&#39; positions will be shown for
     * \&quot;LONG\&quot; and \&quot;SHORT\&quot; when there are positions in both of long and short
     * sides. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void positionAdlQuantileEstimationTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<PositionAdlQuantileEstimationResponse> response =
                api.positionAdlQuantileEstimation(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/adlQuantile", actualRequest.url().encodedPath());
    }

    /**
     * Position Information V2 (USER_DATA)
     *
     * <p>Get current position information. Please use with user data stream
     * &#x60;ACCOUNT_UPDATE&#x60; to meet your timeliness and accuracy needs. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void positionInformationV2Test() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<PositionInformationV2Response> response =
                api.positionInformationV2(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v2/positionRisk", actualRequest.url().encodedPath());
    }

    /**
     * Position Information V3 (USER_DATA)
     *
     * <p>Get current position information(only symbol that has position or open orders will be
     * returned). Please use with user data stream &#x60;ACCOUNT_UPDATE&#x60; to meet your
     * timeliness and accuracy needs. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void positionInformationV3Test() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<PositionInformationV3Response> response =
                api.positionInformationV3(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v3/positionRisk", actualRequest.url().encodedPath());
    }

    /**
     * Query Current Open Order (USER_DATA)
     *
     * <p>Query open order * Either&#x60;orderId&#x60; or &#x60;origClientOrderId&#x60; must be sent
     * * If the queried order has been filled or cancelled, the error message \&quot;Order does not
     * exist\&quot; will be returned. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryCurrentOpenOrderTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        String origClientOrderId = "1";
        Long recvWindow = 5000L;
        ApiResponse<QueryCurrentOpenOrderResponse> response =
                api.queryCurrentOpenOrder(symbol, orderId, origClientOrderId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&orderId=1&origClientOrderId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "cbec82483be2ad044b893ffb2e6bc0d55370e378eaea0b4b61d95893bd9cc458",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/openOrder", actualRequest.url().encodedPath());
    }

    /**
     * Query Order (USER_DATA)
     *
     * <p>Check an order&#39;s status. * These orders will not be found: * order status is
     * &#x60;CANCELED&#x60; or &#x60;EXPIRED&#x60; **AND** order has NO filled trade **AND** created
     * time + 3 days &lt; current time * order create time + 90 days &lt; current time * Either
     * &#x60;orderId&#x60; or &#x60;origClientOrderId&#x60; must be sent. * &#x60;orderId&#x60; is
     * self-increment for each specific &#x60;symbol&#x60; Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryOrderTest() throws ApiException, CryptoException {
        String symbol = "";
        Long orderId = 1L;
        String origClientOrderId = "1";
        Long recvWindow = 5000L;
        ApiResponse<QueryOrderResponse> response =
                api.queryOrder(symbol, orderId, origClientOrderId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&orderId=1&origClientOrderId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "cbec82483be2ad044b893ffb2e6bc0d55370e378eaea0b4b61d95893bd9cc458",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/order", actualRequest.url().encodedPath());
    }

    /**
     * Test Order(TRADE)
     *
     * <p>Testing order request, this order will not be submitted to matching engine * Order with
     * type &#x60;STOP&#x60;, parameter &#x60;timeInForce&#x60; can be sent ( default
     * &#x60;GTC&#x60;). * Order with type &#x60;TAKE_PROFIT&#x60;, parameter
     * &#x60;timeInForce&#x60; can be sent ( default &#x60;GTC&#x60;). * Condition orders will be
     * triggered when: * If parameter&#x60;priceProtect&#x60;is sent as true: * when price reaches
     * the &#x60;stopPrice&#x60; ，the difference rate between \&quot;MARK_PRICE\&quot; and
     * \&quot;CONTRACT_PRICE\&quot; cannot be larger than the \&quot;triggerProtect\&quot; of the
     * symbol * \&quot;triggerProtect\&quot; of a symbol can be got from &#x60;GET
     * /fapi/v1/exchangeInfo&#x60; * &#x60;STOP&#x60;, &#x60;STOP_MARKET&#x60;: * BUY: latest price
     * (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &gt;&#x3D; &#x60;stopPrice&#x60; *
     * SELL: latest price (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &lt;&#x3D;
     * &#x60;stopPrice&#x60; * &#x60;TAKE_PROFIT&#x60;, &#x60;TAKE_PROFIT_MARKET&#x60;: * BUY:
     * latest price (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &lt;&#x3D;
     * &#x60;stopPrice&#x60; * SELL: latest price (\&quot;MARK_PRICE\&quot; or
     * \&quot;CONTRACT_PRICE\&quot;) &gt;&#x3D; &#x60;stopPrice&#x60; *
     * &#x60;TRAILING_STOP_MARKET&#x60;: * BUY: the lowest price after order placed &#x60;&lt;&#x3D;
     * &#x60;activationPrice&#x60;, and the latest price &gt;&#x60;&#x3D; the lowest price * (1 +
     * &#x60;callbackRate&#x60;) * SELL: the highest price after order placed &gt;&#x3D;
     * &#x60;activationPrice&#x60;, and the latest price &lt;&#x3D; the highest price * (1 -
     * &#x60;callbackRate&#x60;) * For &#x60;TRAILING_STOP_MARKET&#x60;, if you got such error code.
     * &#x60;&#x60;{\&quot;code\&quot;: -2021, \&quot;msg\&quot;: \&quot;Order would immediately
     * trigger.\&quot;}&#x60;&#x60; means that the parameters you send do not meet the following
     * requirements: * BUY: &#x60;activationPrice&#x60; should be smaller than latest price. * SELL:
     * &#x60;activationPrice&#x60; should be larger than latest price. * If &#x60;newOrderRespType
     * &#x60; is sent as &#x60;RESULT&#x60; : * &#x60;MARKET&#x60; order: the final FILLED result of
     * the order will be return directly. * &#x60;LIMIT&#x60; order with special
     * &#x60;timeInForce&#x60;: the final status result of the order(FILLED or EXPIRED) will be
     * returned directly. * &#x60;STOP_MARKET&#x60;, &#x60;TAKE_PROFIT_MARKET&#x60; with
     * &#x60;closePosition&#x60;&#x3D;&#x60;true&#x60;: * Follow the same rules for condition
     * orders. * If triggered，**close all** current long position( if &#x60;SELL&#x60;) or current
     * short position( if &#x60;BUY&#x60;). * Cannot be used with &#x60;quantity&#x60; paremeter *
     * Cannot be used with &#x60;reduceOnly&#x60; parameter * In Hedge Mode,cannot be used with
     * &#x60;BUY&#x60; orders in &#x60;LONG&#x60; position side. and cannot be used with
     * &#x60;SELL&#x60; orders in &#x60;SHORT&#x60; position side *
     * &#x60;selfTradePreventionMode&#x60; is only effective when &#x60;timeInForce&#x60; set to
     * &#x60;IOC&#x60; or &#x60;GTC&#x60; or &#x60;GTD&#x60;. * In extreme market conditions,
     * timeInForce &#x60;GTD&#x60; order auto cancel time might be delayed comparing to
     * &#x60;goodTillDate&#x60; Weight: 0
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void testOrderTest() throws ApiException, CryptoException {
        TestOrderRequest testOrderRequest = new TestOrderRequest();

        testOrderRequest.symbol("");
        testOrderRequest.side(Side.BUY);
        testOrderRequest.type("");

        ApiResponse<TestOrderResponse> response = api.testOrder(testOrderRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000symbol=&side=BUY&type=", signInputCaptor.getValue());
        assertEquals(
                "fa7ddab4a660903f7305421c43e7705a88aa40d3039a17e6bf6ad242ec379289",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/order/test", actualRequest.url().encodedPath());
    }

    /**
     * User&#39;s Force Orders (USER_DATA)
     *
     * <p>Query user&#39;s Force Orders * If \&quot;autoCloseType\&quot; is not sent, orders with
     * both of the types will be returned * If \&quot;startTime\&quot; is not sent, data within 7
     * days before \&quot;endTime\&quot; can be queried Weight: 20 with symbol, 50 without symbol
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void usersForceOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        AutoCloseType autoCloseType = AutoCloseType.LIQUIDATION;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<UsersForceOrdersResponse> response =
                api.usersForceOrders(symbol, autoCloseType, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&autoCloseType=LIQUIDATION&startTime=1623319461670&endTime=1641782889000&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "a8fbc61c925506a4d0328c80dbe4bd786245accbfc50aef2a14a769d18bde9d9",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/forceOrders", actualRequest.url().encodedPath());
    }
}
