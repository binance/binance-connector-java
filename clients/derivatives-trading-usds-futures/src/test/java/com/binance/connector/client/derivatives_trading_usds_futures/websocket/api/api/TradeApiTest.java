/*
 * Binance Derivatives Trading USDS Futures WebSocket API
 * OpenAPI Specification for the Binance Derivatives Trading USDS Futures WebSocket API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.api;

import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.websocket.adapter.ConnectionWrapper;
import com.binance.connector.client.common.websocket.configuration.SessionMode;
import com.binance.connector.client.common.websocket.configuration.WebSocketClientConfiguration;
import com.binance.connector.client.common.websocket.dtos.RequestWrapperDTO;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.CancelOrderRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.CancelOrderResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.ModifyOrderRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.ModifyOrderResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.NewOrderRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.NewOrderResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.PositionInformationRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.PositionInformationResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.PositionInformationV2Request;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.PositionInformationV2Response;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.QueryOrderRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.QueryOrderResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.Side;
import java.io.File;
import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.concurrent.CompletableFuture;

import org.eclipse.jetty.websocket.api.RemoteEndpoint;
import org.eclipse.jetty.websocket.api.Session;
import org.eclipse.jetty.websocket.client.WebSocketClient;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;
import org.skyscreamer.jsonassert.JSONAssert;

/** API tests for TradeApi */
public class TradeApiTest {

    private TradeApi api;
    private ConnectionWrapper connectionSpy;
    private Session sessionMock;

    @BeforeEach
    public void initApiClient() throws Exception {
        URL resource = TradeApi.class.getResource("/test-ed25519-prv-key.pem");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        File file = new File(resource.toURI());
        signatureConfiguration.setPrivateKey(file.getAbsolutePath());
        WebSocketClientConfiguration clientConfiguration = new WebSocketClientConfiguration();
        // @TODO: run tests for LOGON as well
        clientConfiguration.setAutoLogon(false);
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);
        clientConfiguration.setUrl("wss://localhost:8080");

        WebSocketClient webSocketClient = Mockito.mock(WebSocketClient.class);
        CompletableFuture<Session> sessionCompletableFuture = new CompletableFuture<>();
        Mockito.doReturn(sessionCompletableFuture)
                .when(webSocketClient)
                .connect(Mockito.any(), Mockito.any(), Mockito.any());
        sessionMock = Mockito.mock(Session.class);

        RemoteEndpoint remoteEndpointMock = Mockito.mock(RemoteEndpoint.class);
        Mockito.doReturn(remoteEndpointMock).when(sessionMock).getRemote();

        sessionCompletableFuture.complete(sessionMock);
        ConnectionWrapper connectionWrapper =
                new ConnectionWrapper(clientConfiguration, webSocketClient);
        connectionSpy = Mockito.spy(connectionWrapper);
        Mockito.doReturn(1736393892000L).when(connectionSpy).getTimestamp();
        connectionSpy.connect();
        TradeApi accountApi = new TradeApi(connectionSpy);
        api = Mockito.spy(accountApi);
        Mockito.doReturn("eaf3292c-64b6-4c04-ad4f-4ca2608b42b4").when(api).getRequestID();
    }

    /**
     * Cancel Order (TRADE)
     *
     * <p>Cancel an active order. * Either &#x60;orderId&#x60; or &#x60;origClientOrderId&#x60; must
     * be sent. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void cancelOrderTest() throws ApiException, URISyntaxException, IOException {
        CancelOrderRequest cancelOrderRequest = new CancelOrderRequest();

        cancelOrderRequest.symbol("");

        CompletableFuture<CancelOrderResponse> response = api.cancelOrder(cancelOrderRequest);
        ArgumentCaptor<RequestWrapperDTO<CancelOrderRequest, CancelOrderResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<CancelOrderRequest, CancelOrderResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        CancelOrderRequest params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                AccountApiTest.class.getResource("/expected/api/TradeApi/order.cancel-test.json");

        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Modify Order (TRADE)
     *
     * <p>Order modify function, currently only LIMIT order modification is supported, modified
     * orders will be reordered in the match queue * Either &#x60;orderId&#x60; or
     * &#x60;origClientOrderId&#x60; must be sent, and the &#x60;orderId&#x60; will prevail if both
     * are sent. * Both &#x60;quantity&#x60; and &#x60;price&#x60; must be sent, which is different
     * from dapi modify order endpoint. * When the new &#x60;quantity&#x60; or &#x60;price&#x60;
     * doesn&#39;t satisfy PRICE_FILTER / PERCENT_FILTER / LOT_SIZE, amendment will be rejected and
     * the order will stay as it is. * However the order will be cancelled by the amendment in the
     * following situations: * when the order is in partially filled status and the new
     * &#x60;quantity&#x60; &lt;&#x3D; &#x60;executedQty&#x60; * When the order is &#x60;GTX&#x60;
     * and the new price will cause it to be executed immediately * One order can only be modfied
     * for less than 10000 times Weight: 1 on 10s order rate limit(X-MBX-ORDER-COUNT-10S); 1 on 1min
     * order rate limit(X-MBX-ORDER-COUNT-1M); 1 on IP rate limit(x-mbx-used-weight-1m)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void modifyOrderTest() throws ApiException, URISyntaxException, IOException {
        ModifyOrderRequest modifyOrderRequest = new ModifyOrderRequest();

        modifyOrderRequest.symbol("");
        modifyOrderRequest.side(Side.BUY);
        modifyOrderRequest.quantity(1d);
        modifyOrderRequest.price(1d);

        CompletableFuture<ModifyOrderResponse> response = api.modifyOrder(modifyOrderRequest);
        ArgumentCaptor<RequestWrapperDTO<ModifyOrderRequest, ModifyOrderResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<ModifyOrderRequest, ModifyOrderResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        ModifyOrderRequest params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                AccountApiTest.class.getResource("/expected/api/TradeApi/order.modify-test.json");

        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * New Order(TRADE)
     *
     * <p>Send in a new order. * Order with type &#x60;STOP&#x60;, parameter &#x60;timeInForce&#x60;
     * can be sent ( default &#x60;GTC&#x60;). * Order with type &#x60;TAKE_PROFIT&#x60;, parameter
     * &#x60;timeInForce&#x60; can be sent ( default &#x60;GTC&#x60;). * Condition orders will be
     * triggered when: * If parameter&#x60;priceProtect&#x60;is sent as true: * when price reaches
     * the &#x60;stopPrice&#x60; ，the difference rate between \&quot;MARK_PRICE\&quot; and
     * \&quot;CONTRACT_PRICE\&quot; cannot be larger than the \&quot;triggerProtect\&quot; of the
     * symbol * \&quot;triggerProtect\&quot; of a symbol can be got from &#x60;GET
     * /fapi/v1/exchangeInfo&#x60; * &#x60;STOP&#x60;, &#x60;STOP_MARKET&#x60;: * BUY: latest price
     * (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &gt;&#x3D; &#x60;stopPrice&#x60; *
     * SELL: latest price (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &lt;&#x3D;
     * &#x60;stopPrice&#x60; * &#x60;TAKE_PROFIT&#x60;, &#x60;TAKE_PROFIT_MARKET&#x60;: * BUY:
     * latest price (\&quot;MARK_PRICE\&quot; or \&quot;CONTRACT_PRICE\&quot;) &lt;&#x3D;
     * &#x60;stopPrice&#x60; * SELL: latest price (\&quot;MARK_PRICE\&quot; or
     * \&quot;CONTRACT_PRICE\&quot;) &gt;&#x3D; &#x60;stopPrice&#x60; *
     * &#x60;TRAILING_STOP_MARKET&#x60;: * BUY: the lowest price after order placed &#x60;&lt;&#x3D;
     * &#x60;activationPrice&#x60;, and the latest price &gt;&#x60;&#x3D; the lowest price * (1 +
     * &#x60;callbackRate&#x60;) * SELL: the highest price after order placed &gt;&#x3D;
     * &#x60;activationPrice&#x60;, and the latest price &lt;&#x3D; the highest price * (1 -
     * &#x60;callbackRate&#x60;) * For &#x60;TRAILING_STOP_MARKET&#x60;, if you got such error code.
     * &#x60;&#x60;{\&quot;code\&quot;: -2021, \&quot;msg\&quot;: \&quot;Order would immediately
     * trigger.\&quot;}&#x60;&#x60; means that the parameters you send do not meet the following
     * requirements: * BUY: &#x60;activationPrice&#x60; should be smaller than latest price. * SELL:
     * &#x60;activationPrice&#x60; should be larger than latest price. * If &#x60;newOrderRespType
     * &#x60; is sent as &#x60;RESULT&#x60; : * &#x60;MARKET&#x60; order: the final FILLED result of
     * the order will be return directly. * &#x60;LIMIT&#x60; order with special
     * &#x60;timeInForce&#x60;: the final status result of the order(FILLED or EXPIRED) will be
     * returned directly. * &#x60;STOP_MARKET&#x60;, &#x60;TAKE_PROFIT_MARKET&#x60; with
     * &#x60;closePosition&#x60;&#x3D;&#x60;true&#x60;: * Follow the same rules for condition
     * orders. * If triggered，**close all** current long position( if &#x60;SELL&#x60;) or current
     * short position( if &#x60;BUY&#x60;). * Cannot be used with &#x60;quantity&#x60; paremeter *
     * Cannot be used with &#x60;reduceOnly&#x60; parameter * In Hedge Mode,cannot be used with
     * &#x60;BUY&#x60; orders in &#x60;LONG&#x60; position side. and cannot be used with
     * &#x60;SELL&#x60; orders in &#x60;SHORT&#x60; position side Weight: 0
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void newOrderTest() throws ApiException, URISyntaxException, IOException {
        NewOrderRequest newOrderRequest = new NewOrderRequest();

        newOrderRequest.symbol("");
        newOrderRequest.side(Side.BUY);
        newOrderRequest.type("");

        CompletableFuture<NewOrderResponse> response = api.newOrder(newOrderRequest);
        ArgumentCaptor<RequestWrapperDTO<NewOrderRequest, NewOrderResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<NewOrderRequest, NewOrderResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        NewOrderRequest params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                AccountApiTest.class.getResource("/expected/api/TradeApi/order.place-test.json");

        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Position Information (USER_DATA)
     *
     * <p>Get current position information. * Please use with user data stream
     * &#x60;ACCOUNT_UPDATE&#x60; to meet your timeliness and accuracy needs. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void positionInformationTest() throws ApiException, URISyntaxException, IOException {
        PositionInformationRequest positionInformationRequest = new PositionInformationRequest();

        CompletableFuture<PositionInformationResponse> response =
                api.positionInformation(positionInformationRequest);
        ArgumentCaptor<RequestWrapperDTO<PositionInformationRequest, PositionInformationResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<PositionInformationRequest, PositionInformationResponse>
                requestWrapperDTO = callArgumentCaptor.getValue();
        PositionInformationRequest params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                AccountApiTest.class.getResource(
                        "/expected/api/TradeApi/account.position-test.json");

        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Position Information V2 (USER_DATA)
     *
     * <p>Get current position information(only symbol that has position or open orders will be
     * returned). * Please use with user data stream &#x60;ACCOUNT_UPDATE&#x60; to meet your
     * timeliness and accuracy needs. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void positionInformationV2Test() throws ApiException, URISyntaxException, IOException {
        PositionInformationV2Request positionInformationV2Request =
                new PositionInformationV2Request();

        CompletableFuture<PositionInformationV2Response> response =
                api.positionInformationV2(positionInformationV2Request);
        ArgumentCaptor<
                        RequestWrapperDTO<
                                PositionInformationV2Request, PositionInformationV2Response>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<PositionInformationV2Request, PositionInformationV2Response>
                requestWrapperDTO = callArgumentCaptor.getValue();
        PositionInformationV2Request params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                AccountApiTest.class.getResource(
                        "/expected/api/TradeApi/v2/account.position-test.json");

        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Query Order (USER_DATA)
     *
     * <p>Check an order&#39;s status. * These orders will not be found: * order status is
     * &#x60;CANCELED&#x60; or &#x60;EXPIRED&#x60; **AND** order has NO filled trade **AND** created
     * time + 3 days &lt; current time * order create time + 90 days &lt; current time * Either
     * &#x60;orderId&#x60; or &#x60;origClientOrderId&#x60; must be sent. * &#x60;orderId&#x60; is
     * self-increment for each specific &#x60;symbol&#x60; Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryOrderTest() throws ApiException, URISyntaxException, IOException {
        QueryOrderRequest queryOrderRequest = new QueryOrderRequest();

        queryOrderRequest.symbol("");

        CompletableFuture<QueryOrderResponse> response = api.queryOrder(queryOrderRequest);
        ArgumentCaptor<RequestWrapperDTO<QueryOrderRequest, QueryOrderResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<QueryOrderRequest, QueryOrderResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        QueryOrderRequest params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                AccountApiTest.class.getResource("/expected/api/TradeApi/order.status-test.json");

        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }
}
