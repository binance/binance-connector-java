/*
 * Binance Derivatives Trading USDS Futures WebSocket API
 * OpenAPI Specification for the Binance Derivatives Trading USDS Futures WebSocket API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.api;

import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.websocket.adapter.ConnectionWrapper;
import com.binance.connector.client.common.websocket.configuration.SessionMode;
import com.binance.connector.client.common.websocket.configuration.WebSocketClientConfiguration;
import com.binance.connector.client.common.websocket.dtos.RequestWrapperDTO;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.OrderBookRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.OrderBookResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.SymbolOrderBookTickerRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.SymbolOrderBookTickerResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.SymbolPriceTickerRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.websocket.api.model.SymbolPriceTickerResponse;
import java.io.File;
import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.concurrent.CompletableFuture;

import org.eclipse.jetty.websocket.api.RemoteEndpoint;
import org.eclipse.jetty.websocket.api.Session;
import org.eclipse.jetty.websocket.client.WebSocketClient;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;
import org.skyscreamer.jsonassert.JSONAssert;

/** API tests for MarketDataApi */
public class MarketDataApiTest {

    private MarketDataApi api;
    private ConnectionWrapper connectionSpy;
    private Session sessionMock;

    @BeforeEach
    public void initApiClient() throws Exception {
        URL resource = MarketDataApi.class.getResource("/test-ed25519-prv-key.pem");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        File file = new File(resource.toURI());
        signatureConfiguration.setPrivateKey(file.getAbsolutePath());
        WebSocketClientConfiguration clientConfiguration = new WebSocketClientConfiguration();
        // @TODO: run tests for LOGON as well
        clientConfiguration.setAutoLogon(false);
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);
        clientConfiguration.setUrl("wss://localhost:8080");

        WebSocketClient webSocketClient = Mockito.mock(WebSocketClient.class);
        CompletableFuture<Session> sessionCompletableFuture = new CompletableFuture<>();
        Mockito.doReturn(sessionCompletableFuture)
                .when(webSocketClient)
                .connect(Mockito.any(), Mockito.any(), Mockito.any());
        sessionMock = Mockito.mock(Session.class);

        RemoteEndpoint remoteEndpointMock = Mockito.mock(RemoteEndpoint.class);
        Mockito.doReturn(remoteEndpointMock).when(sessionMock).getRemote();

        sessionCompletableFuture.complete(sessionMock);
        ConnectionWrapper connectionWrapper =
                new ConnectionWrapper(clientConfiguration, webSocketClient);
        connectionSpy = Mockito.spy(connectionWrapper);
        Mockito.doReturn(1736393892000L).when(connectionSpy).getTimestamp();
        connectionSpy.connect();
        MarketDataApi accountApi = new MarketDataApi(connectionSpy);
        api = Mockito.spy(accountApi);
        Mockito.doReturn("eaf3292c-64b6-4c04-ad4f-4ca2608b42b4").when(api).getRequestID();
    }

    /**
     * Order Book
     *
     * <p>Get current order book. Note that this request returns limited market depth. If you need
     * to continuously monitor order book updates, please consider using Websocket Market Streams: *
     * &#x60;&lt;symbol&gt;@depth&lt;levels&gt;&#x60; * &#x60;&lt;symbol&gt;@depth&#x60; You can use
     * &#x60;depth&#x60; request together with &#x60;&lt;symbol&gt;@depth&#x60; streams to maintain
     * a local order book. Weight: Adjusted based on the limit: | Limit | Weight | | ------------- |
     * ------ | | 5, 10, 20, 50 | 2 | | 100 | 5 | | 500 | 10 | | 1000 | 20 |
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void orderBookTest() throws ApiException, URISyntaxException, IOException {
        OrderBookRequest orderBookRequest = new OrderBookRequest();

        orderBookRequest.symbol("");

        CompletableFuture<OrderBookResponse> response = api.orderBook(orderBookRequest);
        ArgumentCaptor<RequestWrapperDTO<OrderBookRequest, OrderBookResponse>> callArgumentCaptor =
                ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<OrderBookRequest, OrderBookResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        OrderBookRequest params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                AccountApiTest.class.getResource("/expected/api/MarketDataApi/depth-test.json");

        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Symbol Order Book Ticker
     *
     * <p>Best price/qty on the order book for a symbol or symbols. * If the symbol is not sent,
     * bookTickers for all symbols will be returned in an array. * The field
     * &#x60;X-MBX-USED-WEIGHT-1M&#x60; in response header is not accurate from this endpoint,
     * please ignore. Weight: 2 for a single symbol; 5 when the symbol parameter is omitted
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void symbolOrderBookTickerTest() throws ApiException, URISyntaxException, IOException {
        SymbolOrderBookTickerRequest symbolOrderBookTickerRequest =
                new SymbolOrderBookTickerRequest();

        CompletableFuture<SymbolOrderBookTickerResponse> response =
                api.symbolOrderBookTicker(symbolOrderBookTickerRequest);
        ArgumentCaptor<
                        RequestWrapperDTO<
                                SymbolOrderBookTickerRequest, SymbolOrderBookTickerResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<SymbolOrderBookTickerRequest, SymbolOrderBookTickerResponse>
                requestWrapperDTO = callArgumentCaptor.getValue();
        SymbolOrderBookTickerRequest params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                AccountApiTest.class.getResource(
                        "/expected/api/MarketDataApi/ticker.book-test.json");

        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }

    /**
     * Symbol Price Ticker
     *
     * <p>Latest price for a symbol or symbols. * If the symbol is not sent, prices for all symbols
     * will be returned in an array. Weight: 1 for a single symbol; 2 when the symbol parameter is
     * omitted
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void symbolPriceTickerTest() throws ApiException, URISyntaxException, IOException {
        SymbolPriceTickerRequest symbolPriceTickerRequest = new SymbolPriceTickerRequest();

        CompletableFuture<SymbolPriceTickerResponse> response =
                api.symbolPriceTicker(symbolPriceTickerRequest);
        ArgumentCaptor<RequestWrapperDTO<SymbolPriceTickerRequest, SymbolPriceTickerResponse>>
                callArgumentCaptor = ArgumentCaptor.forClass(RequestWrapperDTO.class);
        Mockito.verify(connectionSpy).innerSend(callArgumentCaptor.capture());
        ArgumentCaptor<String> sendArgumentCaptor = ArgumentCaptor.forClass(String.class);
        RemoteEndpoint remote = sessionMock.getRemote();
        Mockito.verify(remote).sendString(sendArgumentCaptor.capture(), Mockito.any());
        RequestWrapperDTO<SymbolPriceTickerRequest, SymbolPriceTickerResponse> requestWrapperDTO =
                callArgumentCaptor.getValue();
        SymbolPriceTickerRequest params = requestWrapperDTO.getParams();
        // TODO: test validations
        String sentPayload = sendArgumentCaptor.getValue();

        URL resource =
                AccountApiTest.class.getResource(
                        "/expected/api/MarketDataApi/ticker.price-test.json");

        String expectedJson = Files.readString(Paths.get(resource.toURI()));
        JSONAssert.assertEquals(expectedJson, sentPayload, true);
    }
}
