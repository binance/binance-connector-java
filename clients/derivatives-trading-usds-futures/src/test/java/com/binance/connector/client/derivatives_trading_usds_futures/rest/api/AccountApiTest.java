/*
 * Binance Derivatives Trading USDS Futures REST API
 * OpenAPI Specification for the Binance Derivatives Trading USDS Futures REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.derivatives_trading_usds_futures.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.AccountInformationV2Response;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.AccountInformationV3Response;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.FuturesAccountBalanceV2Response;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.FuturesAccountBalanceV3Response;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.FuturesAccountConfigurationResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.FuturesTradingQuantitativeRulesIndicatorsResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.GetBnbBurnStatusResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.GetCurrentMultiAssetsModeResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.GetCurrentPositionModeResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.GetDownloadIdForFuturesOrderHistoryResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.GetDownloadIdForFuturesTradeHistoryResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.GetDownloadIdForFuturesTransactionHistoryResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.GetFuturesOrderHistoryDownloadLinkByIdResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.GetFuturesTradeDownloadLinkByIdResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.GetFuturesTransactionHistoryDownloadLinkByIdResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.GetIncomeHistoryResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.NotionalAndLeverageBracketsResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.QueryUserRateLimitResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.SymbolConfigurationResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ToggleBnbBurnOnFuturesTradeRequest;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.ToggleBnbBurnOnFuturesTradeResponse;
import com.binance.connector.client.derivatives_trading_usds_futures.rest.model.UserCommissionRateResponse;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for AccountApi */
public class AccountApiTest {

    private AccountApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new AccountApi(apiClientSpy);
    }

    /**
     * Account Information V2(USER_DATA)
     *
     * <p>Get current account information. User in single-asset/ multi-assets mode will see
     * different value, see comments in response section for detail. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void accountInformationV2Test() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<AccountInformationV2Response> response = api.accountInformationV2(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v2/account", actualRequest.url().encodedPath());
    }

    /**
     * Account Information V3(USER_DATA)
     *
     * <p>Get current account information. User in single-asset/ multi-assets mode will see
     * different value, see comments in response section for detail. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void accountInformationV3Test() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<AccountInformationV3Response> response = api.accountInformationV3(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v3/account", actualRequest.url().encodedPath());
    }

    /**
     * Futures Account Balance V2 (USER_DATA)
     *
     * <p>Query account balance info Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void futuresAccountBalanceV2Test() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<FuturesAccountBalanceV2Response> response =
                api.futuresAccountBalanceV2(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v2/balance", actualRequest.url().encodedPath());
    }

    /**
     * Futures Account Balance V3 (USER_DATA)
     *
     * <p>Query account balance info Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void futuresAccountBalanceV3Test() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<FuturesAccountBalanceV3Response> response =
                api.futuresAccountBalanceV3(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v3/balance", actualRequest.url().encodedPath());
    }

    /**
     * Futures Account Configuration(USER_DATA)
     *
     * <p>Query account configuration Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void futuresAccountConfigurationTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<FuturesAccountConfigurationResponse> response =
                api.futuresAccountConfiguration(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/accountConfig", actualRequest.url().encodedPath());
    }

    /**
     * Futures Trading Quantitative Rules Indicators (USER_DATA)
     *
     * <p>Futures trading quantitative rules indicators, for more information on this, please refer
     * to the [Futures Trading Quantitative
     * Rules](https://www.binance.com/en/support/faq/4f462ebe6ff445d4a170be7d9e897272) Weight: - 1
     * for a single symbol - 10 when the symbol parameter is omitted
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void futuresTradingQuantitativeRulesIndicatorsTest()
            throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<FuturesTradingQuantitativeRulesIndicatorsResponse> response =
                api.futuresTradingQuantitativeRulesIndicators(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/apiTradingStatus", actualRequest.url().encodedPath());
    }

    /**
     * Get BNB Burn Status (USER_DATA)
     *
     * <p>Get user&#39;s BNB Fee Discount (Fee Discount On or Fee Discount Off ) Weight: 30
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getBnbBurnStatusTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<GetBnbBurnStatusResponse> response = api.getBnbBurnStatus(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/feeBurn", actualRequest.url().encodedPath());
    }

    /**
     * Get Current Multi-Assets Mode (USER_DATA)
     *
     * <p>Get user&#39;s Multi-Assets mode (Multi-Assets Mode or Single-Asset Mode) on ***Every
     * symbol*** Weight: 30
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getCurrentMultiAssetsModeTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<GetCurrentMultiAssetsModeResponse> response =
                api.getCurrentMultiAssetsMode(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/multiAssetsMargin", actualRequest.url().encodedPath());
    }

    /**
     * Get Current Position Mode(USER_DATA)
     *
     * <p>Get user&#39;s position mode (Hedge Mode or One-way Mode ) on ***EVERY symbol*** Weight:
     * 30
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getCurrentPositionModeTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<GetCurrentPositionModeResponse> response =
                api.getCurrentPositionMode(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/positionSide/dual", actualRequest.url().encodedPath());
    }

    /**
     * Get Download Id For Futures Order History (USER_DATA)
     *
     * <p>Get Download Id For Futures Order History * Request Limitation is 10 times per month,
     * shared by front end download page and rest api * The time between &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; can not be longer than 1 year Weight: 1000
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getDownloadIdForFuturesOrderHistoryTest() throws ApiException, CryptoException {
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long recvWindow = 5000L;
        ApiResponse<GetDownloadIdForFuturesOrderHistoryResponse> response =
                api.getDownloadIdForFuturesOrderHistory(startTime, endTime, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "startTime=1623319461670&endTime=1641782889000&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "812caedbe8f349196a4532c2050ff706ed2569fed185039c7b60a78cd84bc718",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/order/asyn", actualRequest.url().encodedPath());
    }

    /**
     * Get Download Id For Futures Trade History (USER_DATA)
     *
     * <p>Get download id for futures trade history * Request Limitation is 5 times per month,
     * shared by front end download page and rest api * The time between &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; can not be longer than 1 year Weight: 1000
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getDownloadIdForFuturesTradeHistoryTest() throws ApiException, CryptoException {
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long recvWindow = 5000L;
        ApiResponse<GetDownloadIdForFuturesTradeHistoryResponse> response =
                api.getDownloadIdForFuturesTradeHistory(startTime, endTime, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "startTime=1623319461670&endTime=1641782889000&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "812caedbe8f349196a4532c2050ff706ed2569fed185039c7b60a78cd84bc718",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/trade/asyn", actualRequest.url().encodedPath());
    }

    /**
     * Get Download Id For Futures Transaction History(USER_DATA)
     *
     * <p>Get download id for futures transaction history * Request Limitation is 5 times per month,
     * shared by front end download page and rest api * The time between &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; can not be longer than 1 year Weight: 1000
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getDownloadIdForFuturesTransactionHistoryTest()
            throws ApiException, CryptoException {
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long recvWindow = 5000L;
        ApiResponse<GetDownloadIdForFuturesTransactionHistoryResponse> response =
                api.getDownloadIdForFuturesTransactionHistory(startTime, endTime, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "startTime=1623319461670&endTime=1641782889000&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "812caedbe8f349196a4532c2050ff706ed2569fed185039c7b60a78cd84bc718",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/income/asyn", actualRequest.url().encodedPath());
    }

    /**
     * Get Futures Order History Download Link by Id (USER_DATA)
     *
     * <p>Get futures order history download link by Id * Download link expiration: 24h Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFuturesOrderHistoryDownloadLinkByIdTest() throws ApiException, CryptoException {
        String downloadId = "1";
        Long recvWindow = 5000L;
        ApiResponse<GetFuturesOrderHistoryDownloadLinkByIdResponse> response =
                api.getFuturesOrderHistoryDownloadLinkById(downloadId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "downloadId=1&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "4947fe463a17e3ec0b50fc22b21afc2aafddf3da892fa0c8dfd1b9c50af87349",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/order/asyn/id", actualRequest.url().encodedPath());
    }

    /**
     * Get Futures Trade Download Link by Id(USER_DATA)
     *
     * <p>Get futures trade download link by Id * Download link expiration: 24h Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFuturesTradeDownloadLinkByIdTest() throws ApiException, CryptoException {
        String downloadId = "1";
        Long recvWindow = 5000L;
        ApiResponse<GetFuturesTradeDownloadLinkByIdResponse> response =
                api.getFuturesTradeDownloadLinkById(downloadId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "downloadId=1&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "4947fe463a17e3ec0b50fc22b21afc2aafddf3da892fa0c8dfd1b9c50af87349",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/trade/asyn/id", actualRequest.url().encodedPath());
    }

    /**
     * Get Futures Transaction History Download Link by Id (USER_DATA)
     *
     * <p>Get futures transaction history download link by Id * Download link expiration: 24h
     * Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFuturesTransactionHistoryDownloadLinkByIdTest()
            throws ApiException, CryptoException {
        String downloadId = "1";
        Long recvWindow = 5000L;
        ApiResponse<GetFuturesTransactionHistoryDownloadLinkByIdResponse> response =
                api.getFuturesTransactionHistoryDownloadLinkById(downloadId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "downloadId=1&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "4947fe463a17e3ec0b50fc22b21afc2aafddf3da892fa0c8dfd1b9c50af87349",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/income/asyn/id", actualRequest.url().encodedPath());
    }

    /**
     * Get Income History (USER_DATA)
     *
     * <p>Query income history * If neither &#x60;startTime&#x60; nor &#x60;endTime&#x60; is sent,
     * the recent 7-day data will be returned. * If &#x60;incomeType &#x60; is not sent, all kinds
     * of flow will be returned * \&quot;trandId\&quot; is unique in the same incomeType for a user
     * * Income history only contains data for the last three months Weight: 30
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getIncomeHistoryTest() throws ApiException, CryptoException {
        String symbol = "";
        String incomeType = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long page = 0L;
        Long limit = 100L;
        Long recvWindow = 5000L;
        ApiResponse<GetIncomeHistoryResponse> response =
                api.getIncomeHistory(
                        symbol, incomeType, startTime, endTime, page, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&incomeType=&startTime=1623319461670&endTime=1641782889000&page=0&limit=100&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "05f9946fedf735df42817e55ffdc78ca315f60a95c723d2f957b7ce76546ef2e",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/income", actualRequest.url().encodedPath());
    }

    /**
     * Notional and Leverage Brackets (USER_DATA)
     *
     * <p>Query user notional and leverage bracket on speicfic symbol Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void notionalAndLeverageBracketsTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<NotionalAndLeverageBracketsResponse> response =
                api.notionalAndLeverageBrackets(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/leverageBracket", actualRequest.url().encodedPath());
    }

    /**
     * Query User Rate Limit (USER_DATA)
     *
     * <p>Query User Rate Limit Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryUserRateLimitTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<QueryUserRateLimitResponse> response = api.queryUserRateLimit(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/rateLimit/order", actualRequest.url().encodedPath());
    }

    /**
     * Symbol Configuration(USER_DATA)
     *
     * <p>Get current account symbol configuration. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void symbolConfigurationTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<SymbolConfigurationResponse> response =
                api.symbolConfiguration(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/symbolConfig", actualRequest.url().encodedPath());
    }

    /**
     * Toggle BNB Burn On Futures Trade (TRADE)
     *
     * <p>Change user&#39;s BNB Fee Discount (Fee Discount On or Fee Discount Off ) on ***EVERY
     * symbol*** Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void toggleBnbBurnOnFuturesTradeTest() throws ApiException, CryptoException {
        ToggleBnbBurnOnFuturesTradeRequest toggleBnbBurnOnFuturesTradeRequest =
                new ToggleBnbBurnOnFuturesTradeRequest();

        toggleBnbBurnOnFuturesTradeRequest.feeBurn("");

        ApiResponse<ToggleBnbBurnOnFuturesTradeResponse> response =
                api.toggleBnbBurnOnFuturesTrade(toggleBnbBurnOnFuturesTradeRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000feeBurn=", signInputCaptor.getValue());
        assertEquals(
                "b5185b9009ad5a0346daec6e86f58d6828c88fcc961b7eef5514f9bc0680560d",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/feeBurn", actualRequest.url().encodedPath());
    }

    /**
     * User Commission Rate (USER_DATA)
     *
     * <p>Get User Commission Rate Weight: 20
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void userCommissionRateTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<UserCommissionRateResponse> response =
                api.userCommissionRate(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/fapi/v1/commissionRate", actualRequest.url().encodedPath());
    }
}
