/*
 * Binance Wallet REST API
 * OpenAPI Specification for the Binance Wallet REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.wallet.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.wallet.rest.model.AllCoinsInformationResponse;
import com.binance.connector.client.wallet.rest.model.DepositAddressResponse;
import com.binance.connector.client.wallet.rest.model.DepositHistoryResponse;
import com.binance.connector.client.wallet.rest.model.FetchDepositAddressListWithNetworkResponse;
import com.binance.connector.client.wallet.rest.model.FetchWithdrawAddressListResponse;
import com.binance.connector.client.wallet.rest.model.OneClickArrivalDepositApplyRequest;
import com.binance.connector.client.wallet.rest.model.OneClickArrivalDepositApplyResponse;
import com.binance.connector.client.wallet.rest.model.WithdrawHistoryResponse;
import com.binance.connector.client.wallet.rest.model.WithdrawRequest;
import com.binance.connector.client.wallet.rest.model.WithdrawResponse;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for CapitalApi */
public class CapitalApiTest {

    private CapitalApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new CapitalApi(apiClientSpy);
    }

    /**
     * All Coins&#39; Information (USER_DATA)
     *
     * <p>Get information of coins (available for deposit and withdraw) for user. Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void allCoinsInformationTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<AllCoinsInformationResponse> response = api.allCoinsInformation(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/capital/config/getall", actualRequest.url().encodedPath());
    }

    /**
     * Deposit Address(supporting network) (USER_DATA)
     *
     * <p>Fetch deposit address with network. * If &#x60;network&#x60; is not send, return with
     * default network of the coin. * You can get &#x60;network&#x60; and &#x60;isDefault&#x60; in
     * &#x60;networkList&#x60; in the response of &#x60;Get /sapi/v1/capital/config/getall (HMAC
     * SHA256)&#x60;. * &#x60;amount&#x60; needs to be sent if using LIGHTNING network Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void depositAddressTest() throws ApiException, CryptoException {
        String coin = "";
        String network = "";
        Double amount = 1d;
        Long recvWindow = 5000L;
        ApiResponse<DepositAddressResponse> response =
                api.depositAddress(coin, network, amount, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "coin=&network=&amount=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "3adaccf2f8a7839589008cce4f4800c18fb1549a804794ea5cb13d10bee74f3f",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/capital/deposit/address", actualRequest.url().encodedPath());
    }

    /**
     * Deposit History (supporting network) (USER_DATA)
     *
     * <p>Fetch deposit history. * Please notice the default &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; to make sure that time interval is within 0-90 days. * If both
     * &#x60;&#x60;startTime&#x60;&#x60; and &#x60;&#x60;endTime&#x60;&#x60; are sent, time between
     * &#x60;&#x60;startTime&#x60;&#x60; and &#x60;&#x60;endTime&#x60;&#x60; must be less than 90
     * days. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void depositHistoryTest() throws ApiException, CryptoException {
        Boolean includeSource = false;
        String coin = "";
        Long status = 0L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long offset = 0L;
        Long limit = 7L;
        Long recvWindow = 5000L;
        String txId = "1";
        ApiResponse<DepositHistoryResponse> response =
                api.depositHistory(
                        includeSource,
                        coin,
                        status,
                        startTime,
                        endTime,
                        offset,
                        limit,
                        recvWindow,
                        txId);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "includeSource=false&coin=&status=0&startTime=1623319461670&endTime=1641782889000&offset=0&limit=7&recvWindow=5000&txId=1&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "0435c2811a4c783522fbf39f90a5899f56064cd717e2dcab5f6d7c79e129d91a",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/capital/deposit/hisrec", actualRequest.url().encodedPath());
    }

    /**
     * Fetch deposit address list with network(USER_DATA)
     *
     * <p>Fetch deposit address list with network. * If network is not send, return with default
     * network of the coin. * You can get network and isDefault in networkList in the response of
     * &#x60;Get /sapi/v1/capital/config/getall&#x60;. Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void fetchDepositAddressListWithNetworkTest() throws ApiException, CryptoException {
        String coin = "";
        String network = "";
        ApiResponse<FetchDepositAddressListWithNetworkResponse> response =
                api.fetchDepositAddressListWithNetwork(coin, network);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("coin=&network=&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "0176fed7f72375816de60776e13e1182b649bb73bb0770b876035ecc14111a5d",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/capital/deposit/address/list", actualRequest.url().encodedPath());
    }

    /**
     * Fetch withdraw address list (USER_DATA)
     *
     * <p>Fetch withdraw address list Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void fetchWithdrawAddressListTest() throws ApiException, CryptoException {
        ApiResponse<FetchWithdrawAddressListResponse> response = api.fetchWithdrawAddressList();

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "53668e00dc92eb93de0b253c301e9fc0c20042b13db384a0ad94b38688a5a84c",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/capital/withdraw/address/list", actualRequest.url().encodedPath());
    }

    /**
     * One click arrival deposit apply (for expired address deposit) (USER_DATA)
     *
     * <p>Apply deposit credit for expired address (One click arrival) * Params need to be in the
     * POST body Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void oneClickArrivalDepositApplyTest() throws ApiException, CryptoException {
        OneClickArrivalDepositApplyRequest oneClickArrivalDepositApplyRequest =
                new OneClickArrivalDepositApplyRequest();

        ApiResponse<OneClickArrivalDepositApplyResponse> response =
                api.oneClickArrivalDepositApply(oneClickArrivalDepositApplyRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "53668e00dc92eb93de0b253c301e9fc0c20042b13db384a0ad94b38688a5a84c",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/capital/deposit/credit-apply", actualRequest.url().encodedPath());
    }

    /**
     * Withdraw(USER_DATA)
     *
     * <p>Submit a withdraw request. * If &#x60;network&#x60; not send, return with default network
     * of the coin. * You can get &#x60;network&#x60; and &#x60;isDefault&#x60; in
     * &#x60;networkList&#x60; of a coin in the response of &#x60;Get /sapi/v1/capital/config/getall
     * (HMAC SHA256)&#x60;. Weight: 900
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void withdrawTest() throws ApiException, CryptoException {
        WithdrawRequest withdrawRequest = new WithdrawRequest();

        withdrawRequest.coin("");
        withdrawRequest.address("");
        withdrawRequest.amount(1d);

        ApiResponse<WithdrawResponse> response = api.withdraw(withdrawRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000amount=1&address=&coin=", signInputCaptor.getValue());
        assertEquals(
                "b319fbc9f958d7a76c51c032ba547c695396ecf0df024768f7e6e09caddf6791",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/capital/withdraw/apply", actualRequest.url().encodedPath());
    }

    /**
     * Withdraw History (supporting network) (USER_DATA)
     *
     * <p>Fetch withdraw history. * &#x60;network&#x60; may not be in the response for old withdraw.
     * * Please notice the default &#x60;startTime&#x60; and &#x60;endTime&#x60; to make sure that
     * time interval is within 0-90 days. * If both &#x60;startTime&#x60; and &#x60;endTime&#x60;are
     * sent, time between &#x60;startTime&#x60;and &#x60;endTime&#x60;must be less than 90 days. *
     * If &#x60;withdrawOrderId&#x60; is sent, time between &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; must be less than 7 days. * If &#x60;withdrawOrderId&#x60; is sent,
     * &#x60;startTime&#x60; and &#x60;endTime&#x60; are not sent, will return last 7 days records
     * by default. * Maximum support &#x60;idList&#x60; number is 45. Weight: 18000 Request limit:
     * 10 requests per second
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void withdrawHistoryTest() throws ApiException, CryptoException {
        String coin = "";
        String withdrawOrderId = "1";
        Long status = 0L;
        Long offset = 0L;
        Long limit = 7L;
        String idList = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long recvWindow = 5000L;
        ApiResponse<WithdrawHistoryResponse> response =
                api.withdrawHistory(
                        coin,
                        withdrawOrderId,
                        status,
                        offset,
                        limit,
                        idList,
                        startTime,
                        endTime,
                        recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "coin=&withdrawOrderId=1&status=0&offset=0&limit=7&idList=&startTime=1623319461670&endTime=1641782889000&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "9af7ab926930c86200dd40a05b8103457f5d21cffb03b6305d662d8126b7108f",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/capital/withdraw/history", actualRequest.url().encodedPath());
    }
}
