/*
 * Binance Wallet REST API
 * OpenAPI Specification for the Binance Wallet REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.wallet.rest.api;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.wallet.rest.model.BrokerWithdrawRequest;
import com.binance.connector.client.wallet.rest.model.BrokerWithdrawResponse;
import com.binance.connector.client.wallet.rest.model.DepositHistoryTravelRuleResponse;
import com.binance.connector.client.wallet.rest.model.SubmitDepositQuestionnaireRequest;
import com.binance.connector.client.wallet.rest.model.SubmitDepositQuestionnaireResponse;
import com.binance.connector.client.wallet.rest.model.SubmitDepositQuestionnaireTravelRuleRequest;
import com.binance.connector.client.wallet.rest.model.SubmitDepositQuestionnaireTravelRuleResponse;
import com.binance.connector.client.wallet.rest.model.VaspListResponse;
import com.binance.connector.client.wallet.rest.model.WithdrawHistoryV1Response;
import com.binance.connector.client.wallet.rest.model.WithdrawHistoryV2Response;
import com.binance.connector.client.wallet.rest.model.WithdrawTravelRuleRequest;
import com.binance.connector.client.wallet.rest.model.WithdrawTravelRuleResponse;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

import static org.junit.Assert.assertEquals;

/** API tests for TravelRuleApi */
public class TravelRuleApiTest {

    private TravelRuleApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new TravelRuleApi(apiClientSpy);
    }

    /**
     * Broker Withdraw (for brokers of local entities that require travel rule) (USER_DATA)
     *
     * <p>Submit a withdrawal request for brokers of local entities that required travel rule. * If
     * &#x60;network&#x60; not send, return with default network of the coin, but if the address
     * could not match default network, the withdraw will be rejected. * You can get
     * &#x60;network&#x60; in &#x60;networkList&#x60; of a coin in the response * Questionnaire is
     * different for each local entity, please refer to * If getting error like &#x60;Questionnaire
     * format not valid.&#x60; or &#x60;Questionnaire must not be blank&#x60;, Weight: 600
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void brokerWithdrawTest() throws ApiException, CryptoException {
        BrokerWithdrawRequest brokerWithdrawRequest = new BrokerWithdrawRequest();

        brokerWithdrawRequest.address("");
        brokerWithdrawRequest.coin("");
        brokerWithdrawRequest.amount(1d);
        brokerWithdrawRequest.withdrawOrderId("1");
        brokerWithdrawRequest.questionnaire("");
        brokerWithdrawRequest.originatorPii("");
        brokerWithdrawRequest.signature("");

        ApiResponse<BrokerWithdrawResponse> response = api.brokerWithdraw(brokerWithdrawRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000amount=1&questionnaire=&address=&originatorPii=&signature=&withdrawOrderId=1&coin=",
                signInputCaptor.getValue());
        assertEquals(
                "6ce402e604ac1f40520a2141d76058ffdf83f05b607f6d223735777372cc792a",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/localentity/broker/withdraw/apply", actualRequest.url().encodedPath());
    }

    /**
     * Deposit History (for local entities that required travel rule) (supporting network)
     * (USER_DATA)
     *
     * <p>Fetch deposit history for local entities that required travel rule. * Please notice the
     * default &#x60;startTime&#x60; and &#x60;endTime&#x60; to make sure that time interval is
     * within * If both &#x60;&#x60;startTime&#x60;&#x60; and &#x60;&#x60;endTime&#x60;&#x60; are
     * sent, time between &#x60;&#x60;startTime&#x60;&#x60; and &#x60;&#x60;endTime&#x60;&#x60; must
     * Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void depositHistoryTravelRuleTest() throws ApiException, CryptoException {
        String trId = "1";
        String txId = "1";
        String tranId = "1";
        String network = "";
        String coin = "";
        Long travelRuleStatus = 0L;
        Boolean pendingQuestionnaire = true;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long offset = 0L;
        Long limit = 7L;
        ApiResponse<DepositHistoryTravelRuleResponse> response =
                api.depositHistoryTravelRule(
                        trId,
                        txId,
                        tranId,
                        network,
                        coin,
                        travelRuleStatus,
                        pendingQuestionnaire,
                        startTime,
                        endTime,
                        offset,
                        limit);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "trId=1&txId=1&tranId=1&network=&coin=&travelRuleStatus=0&pendingQuestionnaire=true&startTime=1623319461670&endTime=1641782889000&offset=0&limit=7&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "bf7c19baf5be02bb16000deb65b9564080523e751dc8e0b4bdd740b8d4106acd",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/localentity/deposit/history", actualRequest.url().encodedPath());
    }

    /**
     * Onboarded VASP list (for local entities that require travel rule) (supporting network)
     * (USER_DATA)
     *
     * <p>Fetch the onboarded VASP list for local entities that required travel rule. * This
     * endpoint specifically uses per second IP rate limit, user&#39;s total second level IP rate
     * Weight: 18000 Request limit: 10 requests per second &gt; * This endpoint specifically uses
     * per second IP rate limit, user&#39;s total second level IP rate limit is 180000/second.
     * Response from the endpoint contains header key X-SAPI-USED-IP-WEIGHT-1S, which defines weight
     * used by the current IP.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void onboardedVaspListTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<VaspListResponse> vaspListResponseApiResponse = api.vaspList(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/localentity/vasp", actualRequest.url().encodedPath());
    }

    /**
     * Submit Deposit Questionnaire (For local entities that require travel rule) (supporting
     * network) (USER_DATA)
     *
     * <p>Submit questionnaire for brokers of local entities that require travel rule. The
     * questionnaire is only applies to transactions from un-hosted wallets or VASPs that are not
     * yet onboarded with GTR. * Questionnaire is different for each local entity, please refer * If
     * getting error like &#x60;Questionnaire format not valid.&#x60; or &#x60;Questionnaire must
     * not be blank&#x60;, Weight: 600
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void submitDepositQuestionnaireTest() throws ApiException, CryptoException {
        SubmitDepositQuestionnaireRequest submitDepositQuestionnaireRequest =
                new SubmitDepositQuestionnaireRequest();

        submitDepositQuestionnaireRequest.subAccountId("1");
        submitDepositQuestionnaireRequest.depositId("1");
        submitDepositQuestionnaireRequest.questionnaire("");
        submitDepositQuestionnaireRequest.beneficiaryPii("");
        submitDepositQuestionnaireRequest.signature("");

        ApiResponse<SubmitDepositQuestionnaireResponse> response =
                api.submitDepositQuestionnaire(submitDepositQuestionnaireRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000depositId=1&questionnaire=&subAccountId=1&signature=&beneficiaryPii=",
                signInputCaptor.getValue());
        assertEquals(
                "c4bbb7027534c11fe660c1aa3f3389c8dc17e536410954b4f9d83978c3962d8b",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/localentity/broker/deposit/provide-info",
                actualRequest.url().encodedPath());
    }

    /**
     * Submit Deposit Questionnaire (For local entities that require travel rule) (supporting
     * network) (USER_DATA)
     *
     * <p>Submit questionnaire for local entities that require travel rule. The questionnaire is
     * only applies to transactions from unhosted wallets or VASPs that are not yet onboarded with
     * GTR. * Questionnaire is different for each local entity, please refer * If getting error like
     * &#x60;Questionnaire format not valid.&#x60; or &#x60;Questionnaire must not be blank&#x60;,
     * Weight: 600
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void submitDepositQuestionnaireTravelRuleTest() throws ApiException, CryptoException {
        SubmitDepositQuestionnaireTravelRuleRequest submitDepositQuestionnaireTravelRuleRequest =
                new SubmitDepositQuestionnaireTravelRuleRequest();

        submitDepositQuestionnaireTravelRuleRequest.tranId(1L);
        submitDepositQuestionnaireTravelRuleRequest.questionnaire("");

        ApiResponse<SubmitDepositQuestionnaireTravelRuleResponse> response =
                api.submitDepositQuestionnaireTravelRule(
                        submitDepositQuestionnaireTravelRuleRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000tranId=1&questionnaire=", signInputCaptor.getValue());
        assertEquals(
                "020cf8035001d243dd7a11f2af50c753cad954902892ef59cb222ea644dd54cf",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/localentity/deposit/provide-info", actualRequest.url().encodedPath());
    }

    /**
     * Withdraw History (for local entities that require travel rule) (supporting network)
     * (USER_DATA)
     *
     * <p>Fetch withdraw history for local entities that required travel rule. * This endpoint
     * specifically uses per second IP rate limit, user&#39;s total second level IP rate *
     * &#x60;network&#x60; may not be in the response for old withdraw. * Please notice the default
     * &#x60;startTime&#x60; and &#x60;endTime&#x60; to make sure that time interval is within * If
     * both &#x60;startTime&#x60; and &#x60;endTime&#x60;are sent, time between
     * &#x60;startTime&#x60;and &#x60;endTime&#x60;must be less Weight: 18000 Request limit: 10
     * requests per second &gt; * This endpoint specifically uses per second IP rate limit,
     * user&#39;s total second level IP rate limit is 180000/second. Response from the endpoint
     * contains header key X-SAPI-USED-IP-WEIGHT-1S, which defines weight used by the current IP.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void withdrawHistoryV1Test() throws ApiException, CryptoException {
        String trId = "1";
        String txId = "1";
        String withdrawOrderId = "1";
        String network = "";
        String coin = "";
        Long travelRuleStatus = 0L;
        Long offset = 0L;
        Long limit = 7L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long recvWindow = 5000L;
        ApiResponse<WithdrawHistoryV1Response> response =
                api.withdrawHistoryV1(
                        trId,
                        txId,
                        withdrawOrderId,
                        network,
                        coin,
                        travelRuleStatus,
                        offset,
                        limit,
                        startTime,
                        endTime,
                        recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "trId=1&txId=1&withdrawOrderId=1&network=&coin=&travelRuleStatus=0&offset=0&limit=7&startTime=1623319461670&endTime=1641782889000&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "c9d943d585057bc16f31e43b0069bc8759c99f467198f5992994ff387ca4384b",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/localentity/withdraw/history", actualRequest.url().encodedPath());
    }

    /**
     * Withdraw History V2 (for local entities that require travel rule) (supporting network)
     * (USER_DATA)
     *
     * <p>Fetch withdraw history for local entities that required travel rule. * This endpoint
     * specifically uses per second IP rate limit, user&#39;s total second level IP rate *
     * &#x60;network&#x60; may not be in the response for old withdraw. * Withdrawal made through
     * /sapi/v1/capital/withdraw/apply may not be in the response. * Please notice the default
     * &#x60;startTime&#x60; and &#x60;endTime&#x60; to make sure that time interval is within * If
     * both &#x60;startTime&#x60; and &#x60;endTime&#x60;are sent, time between
     * &#x60;startTime&#x60;and &#x60;endTime&#x60;must be less * If withdrawOrderId is sent, time
     * between startTime and endTime must be less than 7 days. * If withdrawOrderId is sent,
     * startTime and endTime are not sent, will return last 7 days records by default. * Maximum
     * support trId,txId number is 45. * WithdrawOrderId only support 1. * If responsible does not
     * include withdrawalStatus, please input trId or txId retrieve the data. Weight: 18000 Request
     * limit: 10 requests per second &gt; * This endpoint specifically uses per second IP rate
     * limit, user&#39;s total second level IP rate limit is 180000/second. Response from the
     * endpoint contains header key X-SAPI-USED-IP-WEIGHT-1S, which defines weight used by the
     * current IP.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void withdrawHistoryV2Test() throws ApiException, CryptoException {
        String trId = "1";
        String txId = "1";
        String withdrawOrderId = "1";
        String network = "";
        String coin = "";
        Long travelRuleStatus = 0L;
        Long offset = 0L;
        Long limit = 7L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long recvWindow = 5000L;
        ApiResponse<WithdrawHistoryV2Response> response =
                api.withdrawHistoryV2(
                        trId,
                        txId,
                        withdrawOrderId,
                        network,
                        coin,
                        travelRuleStatus,
                        offset,
                        limit,
                        startTime,
                        endTime,
                        recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "trId=1&txId=1&withdrawOrderId=1&network=&coin=&travelRuleStatus=0&offset=0&limit=7&startTime=1623319461670&endTime=1641782889000&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "c9d943d585057bc16f31e43b0069bc8759c99f467198f5992994ff387ca4384b",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v2/localentity/withdraw/history", actualRequest.url().encodedPath());
    }

    /**
     * Withdraw (for local entities that require travel rule) (USER_DATA)
     *
     * <p>Submit a withdrawal request for local entities that required travel rule. * If
     * &#x60;network&#x60; not send, return with default network of the coin, but if the address
     * could not match default network, the withdraw will be rejected. * You can get
     * &#x60;network&#x60; and &#x60;isDefault&#x60; in &#x60;networkList&#x60; of a coin in the
     * response * Questionnaire is different for each local entity, please refer to * If getting
     * error like &#x60;Questionnaire format not valid.&#x60; or &#x60;Questionnaire must not be
     * blank&#x60;, Weight: 600
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void withdrawTravelRuleTest() throws ApiException, CryptoException {
        WithdrawTravelRuleRequest withdrawTravelRuleRequest = new WithdrawTravelRuleRequest();

        withdrawTravelRuleRequest.coin("");
        withdrawTravelRuleRequest.address("");
        withdrawTravelRuleRequest.amount(1d);
        withdrawTravelRuleRequest.questionnaire("");

        ApiResponse<WithdrawTravelRuleResponse> response =
                api.withdrawTravelRule(withdrawTravelRuleRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000amount=1&questionnaire=&address=&coin=",
                signInputCaptor.getValue());
        assertEquals(
                "30a5f51ebf4cf7070fe2301951f7720bba2ab127a668eab66e65c551e67a0963",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/localentity/withdraw/apply", actualRequest.url().encodedPath());
    }
}
