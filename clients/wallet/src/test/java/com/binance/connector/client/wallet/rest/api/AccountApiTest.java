/*
 * Binance Wallet REST API
 * OpenAPI Specification for the Binance Wallet REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.wallet.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.wallet.rest.model.AccountApiTradingStatusResponse;
import com.binance.connector.client.wallet.rest.model.AccountInfoResponse;
import com.binance.connector.client.wallet.rest.model.AccountStatusResponse;
import com.binance.connector.client.wallet.rest.model.DailyAccountSnapshotResponse;
import com.binance.connector.client.wallet.rest.model.DisableFastWithdrawSwitchRequest;
import com.binance.connector.client.wallet.rest.model.EnableFastWithdrawSwitchRequest;
import com.binance.connector.client.wallet.rest.model.GetApiKeyPermissionResponse;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for AccountApi */
public class AccountApiTest {

    private AccountApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new AccountApi(apiClientSpy);
    }

    /**
     * Account API Trading Status (USER_DATA)
     *
     * <p>Fetch account api trading status detail. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void accountApiTradingStatusTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<AccountApiTradingStatusResponse> response =
                api.accountApiTradingStatus(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/account/apiTradingStatus", actualRequest.url().encodedPath());
    }

    /**
     * Account info (USER_DATA)
     *
     * <p>Fetch account info detail. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void accountInfoTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<AccountInfoResponse> response = api.accountInfo(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/account/info", actualRequest.url().encodedPath());
    }

    /**
     * Account Status (USER_DATA)
     *
     * <p>Fetch account status detail. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void accountStatusTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<AccountStatusResponse> response = api.accountStatus(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/account/status", actualRequest.url().encodedPath());
    }

    /**
     * Daily Account Snapshot (USER_DATA)
     *
     * <p>Daily account snapshot * The query time period must be less then 30 days * Support query
     * within the last one month only * If startTimeand endTime not sent, return records of the last
     * 7 days by default Weight: 2400
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void dailyAccountSnapshotTest() throws ApiException, CryptoException {
        String type = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 7L;
        Long recvWindow = 5000L;
        ApiResponse<DailyAccountSnapshotResponse> response =
                api.dailyAccountSnapshot(type, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "type=&startTime=1623319461670&endTime=1641782889000&limit=7&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "7f5d880300068afcaef8978dcf0b77c58c8307d0f2de2302fd75872e33a68f9e",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/accountSnapshot", actualRequest.url().encodedPath());
    }

    /**
     * Disable Fast Withdraw Switch (USER_DATA)
     *
     * <p>Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void disableFastWithdrawSwitchTest() throws ApiException, CryptoException {
        DisableFastWithdrawSwitchRequest disableFastWithdrawSwitchRequest =
                new DisableFastWithdrawSwitchRequest();

        api.disableFastWithdrawSwitch(disableFastWithdrawSwitchRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy).execute(callArgumentCaptor.capture());

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "53668e00dc92eb93de0b253c301e9fc0c20042b13db384a0ad94b38688a5a84c",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/account/disableFastWithdrawSwitch", actualRequest.url().encodedPath());
    }

    /**
     * Enable Fast Withdraw Switch (USER_DATA)
     *
     * <p>Enable Fast Withdraw Switch (USER_DATA) * This request will enable fastwithdraw switch
     * under your account. &lt;br&gt;&lt;/br&gt; * When Fast Withdraw Switch is on, transferring
     * funds to a Binance account will be done instantly. There is no on-chain transaction, no
     * transaction ID and no withdrawal fee. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void enableFastWithdrawSwitchTest() throws ApiException, CryptoException {
        EnableFastWithdrawSwitchRequest enableFastWithdrawSwitchRequest =
                new EnableFastWithdrawSwitchRequest();

        api.enableFastWithdrawSwitch(enableFastWithdrawSwitchRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy).execute(callArgumentCaptor.capture());

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "53668e00dc92eb93de0b253c301e9fc0c20042b13db384a0ad94b38688a5a84c",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/account/enableFastWithdrawSwitch", actualRequest.url().encodedPath());
    }

    /**
     * Get API Key Permission (USER_DATA)
     *
     * <p>Get API Key Permission Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getApiKeyPermissionTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<GetApiKeyPermissionResponse> response = api.getApiKeyPermission(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/account/apiRestrictions", actualRequest.url().encodedPath());
    }
}
