/*
 * Binance Wallet REST API
 * OpenAPI Specification for the Binance Wallet REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.wallet.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.wallet.rest.model.AssetDetailResponse;
import com.binance.connector.client.wallet.rest.model.AssetDividendRecordResponse;
import com.binance.connector.client.wallet.rest.model.DustTransferRequest;
import com.binance.connector.client.wallet.rest.model.DustTransferResponse;
import com.binance.connector.client.wallet.rest.model.DustlogResponse;
import com.binance.connector.client.wallet.rest.model.FundingWalletRequest;
import com.binance.connector.client.wallet.rest.model.FundingWalletResponse;
import com.binance.connector.client.wallet.rest.model.GetAssetsThatCanBeConvertedIntoBnbRequest;
import com.binance.connector.client.wallet.rest.model.GetAssetsThatCanBeConvertedIntoBnbResponse;
import com.binance.connector.client.wallet.rest.model.GetCloudMiningPaymentAndRefundHistoryResponse;
import com.binance.connector.client.wallet.rest.model.GetOpenSymbolListResponse;
import com.binance.connector.client.wallet.rest.model.QueryUserDelegationHistoryResponse;
import com.binance.connector.client.wallet.rest.model.QueryUserUniversalTransferHistoryResponse;
import com.binance.connector.client.wallet.rest.model.QueryUserWalletBalanceResponse;
import com.binance.connector.client.wallet.rest.model.ToggleBnbBurnOnSpotTradeAndMarginInterestRequest;
import com.binance.connector.client.wallet.rest.model.ToggleBnbBurnOnSpotTradeAndMarginInterestResponse;
import com.binance.connector.client.wallet.rest.model.TradeFeeResponse;
import com.binance.connector.client.wallet.rest.model.UserAssetRequest;
import com.binance.connector.client.wallet.rest.model.UserAssetResponse;
import com.binance.connector.client.wallet.rest.model.UserUniversalTransferRequest;
import com.binance.connector.client.wallet.rest.model.UserUniversalTransferResponse;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for AssetApi */
public class AssetApiTest {

    private AssetApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new AssetApi(apiClientSpy);
    }

    /**
     * Asset Detail (USER_DATA)
     *
     * <p>Fetch details of assets supported on Binance. * Please get network and other deposit or
     * withdraw details from &#x60;&#x60;GET /sapi/v1/capital/config/getall&#x60;&#x60;. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void assetDetailTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<AssetDetailResponse> response = api.assetDetail(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/asset/assetDetail", actualRequest.url().encodedPath());
    }

    /**
     * Asset Dividend Record (USER_DATA)
     *
     * <p>Query asset dividend record. * There cannot be more than 180 days between parameter
     * &#x60;startTime&#x60; and &#x60;endTime&#x60;. Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void assetDividendRecordTest() throws ApiException, CryptoException {
        String asset = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 7L;
        Long recvWindow = 5000L;
        ApiResponse<AssetDividendRecordResponse> response =
                api.assetDividendRecord(asset, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "asset=&startTime=1623319461670&endTime=1641782889000&limit=7&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "68e772371d381d772449272107ff583a7c33dce3bd72ee211bd0ff3e4d9de7d9",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/asset/assetDividend", actualRequest.url().encodedPath());
    }

    /**
     * Dust Transfer (USER_DATA)
     *
     * <p>Convert dust assets to BNB. * You need to open&#x60;Enable Spot &amp; Margin Trading&#x60;
     * permission for the API Key which requests this endpoint. Weight: 10
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void dustTransferTest() throws ApiException, CryptoException {
        DustTransferRequest dustTransferRequest = new DustTransferRequest();

        dustTransferRequest.asset("");

        ApiResponse<DustTransferResponse> response = api.dustTransfer(dustTransferRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000asset=", signInputCaptor.getValue());
        assertEquals(
                "733c2733b75fbea096af9abd7a6e22ac4cce318248e66e514087362c82db2bf1",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/asset/dust", actualRequest.url().encodedPath());
    }

    /**
     * DustLog(USER_DATA)
     *
     * <p>Dustlog * Only return last 100 records * Only return records after 2020/12/01 Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void dustlogTest() throws ApiException, CryptoException {
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long recvWindow = 5000L;
        ApiResponse<DustlogResponse> response = api.dustlog(startTime, endTime, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "startTime=1623319461670&endTime=1641782889000&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "812caedbe8f349196a4532c2050ff706ed2569fed185039c7b60a78cd84bc718",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/asset/dribblet", actualRequest.url().encodedPath());
    }

    /**
     * Funding Wallet (USER_DATA)
     *
     * <p>Query Funding Wallet * Currently supports querying the following business assets：Binance
     * Pay, Binance Card, Binance Gift Card, Stock Token Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void fundingWalletTest() throws ApiException, CryptoException {
        FundingWalletRequest fundingWalletRequest = new FundingWalletRequest();

        ApiResponse<FundingWalletResponse> response = api.fundingWallet(fundingWalletRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "53668e00dc92eb93de0b253c301e9fc0c20042b13db384a0ad94b38688a5a84c",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/asset/get-funding-asset", actualRequest.url().encodedPath());
    }

    /**
     * Get Assets That Can Be Converted Into BNB (USER_DATA)
     *
     * <p>Get Assets That Can Be Converted Into BNB Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAssetsThatCanBeConvertedIntoBnbTest() throws ApiException, CryptoException {
        GetAssetsThatCanBeConvertedIntoBnbRequest getAssetsThatCanBeConvertedIntoBnbRequest =
                new GetAssetsThatCanBeConvertedIntoBnbRequest();

        ApiResponse<GetAssetsThatCanBeConvertedIntoBnbResponse> response =
                api.getAssetsThatCanBeConvertedIntoBnb(getAssetsThatCanBeConvertedIntoBnbRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "53668e00dc92eb93de0b253c301e9fc0c20042b13db384a0ad94b38688a5a84c",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/asset/dust-btc", actualRequest.url().encodedPath());
    }

    /**
     * Get Cloud-Mining payment and refund history (USER_DATA)
     *
     * <p>The query of Cloud-Mining payment and refund history * Just return the SUCCESS records of
     * payment and refund. * For response, type &#x3D; 248 means payment, type &#x3D; 249 means
     * refund, status &#x3D;S means SUCCESS. Weight: 600
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getCloudMiningPaymentAndRefundHistoryTest() throws ApiException, CryptoException {
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long tranId = 1L;
        String clientTranId = "1";
        String asset = "";
        Long current = 1L;
        Long size = 10L;
        ApiResponse<GetCloudMiningPaymentAndRefundHistoryResponse> response =
                api.getCloudMiningPaymentAndRefundHistory(
                        startTime, endTime, tranId, clientTranId, asset, current, size);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "tranId=1&clientTranId=1&asset=&startTime=1623319461670&endTime=1641782889000&current=1&size=10&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "8ef5140dd72003ac47e15d9ab53c2d9f14ce6cdcd5ad9c8f13aad7ff76691f2d",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/asset/ledger-transfer/cloud-mining/queryByPage",
                actualRequest.url().encodedPath());
    }

    /**
     * Get Open Symbol List (MARKET_DATA)
     *
     * <p>Get the list of symbols that are scheduled to be opened for trading in the market. Weight:
     * 100
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getOpenSymbolListTest() throws ApiException, CryptoException {
        ApiResponse<GetOpenSymbolListResponse> response = api.getOpenSymbolList();

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/spot/open-symbol-list", actualRequest.url().encodedPath());
    }

    /**
     * Query User Delegation History(For Master Account)(USER_DATA)
     *
     * <p>Query User Delegation History * You need to open Enable Spot &amp; Margin Trading
     * permission for the API Key which requests this endpoint Weight: 60
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryUserDelegationHistoryTest() throws ApiException, CryptoException {
        String email = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        String type = "";
        String asset = "";
        Long current = 1L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<QueryUserDelegationHistoryResponse> response =
                api.queryUserDelegationHistory(
                        email, startTime, endTime, type, asset, current, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "email=&startTime=1623319461670&endTime=1641782889000&type=&asset=&current=1&size=10&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "275c21d8b18284d8e829a5b0cbde5f90d8fbf2213ab01193deaf7129ec87a1d8",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/asset/custody/transfer-history", actualRequest.url().encodedPath());
    }

    /**
     * Query User Universal Transfer History(USER_DATA)
     *
     * <p>Query User Universal Transfer History * &#x60;fromSymbol&#x60; must be sent when type are
     * ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN * &#x60;toSymbol&#x60; must be sent
     * when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN * Support query within
     * the last 6 months only * If &#x60;startTime&#x60;and &#x60;endTime&#x60; not sent, return
     * records of the last 7 days by default Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryUserUniversalTransferHistoryTest() throws ApiException, CryptoException {
        String type = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long current = 1L;
        Long size = 10L;
        String fromSymbol = "";
        String toSymbol = "";
        Long recvWindow = 5000L;
        ApiResponse<QueryUserUniversalTransferHistoryResponse> response =
                api.queryUserUniversalTransferHistory(
                        type, startTime, endTime, current, size, fromSymbol, toSymbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "type=&startTime=1623319461670&endTime=1641782889000&current=1&size=10&fromSymbol=&toSymbol=&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "ffae64ec239a949e8770619077f2814a553facac70bc81b25a3a04c9947dde91",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/asset/transfer", actualRequest.url().encodedPath());
    }

    /**
     * Query User Wallet Balance (USER_DATA)
     *
     * <p>Query User Wallet Balance * You need to open Permits Universal Transfer permission for the
     * API Key which requests this endpoint. Weight: 60
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryUserWalletBalanceTest() throws ApiException, CryptoException {
        String quoteAsset = "BTC";
        Long recvWindow = 5000L;
        ApiResponse<QueryUserWalletBalanceResponse> response =
                api.queryUserWalletBalance(quoteAsset, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "quoteAsset=BTC&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "fb7a854542348a3445f9dbdab6d6639e8d3dedbacc4a203868c4bb12fe280d54",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/asset/wallet/balance", actualRequest.url().encodedPath());
    }

    /**
     * Toggle BNB Burn On Spot Trade And Margin Interest (USER_DATA)
     *
     * <p>Toggle BNB Burn On Spot Trade And Margin Interest * \&quot;spotBNBBurn\&quot; and
     * \&quot;interestBNBBurn\&quot; should be sent at least one. Weight: 1(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void toggleBnbBurnOnSpotTradeAndMarginInterestTest()
            throws ApiException, CryptoException {
        ToggleBnbBurnOnSpotTradeAndMarginInterestRequest
                toggleBnbBurnOnSpotTradeAndMarginInterestRequest =
                        new ToggleBnbBurnOnSpotTradeAndMarginInterestRequest();

        ApiResponse<ToggleBnbBurnOnSpotTradeAndMarginInterestResponse> response =
                api.toggleBnbBurnOnSpotTradeAndMarginInterest(
                        toggleBnbBurnOnSpotTradeAndMarginInterestRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "53668e00dc92eb93de0b253c301e9fc0c20042b13db384a0ad94b38688a5a84c",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/bnbBurn", actualRequest.url().encodedPath());
    }

    /**
     * Trade Fee (USER_DATA)
     *
     * <p>Fetch trade fee Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void tradeFeeTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<TradeFeeResponse> response = api.tradeFee(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/asset/tradeFee", actualRequest.url().encodedPath());
    }

    /**
     * User Asset (USER_DATA)
     *
     * <p>Get user assets, just for positive data. * If asset is set, then return this asset,
     * otherwise return all assets positive. * If needBtcValuation is set, then return
     * btcValudation. Weight: 5
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void userAssetTest() throws ApiException, CryptoException {
        UserAssetRequest userAssetRequest = new UserAssetRequest();

        ApiResponse<UserAssetResponse> response = api.userAsset(userAssetRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "53668e00dc92eb93de0b253c301e9fc0c20042b13db384a0ad94b38688a5a84c",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v3/asset/getUserAsset", actualRequest.url().encodedPath());
    }

    /**
     * User Universal Transfer (USER_DATA)
     *
     * <p>user universal transfer * &#x60;fromSymbol&#x60; must be sent when type are
     * ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN * &#x60;toSymbol&#x60; must be sent
     * when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN * ENUM of transfer
     * types: * MAIN_UMFUTURE Spot account transfer to USDⓈ-M Futures account * MAIN_CMFUTURE Spot
     * account transfer to COIN-M Futures account * MAIN_MARGIN Spot account transfer to
     * Margin（cross）account * UMFUTURE_MAIN USDⓈ-M Futures account transfer to Spot account *
     * UMFUTURE_MARGIN USDⓈ-M Futures account transfer to Margin（cross）account * CMFUTURE_MAIN
     * COIN-M Futures account transfer to Spot account * CMFUTURE_MARGIN COIN-M Futures account
     * transfer to Margin(cross) account * MARGIN_MAIN Margin（cross）account transfer to Spot account
     * * MARGIN_UMFUTURE Margin（cross）account transfer to USDⓈ-M Futures * MARGIN_CMFUTURE
     * Margin（cross）account transfer to COIN-M Futures * ISOLATEDMARGIN_MARGIN Isolated margin
     * account transfer to Margin(cross) account * MARGIN_ISOLATEDMARGIN Margin(cross) account
     * transfer to Isolated margin account * ISOLATEDMARGIN_ISOLATEDMARGIN Isolated margin account
     * transfer to Isolated margin account * MAIN_FUNDING Spot account transfer to Funding account *
     * FUNDING_MAIN Funding account transfer to Spot account * FUNDING_UMFUTURE Funding account
     * transfer to UMFUTURE account * UMFUTURE_FUNDING UMFUTURE account transfer to Funding account
     * * MARGIN_FUNDING MARGIN account transfer to Funding account * FUNDING_MARGIN Funding account
     * transfer to Margin account * FUNDING_CMFUTURE Funding account transfer to CMFUTURE account *
     * CMFUTURE_FUNDING CMFUTURE account transfer to Funding account * MAIN_OPTION Spot account
     * transfer to Options account * OPTION_MAIN Options account transfer to Spot account *
     * UMFUTURE_OPTION USDⓈ-M Futures account transfer to Options account * OPTION_UMFUTURE Options
     * account transfer to USDⓈ-M Futures account * MARGIN_OPTION Margin（cross）account transfer to
     * Options account * OPTION_MARGIN Options account transfer to Margin（cross）account *
     * FUNDING_OPTION Funding account transfer to Options account * OPTION_FUNDING Options account
     * transfer to Funding account * MAIN_PORTFOLIO_MARGIN Spot account transfer to Portfolio Margin
     * account * PORTFOLIO_MARGIN_MAIN Portfolio Margin account transfer to Spot account Weight: 900
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void userUniversalTransferTest() throws ApiException, CryptoException {
        UserUniversalTransferRequest userUniversalTransferRequest =
                new UserUniversalTransferRequest();

        userUniversalTransferRequest.type("");
        userUniversalTransferRequest.asset("");
        userUniversalTransferRequest.amount(1d);

        ApiResponse<UserUniversalTransferResponse> response =
                api.userUniversalTransfer(userUniversalTransferRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000amount=1&type=&asset=", signInputCaptor.getValue());
        assertEquals(
                "99b384ce1ec34b5e4e6569c568238a6da2b12e52e022fe55e390faf2d1ce3e60",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/asset/transfer", actualRequest.url().encodedPath());
    }
}
