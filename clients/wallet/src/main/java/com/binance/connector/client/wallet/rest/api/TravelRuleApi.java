/*
 * Binance Wallet REST API
 * OpenAPI Specification for the Binance Wallet REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.wallet.rest.api;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.DecimalFormatter;
import com.binance.connector.client.common.Pair;
import com.binance.connector.client.common.SystemUtil;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.exception.ConstraintViolationException;
import com.binance.connector.client.wallet.rest.model.BrokerWithdrawRequest;
import com.binance.connector.client.wallet.rest.model.BrokerWithdrawResponse;
import com.binance.connector.client.wallet.rest.model.DepositHistoryTravelRuleResponse;
import com.binance.connector.client.wallet.rest.model.FetchAddressVerificationListResponse;
import com.binance.connector.client.wallet.rest.model.OnboardedVaspListResponse;
import com.binance.connector.client.wallet.rest.model.SubmitDepositQuestionnaireRequest;
import com.binance.connector.client.wallet.rest.model.SubmitDepositQuestionnaireResponse;
import com.binance.connector.client.wallet.rest.model.SubmitDepositQuestionnaireTravelRuleRequest;
import com.binance.connector.client.wallet.rest.model.SubmitDepositQuestionnaireTravelRuleResponse;
import com.binance.connector.client.wallet.rest.model.WithdrawHistoryV1Response;
import com.binance.connector.client.wallet.rest.model.WithdrawHistoryV2Response;
import com.binance.connector.client.wallet.rest.model.WithdrawTravelRuleRequest;
import com.binance.connector.client.wallet.rest.model.WithdrawTravelRuleResponse;
import com.google.gson.reflect.TypeToken;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Valid;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.constraints.*;
import jakarta.validation.executable.ExecutableValidator;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator;

public class TravelRuleApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    private static final String USER_AGENT =
            String.format(
                    "binance-wallet/2.0.0 (Java/%s; %s; %s)",
                    SystemUtil.getJavaVersion(), SystemUtil.getOs(), SystemUtil.getArch());
    private static final boolean HAS_TIME_UNIT = false;

    public TravelRuleApi(ClientConfiguration clientConfiguration) {
        this(new ApiClient(clientConfiguration));
    }

    public TravelRuleApi(ApiClient apiClient) {
        apiClient.setUserAgent(USER_AGENT);
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for brokerWithdraw
     *
     * @param brokerWithdrawRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Broker Withdraw </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a href="https://developers.binance.com/docs/wallet/travel-rule/Broker-Withdraw">Broker
     *     Withdraw (for brokers of local entities that require travel rule) (USER_DATA)
     *     Documentation</a>
     */
    private okhttp3.Call brokerWithdrawCall(BrokerWithdrawRequest brokerWithdrawRequest)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/localentity/broker/withdraw/apply";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (brokerWithdrawRequest.getAddress() != null) {
            localVarFormParams.put("address", brokerWithdrawRequest.getAddress());
        }

        if (brokerWithdrawRequest.getAddressTag() != null) {
            localVarFormParams.put("addressTag", brokerWithdrawRequest.getAddressTag());
        }

        if (brokerWithdrawRequest.getNetwork() != null) {
            localVarFormParams.put("network", brokerWithdrawRequest.getNetwork());
        }

        if (brokerWithdrawRequest.getCoin() != null) {
            localVarFormParams.put("coin", brokerWithdrawRequest.getCoin());
        }

        if (brokerWithdrawRequest.getAddressName() != null) {
            localVarFormParams.put("addressName", brokerWithdrawRequest.getAddressName());
        }

        if (brokerWithdrawRequest.getAmount() != null) {
            localVarFormParams.put(
                    "amount",
                    DecimalFormatter.getFormatter().format(brokerWithdrawRequest.getAmount()));
        }

        if (brokerWithdrawRequest.getWithdrawOrderId() != null) {
            localVarFormParams.put("withdrawOrderId", brokerWithdrawRequest.getWithdrawOrderId());
        }

        if (brokerWithdrawRequest.getTransactionFeeFlag() != null) {
            localVarFormParams.put(
                    "transactionFeeFlag", brokerWithdrawRequest.getTransactionFeeFlag());
        }

        if (brokerWithdrawRequest.getWalletType() != null) {
            localVarFormParams.put("walletType", brokerWithdrawRequest.getWalletType());
        }

        if (brokerWithdrawRequest.getQuestionnaire() != null) {
            localVarFormParams.put("questionnaire", brokerWithdrawRequest.getQuestionnaire());
        }

        if (brokerWithdrawRequest.getOriginatorPii() != null) {
            localVarFormParams.put("originatorPii", brokerWithdrawRequest.getOriginatorPii());
        }

        if (brokerWithdrawRequest.getSignature() != null) {
            localVarFormParams.put("signature", brokerWithdrawRequest.getSignature());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call brokerWithdrawValidateBeforeCall(
            BrokerWithdrawRequest brokerWithdrawRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {brokerWithdrawRequest};
            Method method =
                    this.getClass().getMethod("brokerWithdraw", BrokerWithdrawRequest.class);
            Set<ConstraintViolation<TravelRuleApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return brokerWithdrawCall(brokerWithdrawRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Broker Withdraw (for brokers of local entities that require travel rule) (USER_DATA) Submit a
     * withdrawal request for brokers of local entities that required travel rule. * If
     * &#x60;network&#x60; not send, return with default network of the coin, but if the address
     * could not match default network, the withdraw will be rejected. * You can get
     * &#x60;network&#x60; in &#x60;networkList&#x60; of a coin in the response * Questionnaire is
     * different for each local entity, please refer to * If getting error like &#x60;Questionnaire
     * format not valid.&#x60; or &#x60;Questionnaire must not be blank&#x60;, Weight: 600
     *
     * @param brokerWithdrawRequest (required)
     * @return ApiResponse&lt;BrokerWithdrawResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Broker Withdraw </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a href="https://developers.binance.com/docs/wallet/travel-rule/Broker-Withdraw">Broker
     *     Withdraw (for brokers of local entities that require travel rule) (USER_DATA)
     *     Documentation</a>
     */
    public ApiResponse<BrokerWithdrawResponse> brokerWithdraw(
            @Valid @NotNull BrokerWithdrawRequest brokerWithdrawRequest) throws ApiException {
        okhttp3.Call localVarCall = brokerWithdrawValidateBeforeCall(brokerWithdrawRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<BrokerWithdrawResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for depositHistoryTravelRule
     *
     * @param trId Comma(,) separated list of travel rule record Ids. (optional)
     * @param txId (optional)
     * @param tranId Comma(,) separated list of wallet tran Ids. (optional)
     * @param network (optional)
     * @param coin (optional)
     * @param travelRuleStatus 0:Completed,1:Pending,2:Failed (optional)
     * @param pendingQuestionnaire true: Only return records that pending deposit questionnaire.
     *     false/not provided: return all records. (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param offset Default: 0 (optional)
     * @param limit min 7, max 30, default 7 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Deposit History </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a href="https://developers.binance.com/docs/wallet/travel-rule/Deposit-History">Deposit
     *     History (for local entities that required travel rule) (supporting network) (USER_DATA)
     *     Documentation</a>
     */
    private okhttp3.Call depositHistoryTravelRuleCall(
            String trId,
            String txId,
            String tranId,
            String network,
            String coin,
            Long travelRuleStatus,
            Boolean pendingQuestionnaire,
            Long startTime,
            Long endTime,
            Long offset,
            Long limit)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/localentity/deposit/history";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("trId", trId));
        }

        if (txId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("txId", txId));
        }

        if (tranId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tranId", tranId));
        }

        if (network != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("network", network));
        }

        if (coin != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("coin", coin));
        }

        if (travelRuleStatus != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("travelRuleStatus", travelRuleStatus));
        }

        if (pendingQuestionnaire != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair(
                            "pendingQuestionnaire", pendingQuestionnaire));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call depositHistoryTravelRuleValidateBeforeCall(
            String trId,
            String txId,
            String tranId,
            String network,
            String coin,
            Long travelRuleStatus,
            Boolean pendingQuestionnaire,
            Long startTime,
            Long endTime,
            Long offset,
            Long limit)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {
                trId,
                txId,
                tranId,
                network,
                coin,
                travelRuleStatus,
                pendingQuestionnaire,
                startTime,
                endTime,
                offset,
                limit
            };
            Method method =
                    this.getClass()
                            .getMethod(
                                    "depositHistoryTravelRule",
                                    String.class,
                                    String.class,
                                    String.class,
                                    String.class,
                                    String.class,
                                    Long.class,
                                    Boolean.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<TravelRuleApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return depositHistoryTravelRuleCall(
                        trId,
                        txId,
                        tranId,
                        network,
                        coin,
                        travelRuleStatus,
                        pendingQuestionnaire,
                        startTime,
                        endTime,
                        offset,
                        limit);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Deposit History (for local entities that required travel rule) (supporting network)
     * (USER_DATA) Fetch deposit history for local entities that required travel rule. * Please
     * notice the default &#x60;startTime&#x60; and &#x60;endTime&#x60; to make sure that time
     * interval is within * If both &#x60;&#x60;startTime&#x60;&#x60; and
     * &#x60;&#x60;endTime&#x60;&#x60; are sent, time between &#x60;&#x60;startTime&#x60;&#x60; and
     * &#x60;&#x60;endTime&#x60;&#x60; must Weight: 1
     *
     * @param trId Comma(,) separated list of travel rule record Ids. (optional)
     * @param txId (optional)
     * @param tranId Comma(,) separated list of wallet tran Ids. (optional)
     * @param network (optional)
     * @param coin (optional)
     * @param travelRuleStatus 0:Completed,1:Pending,2:Failed (optional)
     * @param pendingQuestionnaire true: Only return records that pending deposit questionnaire.
     *     false/not provided: return all records. (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param offset Default: 0 (optional)
     * @param limit min 7, max 30, default 7 (optional)
     * @return ApiResponse&lt;DepositHistoryTravelRuleResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Deposit History </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a href="https://developers.binance.com/docs/wallet/travel-rule/Deposit-History">Deposit
     *     History (for local entities that required travel rule) (supporting network) (USER_DATA)
     *     Documentation</a>
     */
    public ApiResponse<DepositHistoryTravelRuleResponse> depositHistoryTravelRule(
            String trId,
            String txId,
            String tranId,
            String network,
            String coin,
            Long travelRuleStatus,
            Boolean pendingQuestionnaire,
            Long startTime,
            Long endTime,
            Long offset,
            Long limit)
            throws ApiException {
        okhttp3.Call localVarCall =
                depositHistoryTravelRuleValidateBeforeCall(
                        trId,
                        txId,
                        tranId,
                        network,
                        coin,
                        travelRuleStatus,
                        pendingQuestionnaire,
                        startTime,
                        endTime,
                        offset,
                        limit);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<DepositHistoryTravelRuleResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for fetchAddressVerificationList
     *
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetch address verification list </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/wallet/travel-rule/address-verification-list">Fetch
     *     address verification list (USER_DATA) Documentation</a>
     */
    private okhttp3.Call fetchAddressVerificationListCall() throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/addressVerify/list";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call fetchAddressVerificationListValidateBeforeCall() throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {};
            Method method = this.getClass().getMethod("fetchAddressVerificationList");
            Set<ConstraintViolation<TravelRuleApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return fetchAddressVerificationListCall();
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Fetch address verification list (USER_DATA) Fetch address verification list Weight: 10
     *
     * @return ApiResponse&lt;FetchAddressVerificationListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetch address verification list </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/wallet/travel-rule/address-verification-list">Fetch
     *     address verification list (USER_DATA) Documentation</a>
     */
    public ApiResponse<FetchAddressVerificationListResponse> fetchAddressVerificationList()
            throws ApiException {
        okhttp3.Call localVarCall = fetchAddressVerificationListValidateBeforeCall();
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<FetchAddressVerificationListResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for onboardedVaspList
     *
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Onboarded VASP list </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/wallet/travel-rule/Onboarded-VASP-list">Onboarded
     *     VASP list (for local entities that require travel rule) (supporting network) (USER_DATA)
     *     Documentation</a>
     */
    private okhttp3.Call onboardedVaspListCall() throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/localentity/vasp";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call onboardedVaspListValidateBeforeCall() throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {};
            Method method = this.getClass().getMethod("onboardedVaspList");
            Set<ConstraintViolation<TravelRuleApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return onboardedVaspListCall();
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Onboarded VASP list (for local entities that require travel rule) (supporting network)
     * (USER_DATA) Fetch the onboarded VASP list for local entities that required travel rule. *
     * This endpoint specifically uses per second IP rate limit, user&#39;s total second level IP
     * rate Weight: 18000 Request limit: 10 requests per second &gt; * This endpoint specifically
     * uses per second IP rate limit, user&#39;s total second level IP rate limit is 180000/second.
     * Response from the endpoint contains header key X-SAPI-USED-IP-WEIGHT-1S, which defines weight
     * used by the current IP.
     *
     * @return ApiResponse&lt;OnboardedVaspListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Onboarded VASP list </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/wallet/travel-rule/Onboarded-VASP-list">Onboarded
     *     VASP list (for local entities that require travel rule) (supporting network) (USER_DATA)
     *     Documentation</a>
     */
    public ApiResponse<OnboardedVaspListResponse> onboardedVaspList() throws ApiException {
        okhttp3.Call localVarCall = onboardedVaspListValidateBeforeCall();
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<OnboardedVaspListResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for submitDepositQuestionnaire
     *
     * @param submitDepositQuestionnaireRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Submit Deposit Questionnaire </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/wallet/travel-rule/deposit-provide-info">Submit
     *     Deposit Questionnaire (For local entities that require travel rule) (supporting network)
     *     (USER_DATA) Documentation</a>
     */
    private okhttp3.Call submitDepositQuestionnaireCall(
            SubmitDepositQuestionnaireRequest submitDepositQuestionnaireRequest)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/localentity/broker/deposit/provide-info";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (submitDepositQuestionnaireRequest.getSubAccountId() != null) {
            localVarFormParams.put(
                    "subAccountId", submitDepositQuestionnaireRequest.getSubAccountId());
        }

        if (submitDepositQuestionnaireRequest.getDepositId() != null) {
            localVarFormParams.put("depositId", submitDepositQuestionnaireRequest.getDepositId());
        }

        if (submitDepositQuestionnaireRequest.getQuestionnaire() != null) {
            localVarFormParams.put(
                    "questionnaire", submitDepositQuestionnaireRequest.getQuestionnaire());
        }

        if (submitDepositQuestionnaireRequest.getBeneficiaryPii() != null) {
            localVarFormParams.put(
                    "beneficiaryPii", submitDepositQuestionnaireRequest.getBeneficiaryPii());
        }

        if (submitDepositQuestionnaireRequest.getNetwork() != null) {
            localVarFormParams.put("network", submitDepositQuestionnaireRequest.getNetwork());
        }

        if (submitDepositQuestionnaireRequest.getCoin() != null) {
            localVarFormParams.put("coin", submitDepositQuestionnaireRequest.getCoin());
        }

        if (submitDepositQuestionnaireRequest.getAmount() != null) {
            localVarFormParams.put(
                    "amount",
                    DecimalFormatter.getFormatter()
                            .format(submitDepositQuestionnaireRequest.getAmount()));
        }

        if (submitDepositQuestionnaireRequest.getAddress() != null) {
            localVarFormParams.put("address", submitDepositQuestionnaireRequest.getAddress());
        }

        if (submitDepositQuestionnaireRequest.getAddressTag() != null) {
            localVarFormParams.put("addressTag", submitDepositQuestionnaireRequest.getAddressTag());
        }

        if (submitDepositQuestionnaireRequest.getSignature() != null) {
            localVarFormParams.put("signature", submitDepositQuestionnaireRequest.getSignature());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "PUT",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call submitDepositQuestionnaireValidateBeforeCall(
            SubmitDepositQuestionnaireRequest submitDepositQuestionnaireRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {submitDepositQuestionnaireRequest};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "submitDepositQuestionnaire",
                                    SubmitDepositQuestionnaireRequest.class);
            Set<ConstraintViolation<TravelRuleApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return submitDepositQuestionnaireCall(submitDepositQuestionnaireRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Submit Deposit Questionnaire (For local entities that require travel rule) (supporting
     * network) (USER_DATA) Submit questionnaire for brokers of local entities that require travel
     * rule. The questionnaire is only applies to transactions from un-hosted wallets or VASPs that
     * are not yet onboarded with GTR. * Questionnaire is different for each local entity, please
     * refer * If getting error like &#x60;Questionnaire format not valid.&#x60; or
     * &#x60;Questionnaire must not be blank&#x60;, Weight: 600
     *
     * @param submitDepositQuestionnaireRequest (required)
     * @return ApiResponse&lt;SubmitDepositQuestionnaireResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Submit Deposit Questionnaire </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/wallet/travel-rule/deposit-provide-info">Submit
     *     Deposit Questionnaire (For local entities that require travel rule) (supporting network)
     *     (USER_DATA) Documentation</a>
     */
    public ApiResponse<SubmitDepositQuestionnaireResponse> submitDepositQuestionnaire(
            @Valid @NotNull SubmitDepositQuestionnaireRequest submitDepositQuestionnaireRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                submitDepositQuestionnaireValidateBeforeCall(submitDepositQuestionnaireRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<SubmitDepositQuestionnaireResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for submitDepositQuestionnaireTravelRule
     *
     * @param submitDepositQuestionnaireTravelRuleRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Submit Deposit Questionnaire </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/wallet/travel-rule/deposit-provide-info">Submit
     *     Deposit Questionnaire (For local entities that require travel rule) (supporting network)
     *     (USER_DATA) Documentation</a>
     */
    private okhttp3.Call submitDepositQuestionnaireTravelRuleCall(
            SubmitDepositQuestionnaireTravelRuleRequest submitDepositQuestionnaireTravelRuleRequest)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/localentity/deposit/provide-info";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (submitDepositQuestionnaireTravelRuleRequest.getTranId() != null) {
            localVarFormParams.put(
                    "tranId", submitDepositQuestionnaireTravelRuleRequest.getTranId());
        }

        if (submitDepositQuestionnaireTravelRuleRequest.getQuestionnaire() != null) {
            localVarFormParams.put(
                    "questionnaire",
                    submitDepositQuestionnaireTravelRuleRequest.getQuestionnaire());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "PUT",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call submitDepositQuestionnaireTravelRuleValidateBeforeCall(
            SubmitDepositQuestionnaireTravelRuleRequest submitDepositQuestionnaireTravelRuleRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {submitDepositQuestionnaireTravelRuleRequest};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "submitDepositQuestionnaireTravelRule",
                                    SubmitDepositQuestionnaireTravelRuleRequest.class);
            Set<ConstraintViolation<TravelRuleApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return submitDepositQuestionnaireTravelRuleCall(
                        submitDepositQuestionnaireTravelRuleRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Submit Deposit Questionnaire (For local entities that require travel rule) (supporting
     * network) (USER_DATA) Submit questionnaire for local entities that require travel rule. The
     * questionnaire is only applies to transactions from unhosted wallets or VASPs that are not yet
     * onboarded with GTR. * Questionnaire is different for each local entity, please refer * If
     * getting error like &#x60;Questionnaire format not valid.&#x60; or &#x60;Questionnaire must
     * not be blank&#x60;, Weight: 600
     *
     * @param submitDepositQuestionnaireTravelRuleRequest (required)
     * @return ApiResponse&lt;SubmitDepositQuestionnaireTravelRuleResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Submit Deposit Questionnaire </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/wallet/travel-rule/deposit-provide-info">Submit
     *     Deposit Questionnaire (For local entities that require travel rule) (supporting network)
     *     (USER_DATA) Documentation</a>
     */
    public ApiResponse<SubmitDepositQuestionnaireTravelRuleResponse>
            submitDepositQuestionnaireTravelRule(
                    @Valid @NotNull
                            SubmitDepositQuestionnaireTravelRuleRequest
                                    submitDepositQuestionnaireTravelRuleRequest)
                    throws ApiException {
        okhttp3.Call localVarCall =
                submitDepositQuestionnaireTravelRuleValidateBeforeCall(
                        submitDepositQuestionnaireTravelRuleRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<SubmitDepositQuestionnaireTravelRuleResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for withdrawHistoryV1
     *
     * @param trId Comma(,) separated list of travel rule record Ids. (optional)
     * @param txId (optional)
     * @param withdrawOrderId client side id for withdrawal, if provided in POST
     *     &#x60;/sapi/v1/capital/withdraw/apply&#x60;, can be used here for query. (optional)
     * @param network (optional)
     * @param coin (optional)
     * @param travelRuleStatus 0:Completed,1:Pending,2:Failed (optional)
     * @param offset Default: 0 (optional)
     * @param limit min 7, max 30, default 7 (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Withdraw History </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/wallet/travel-rule/Withdraw-History">Withdraw
     *     History (for local entities that require travel rule) (supporting network) (USER_DATA)
     *     Documentation</a>
     */
    private okhttp3.Call withdrawHistoryV1Call(
            String trId,
            String txId,
            String withdrawOrderId,
            String network,
            String coin,
            Long travelRuleStatus,
            Long offset,
            Long limit,
            Long startTime,
            Long endTime,
            Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/localentity/withdraw/history";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("trId", trId));
        }

        if (txId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("txId", txId));
        }

        if (withdrawOrderId != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("withdrawOrderId", withdrawOrderId));
        }

        if (network != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("network", network));
        }

        if (coin != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("coin", coin));
        }

        if (travelRuleStatus != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("travelRuleStatus", travelRuleStatus));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call withdrawHistoryV1ValidateBeforeCall(
            String trId,
            String txId,
            String withdrawOrderId,
            String network,
            String coin,
            Long travelRuleStatus,
            Long offset,
            Long limit,
            Long startTime,
            Long endTime,
            Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {
                trId,
                txId,
                withdrawOrderId,
                network,
                coin,
                travelRuleStatus,
                offset,
                limit,
                startTime,
                endTime,
                recvWindow
            };
            Method method =
                    this.getClass()
                            .getMethod(
                                    "withdrawHistoryV1",
                                    String.class,
                                    String.class,
                                    String.class,
                                    String.class,
                                    String.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<TravelRuleApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return withdrawHistoryV1Call(
                        trId,
                        txId,
                        withdrawOrderId,
                        network,
                        coin,
                        travelRuleStatus,
                        offset,
                        limit,
                        startTime,
                        endTime,
                        recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Withdraw History (for local entities that require travel rule) (supporting network)
     * (USER_DATA) Fetch withdraw history for local entities that required travel rule. * This
     * endpoint specifically uses per second IP rate limit, user&#39;s total second level IP rate *
     * &#x60;network&#x60; may not be in the response for old withdraw. * Please notice the default
     * &#x60;startTime&#x60; and &#x60;endTime&#x60; to make sure that time interval is within * If
     * both &#x60;startTime&#x60; and &#x60;endTime&#x60;are sent, time between
     * &#x60;startTime&#x60;and &#x60;endTime&#x60;must be less Weight: 18000 Request limit: 10
     * requests per second &gt; * This endpoint specifically uses per second IP rate limit,
     * user&#39;s total second level IP rate limit is 180000/second. Response from the endpoint
     * contains header key X-SAPI-USED-IP-WEIGHT-1S, which defines weight used by the current IP.
     *
     * @param trId Comma(,) separated list of travel rule record Ids. (optional)
     * @param txId (optional)
     * @param withdrawOrderId client side id for withdrawal, if provided in POST
     *     &#x60;/sapi/v1/capital/withdraw/apply&#x60;, can be used here for query. (optional)
     * @param network (optional)
     * @param coin (optional)
     * @param travelRuleStatus 0:Completed,1:Pending,2:Failed (optional)
     * @param offset Default: 0 (optional)
     * @param limit min 7, max 30, default 7 (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;WithdrawHistoryV1Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Withdraw History </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/wallet/travel-rule/Withdraw-History">Withdraw
     *     History (for local entities that require travel rule) (supporting network) (USER_DATA)
     *     Documentation</a>
     */
    public ApiResponse<WithdrawHistoryV1Response> withdrawHistoryV1(
            String trId,
            String txId,
            String withdrawOrderId,
            String network,
            String coin,
            Long travelRuleStatus,
            Long offset,
            Long limit,
            Long startTime,
            Long endTime,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                withdrawHistoryV1ValidateBeforeCall(
                        trId,
                        txId,
                        withdrawOrderId,
                        network,
                        coin,
                        travelRuleStatus,
                        offset,
                        limit,
                        startTime,
                        endTime,
                        recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<WithdrawHistoryV1Response>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for withdrawHistoryV2
     *
     * @param trId Comma(,) separated list of travel rule record Ids. (optional)
     * @param txId (optional)
     * @param withdrawOrderId client side id for withdrawal, if provided in POST
     *     &#x60;/sapi/v1/capital/withdraw/apply&#x60;, can be used here for query. (optional)
     * @param network (optional)
     * @param coin (optional)
     * @param travelRuleStatus 0:Completed,1:Pending,2:Failed (optional)
     * @param offset Default: 0 (optional)
     * @param limit min 7, max 30, default 7 (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param recvWindow (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Withdraw History V2 </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/wallet/travel-rule/Withdraw-History-V2">Withdraw
     *     History V2 (for local entities that require travel rule) (supporting network) (USER_DATA)
     *     Documentation</a>
     */
    private okhttp3.Call withdrawHistoryV2Call(
            String trId,
            String txId,
            String withdrawOrderId,
            String network,
            String coin,
            Long travelRuleStatus,
            Long offset,
            Long limit,
            Long startTime,
            Long endTime,
            Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v2/localentity/withdraw/history";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (trId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("trId", trId));
        }

        if (txId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("txId", txId));
        }

        if (withdrawOrderId != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("withdrawOrderId", withdrawOrderId));
        }

        if (network != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("network", network));
        }

        if (coin != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("coin", coin));
        }

        if (travelRuleStatus != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("travelRuleStatus", travelRuleStatus));
        }

        if (offset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("offset", offset));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call withdrawHistoryV2ValidateBeforeCall(
            String trId,
            String txId,
            String withdrawOrderId,
            String network,
            String coin,
            Long travelRuleStatus,
            Long offset,
            Long limit,
            Long startTime,
            Long endTime,
            Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {
                trId,
                txId,
                withdrawOrderId,
                network,
                coin,
                travelRuleStatus,
                offset,
                limit,
                startTime,
                endTime,
                recvWindow
            };
            Method method =
                    this.getClass()
                            .getMethod(
                                    "withdrawHistoryV2",
                                    String.class,
                                    String.class,
                                    String.class,
                                    String.class,
                                    String.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<TravelRuleApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return withdrawHistoryV2Call(
                        trId,
                        txId,
                        withdrawOrderId,
                        network,
                        coin,
                        travelRuleStatus,
                        offset,
                        limit,
                        startTime,
                        endTime,
                        recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Withdraw History V2 (for local entities that require travel rule) (supporting network)
     * (USER_DATA) Fetch withdraw history for local entities that required travel rule. * This
     * endpoint specifically uses per second IP rate limit, user&#39;s total second level IP rate *
     * &#x60;network&#x60; may not be in the response for old withdraw. * Withdrawal made through
     * /sapi/v1/capital/withdraw/apply may not be in the response. * Please notice the default
     * &#x60;startTime&#x60; and &#x60;endTime&#x60; to make sure that time interval is within * If
     * both &#x60;startTime&#x60; and &#x60;endTime&#x60;are sent, time between
     * &#x60;startTime&#x60;and &#x60;endTime&#x60;must be less * If withdrawOrderId is sent, time
     * between startTime and endTime must be less than 7 days. * If withdrawOrderId is sent,
     * startTime and endTime are not sent, will return last 7 days records by default. * Maximum
     * support trId,txId number is 45. * WithdrawOrderId only support 1. * If responsible does not
     * include withdrawalStatus, please input trId or txId retrieve the data. Weight: 18000 Request
     * limit: 10 requests per second &gt; * This endpoint specifically uses per second IP rate
     * limit, user&#39;s total second level IP rate limit is 180000/second. Response from the
     * endpoint contains header key X-SAPI-USED-IP-WEIGHT-1S, which defines weight used by the
     * current IP.
     *
     * @param trId Comma(,) separated list of travel rule record Ids. (optional)
     * @param txId (optional)
     * @param withdrawOrderId client side id for withdrawal, if provided in POST
     *     &#x60;/sapi/v1/capital/withdraw/apply&#x60;, can be used here for query. (optional)
     * @param network (optional)
     * @param coin (optional)
     * @param travelRuleStatus 0:Completed,1:Pending,2:Failed (optional)
     * @param offset Default: 0 (optional)
     * @param limit min 7, max 30, default 7 (optional)
     * @param startTime (optional)
     * @param endTime (optional)
     * @param recvWindow (optional)
     * @return ApiResponse&lt;WithdrawHistoryV2Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Withdraw History V2 </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/wallet/travel-rule/Withdraw-History-V2">Withdraw
     *     History V2 (for local entities that require travel rule) (supporting network) (USER_DATA)
     *     Documentation</a>
     */
    public ApiResponse<WithdrawHistoryV2Response> withdrawHistoryV2(
            String trId,
            String txId,
            String withdrawOrderId,
            String network,
            String coin,
            Long travelRuleStatus,
            Long offset,
            Long limit,
            Long startTime,
            Long endTime,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                withdrawHistoryV2ValidateBeforeCall(
                        trId,
                        txId,
                        withdrawOrderId,
                        network,
                        coin,
                        travelRuleStatus,
                        offset,
                        limit,
                        startTime,
                        endTime,
                        recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<WithdrawHistoryV2Response>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for withdrawTravelRule
     *
     * @param withdrawTravelRuleRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Withdraw </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a href="https://developers.binance.com/docs/wallet/travel-rule/Withdraw">Withdraw (for
     *     local entities that require travel rule) (USER_DATA) Documentation</a>
     */
    private okhttp3.Call withdrawTravelRuleCall(WithdrawTravelRuleRequest withdrawTravelRuleRequest)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/localentity/withdraw/apply";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (withdrawTravelRuleRequest.getCoin() != null) {
            localVarFormParams.put("coin", withdrawTravelRuleRequest.getCoin());
        }

        if (withdrawTravelRuleRequest.getWithdrawOrderId() != null) {
            localVarFormParams.put(
                    "withdrawOrderId", withdrawTravelRuleRequest.getWithdrawOrderId());
        }

        if (withdrawTravelRuleRequest.getNetwork() != null) {
            localVarFormParams.put("network", withdrawTravelRuleRequest.getNetwork());
        }

        if (withdrawTravelRuleRequest.getAddress() != null) {
            localVarFormParams.put("address", withdrawTravelRuleRequest.getAddress());
        }

        if (withdrawTravelRuleRequest.getAddressTag() != null) {
            localVarFormParams.put("addressTag", withdrawTravelRuleRequest.getAddressTag());
        }

        if (withdrawTravelRuleRequest.getAmount() != null) {
            localVarFormParams.put(
                    "amount",
                    DecimalFormatter.getFormatter().format(withdrawTravelRuleRequest.getAmount()));
        }

        if (withdrawTravelRuleRequest.getTransactionFeeFlag() != null) {
            localVarFormParams.put(
                    "transactionFeeFlag", withdrawTravelRuleRequest.getTransactionFeeFlag());
        }

        if (withdrawTravelRuleRequest.getName() != null) {
            localVarFormParams.put("name", withdrawTravelRuleRequest.getName());
        }

        if (withdrawTravelRuleRequest.getWalletType() != null) {
            localVarFormParams.put("walletType", withdrawTravelRuleRequest.getWalletType());
        }

        if (withdrawTravelRuleRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", withdrawTravelRuleRequest.getRecvWindow());
        }

        if (withdrawTravelRuleRequest.getQuestionnaire() != null) {
            localVarFormParams.put("questionnaire", withdrawTravelRuleRequest.getQuestionnaire());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call withdrawTravelRuleValidateBeforeCall(
            WithdrawTravelRuleRequest withdrawTravelRuleRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {withdrawTravelRuleRequest};
            Method method =
                    this.getClass()
                            .getMethod("withdrawTravelRule", WithdrawTravelRuleRequest.class);
            Set<ConstraintViolation<TravelRuleApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return withdrawTravelRuleCall(withdrawTravelRuleRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Withdraw (for local entities that require travel rule) (USER_DATA) Submit a withdrawal
     * request for local entities that required travel rule. * If &#x60;network&#x60; not send,
     * return with default network of the coin, but if the address could not match default network,
     * the withdraw will be rejected. * You can get &#x60;network&#x60; and &#x60;isDefault&#x60; in
     * &#x60;networkList&#x60; of a coin in the response * Questionnaire is different for each local
     * entity, please refer to * If getting error like &#x60;Questionnaire format not valid.&#x60;
     * or &#x60;Questionnaire must not be blank&#x60;, Weight: 600
     *
     * @param withdrawTravelRuleRequest (required)
     * @return ApiResponse&lt;WithdrawTravelRuleResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Withdraw </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a href="https://developers.binance.com/docs/wallet/travel-rule/Withdraw">Withdraw (for
     *     local entities that require travel rule) (USER_DATA) Documentation</a>
     */
    public ApiResponse<WithdrawTravelRuleResponse> withdrawTravelRule(
            @Valid @NotNull WithdrawTravelRuleRequest withdrawTravelRuleRequest)
            throws ApiException {
        okhttp3.Call localVarCall = withdrawTravelRuleValidateBeforeCall(withdrawTravelRuleRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<WithdrawTravelRuleResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }
}
