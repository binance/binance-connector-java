/*
 * Binance Gift Card REST API
 * OpenAPI Specification for the Binance Gift Card REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.gift_card.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.gift_card.rest.model.CreateADualTokenGiftCardRequest;
import com.binance.connector.client.gift_card.rest.model.CreateADualTokenGiftCardResponse;
import com.binance.connector.client.gift_card.rest.model.CreateASingleTokenGiftCardRequest;
import com.binance.connector.client.gift_card.rest.model.CreateASingleTokenGiftCardResponse;
import com.binance.connector.client.gift_card.rest.model.FetchRsaPublicKeyResponse;
import com.binance.connector.client.gift_card.rest.model.FetchTokenLimitResponse;
import com.binance.connector.client.gift_card.rest.model.RedeemABinanceGiftCardRequest;
import com.binance.connector.client.gift_card.rest.model.RedeemABinanceGiftCardResponse;
import com.binance.connector.client.gift_card.rest.model.VerifyBinanceGiftCardByGiftCardNumberResponse;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for MarketDataApi */
public class MarketDataApiTest {

    private MarketDataApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new MarketDataApi(apiClientSpy);
    }

    /**
     * Create a dual-token gift card(fixed value, discount feature)(TRADE)
     *
     * <p>* This API is for creating a dual-token ( stablecoin-denominated) Binance Gift Card. You
     * may create a gift card using USDT as baseToken, that is redeemable to another designated
     * token (faceToken). For example, you can create a fixed-value BTC gift card and pay with 100
     * USDT plus 1 USDT fee. This gift card can keep the value fixed at 100 USDT before redemption,
     * and will be redeemable to BTC equivalent to 100 USDT upon redemption. * Once successfully
     * created, the amount of baseToken (e.g. USDT) in the fixed-value gift card along with the fee
     * would be deducted from your funding wallet. * To get started with, please make sure: * You
     * have a Binance account * You have passed KYB * You have a sufﬁcient balance(Gift Card amount
     * and fee amount) in your Binance funding wallet * You need Enable Withdrawals for the API Key
     * which requests this endpoint. Weight: 1 * Monthly creation volume: 4,200,000 USDC / month /
     * account * Monthly creation quantity: 6,000 Gift Cards / month / account
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createADualTokenGiftCardTest() throws ApiException, CryptoException {
        CreateADualTokenGiftCardRequest createADualTokenGiftCardRequest =
                new CreateADualTokenGiftCardRequest();

        createADualTokenGiftCardRequest.baseToken("");
        createADualTokenGiftCardRequest.faceToken("");
        createADualTokenGiftCardRequest.baseTokenAmount(1d);

        ApiResponse<CreateADualTokenGiftCardResponse> response =
                api.createADualTokenGiftCard(createADualTokenGiftCardRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000faceToken=&baseToken=&baseTokenAmount=1",
                signInputCaptor.getValue());
        assertEquals(
                "bbe48ab31c99a9424cf70566cd9e185b82788212d8b92ac66e921f0f6cdece26",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/giftcard/buyCode", actualRequest.url().encodedPath());
    }

    /**
     * Create a single-token gift card (USER_DATA)
     *
     * <p>This API is for creating a Binance Gift Card. To get started with, please make sure: * You
     * have a Binance account * You have passed KYB * You have a sufﬁcient balance(Gift Card amount
     * and fee amount) in your Binance funding wallet * You need &#x60;Enable Withdrawals&#x60; for
     * the API Key which requests this endpoint. Weight: 1 * Monthly creation volume: 4,200,000 USDC
     * / month / account * Monthly creation quantity: 6,000 Gift Cards / month / account
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createASingleTokenGiftCardTest() throws ApiException, CryptoException {
        CreateASingleTokenGiftCardRequest createASingleTokenGiftCardRequest =
                new CreateASingleTokenGiftCardRequest();

        createASingleTokenGiftCardRequest.token("");
        createASingleTokenGiftCardRequest.amount(1d);

        ApiResponse<CreateASingleTokenGiftCardResponse> response =
                api.createASingleTokenGiftCard(createASingleTokenGiftCardRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000amount=1&token=", signInputCaptor.getValue());
        assertEquals(
                "91dfe9e37be6d04c246a02fcc01ed644ea5257803912f5cef6f46a021a1b8248",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/giftcard/createCode", actualRequest.url().encodedPath());
    }

    /**
     * Fetch RSA Public Key(USER_DATA)
     *
     * <p>This API is for fetching the RSA Public Key. This RSA Public key will be used to encrypt
     * the card code. **Please note that the RSA Public key fetched is valid only for the current
     * day.** Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void fetchRsaPublicKeyTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<FetchRsaPublicKeyResponse> response = api.fetchRsaPublicKey(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/giftcard/cryptography/rsa-public-key", actualRequest.url().encodedPath());
    }

    /**
     * Fetch Token Limit(USER_DATA)
     *
     * <p>This API is to help you verify which tokens are available for you to create
     * Stablecoin-Denominated gift cards as mentioned in section 2 and its’ limitation. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void fetchTokenLimitTest() throws ApiException, CryptoException {
        String baseToken = "";
        Long recvWindow = 5000L;
        ApiResponse<FetchTokenLimitResponse> response = api.fetchTokenLimit(baseToken, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "baseToken=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "ad48ec2424bc86ad21d7fc07d5661584031423f7843df207b496c96683f24adf",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/giftcard/buyCode/token-limit", actualRequest.url().encodedPath());
    }

    /**
     * Redeem a Binance Gift Card(USER_DATA)
     *
     * <p>This API is for redeeming a Binance Gift Card Once redeemed, the coins will be deposited
     * in your funding wallet. * Parameter code can be sent in two formats: * Plaintext * Encrypted
     * * Sending code in Encrypted format provides more security than sending it as a plaintext. To
     * send card code in encrypted format the following steps must be followed: * Fetch RSA public
     * key from api stated below. * Use the below algorithm to encrypt the card code using the RSA
     * public key fetched above: &#x60;RSA/ECB/OAEPWithSHA-256AndMGF1Padding&#x60; **A sample code
     * snippet (JAVA) is stated below for reference, the same approach can be used for different
     * languages like C#, PERL, PYTHON, SHELL etc.:** Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void redeemABinanceGiftCardTest() throws ApiException, CryptoException {
        RedeemABinanceGiftCardRequest redeemABinanceGiftCardRequest =
                new RedeemABinanceGiftCardRequest();

        redeemABinanceGiftCardRequest.code("");

        ApiResponse<RedeemABinanceGiftCardResponse> response =
                api.redeemABinanceGiftCard(redeemABinanceGiftCardRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000code=", signInputCaptor.getValue());
        assertEquals(
                "1bbed7491819e9e91dca721f71b689fd5802f67881ed39df565eef91d31a6ea1",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/giftcard/redeemCode", actualRequest.url().encodedPath());
    }

    /**
     * Verify Binance Gift Card by Gift Card Number(USER_DATA)
     *
     * <p>This API is for verifying whether the Binance Gift Card is valid or not by entering Gift
     * Card Number. **Please note that if you enter the wrong Gift Card Number 5 times within an
     * hour, you will no longer be able to verify any Gift Card Number for that hour.** Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void verifyBinanceGiftCardByGiftCardNumberTest() throws ApiException, CryptoException {
        String referenceNo = "";
        Long recvWindow = 5000L;
        ApiResponse<VerifyBinanceGiftCardByGiftCardNumberResponse> response =
                api.verifyBinanceGiftCardByGiftCardNumber(referenceNo, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "referenceNo=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "bf4fdc473e45ef2efce7f171ab61a231969e9924b1a839b72500868675378a6f",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/giftcard/verify", actualRequest.url().encodedPath());
    }
}
