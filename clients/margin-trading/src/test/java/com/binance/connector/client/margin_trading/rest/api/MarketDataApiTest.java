/*
 * Binance Margin Trading REST API
 * OpenAPI Specification for the Binance Margin Trading REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.margin_trading.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.margin_trading.rest.model.CrossMarginCollateralRatioResponse;
import com.binance.connector.client.margin_trading.rest.model.GetAllCrossMarginPairsResponse;
import com.binance.connector.client.margin_trading.rest.model.GetAllIsolatedMarginSymbolResponse;
import com.binance.connector.client.margin_trading.rest.model.GetAllMarginAssetsResponse;
import com.binance.connector.client.margin_trading.rest.model.GetDelistScheduleResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryIsolatedMarginTierDataResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryLiabilityCoinLeverageBracketInCrossMarginProModeResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryMarginAvailableInventoryResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryMarginPriceindexResponse;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for MarketDataApi */
public class MarketDataApiTest {

    private MarketDataApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new MarketDataApi(apiClientSpy);
    }

    /**
     * Cross margin collateral ratio (MARKET_DATA)
     *
     * <p>Cross margin collateral ratio Weight: 100(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void crossMarginCollateralRatioTest() throws ApiException, CryptoException {
        ApiResponse<CrossMarginCollateralRatioResponse> response = api.crossMarginCollateralRatio();

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/margin/crossMarginCollateralRatio", actualRequest.url().encodedPath());
    }

    /**
     * Get All Cross Margin Pairs (MARKET_DATA)
     *
     * <p>Get All Cross Margin Pairs Weight: 1(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAllCrossMarginPairsTest() throws ApiException, CryptoException {
        String symbol = "";
        ApiResponse<GetAllCrossMarginPairsResponse> response = api.getAllCrossMarginPairs(symbol);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/allPairs", actualRequest.url().encodedPath());
    }

    /**
     * Get All Isolated Margin Symbol(MARKET_DATA)
     *
     * <p>Get All Isolated Margin Symbol Weight: 10(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAllIsolatedMarginSymbolTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<GetAllIsolatedMarginSymbolResponse> response =
                api.getAllIsolatedMarginSymbol(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/isolated/allPairs", actualRequest.url().encodedPath());
    }

    /**
     * Get All Margin Assets (MARKET_DATA)
     *
     * <p>Get All Margin Assets. Weight: 1(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAllMarginAssetsTest() throws ApiException, CryptoException {
        String asset = "";
        ApiResponse<GetAllMarginAssetsResponse> response = api.getAllMarginAssets(asset);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/allAssets", actualRequest.url().encodedPath());
    }

    /**
     * Get Delist Schedule (MARKET_DATA)
     *
     * <p>Get tokens or symbols delist schedule for cross margin and isolated margin Weight: 100
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getDelistScheduleTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<GetDelistScheduleResponse> response = api.getDelistSchedule(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/delist-schedule", actualRequest.url().encodedPath());
    }

    /**
     * Query Isolated Margin Tier Data (USER_DATA)
     *
     * <p>Get isolated margin tier data collection with any tier as
     * https://www.binance.com/en/margin-data Weight: 1(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryIsolatedMarginTierDataTest() throws ApiException, CryptoException {
        String symbol = "";
        Long tier = 0L;
        Long recvWindow = 5000L;
        ApiResponse<QueryIsolatedMarginTierDataResponse> response =
                api.queryIsolatedMarginTierData(symbol, tier, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&tier=0&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "d598c86102a833b330fd5e0b272ae3ec3e38965235029950fe63b98d3f21118c",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/isolatedMarginTier", actualRequest.url().encodedPath());
    }

    /**
     * Query Liability Coin Leverage Bracket in Cross Margin Pro Mode(MARKET_DATA)
     *
     * <p>Liability Coin Leverage Bracket in Cross Margin Pro Mode Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryLiabilityCoinLeverageBracketInCrossMarginProModeTest()
            throws ApiException, CryptoException {
        ApiResponse<QueryLiabilityCoinLeverageBracketInCrossMarginProModeResponse> response =
                api.queryLiabilityCoinLeverageBracketInCrossMarginProMode();

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/leverageBracket", actualRequest.url().encodedPath());
    }

    /**
     * Query Margin Available Inventory(USER_DATA)
     *
     * <p>Margin available Inventory query Weight: 50
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryMarginAvailableInventoryTest() throws ApiException, CryptoException {
        String type = "";
        ApiResponse<QueryMarginAvailableInventoryResponse> response =
                api.queryMarginAvailableInventory(type);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("type=&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "a0a00da616718f873c1bc76aa304e6124894ea2b3df857101576732dca4e8f53",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/available-inventory", actualRequest.url().encodedPath());
    }

    /**
     * Query Margin PriceIndex (MARKET_DATA)
     *
     * <p>Query Margin PriceIndex Weight: 10(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryMarginPriceindexTest() throws ApiException, CryptoException {
        String symbol = "";
        ApiResponse<QueryMarginPriceindexResponse> response = api.queryMarginPriceindex(symbol);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(null, actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/priceIndex", actualRequest.url().encodedPath());
    }
}
