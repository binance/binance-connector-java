/*
 * Binance Margin Trading REST API
 * OpenAPI Specification for the Binance Margin Trading REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.margin_trading.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.margin_trading.rest.model.GetFutureHourlyInterestRateResponse;
import com.binance.connector.client.margin_trading.rest.model.GetInterestHistoryResponse;
import com.binance.connector.client.margin_trading.rest.model.MarginAccountBorrowRepayRequest;
import com.binance.connector.client.margin_trading.rest.model.MarginAccountBorrowRepayResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryBorrowRepayRecordsInMarginAccountResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryMarginInterestRateHistoryResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryMaxBorrowResponse;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for BorrowRepayApi */
public class BorrowRepayApiTest {

    private BorrowRepayApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new BorrowRepayApi(apiClientSpy);
    }

    /**
     * Get future hourly interest rate (USER_DATA)
     *
     * <p>Get future hourly interest rate Weight: 100
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFutureHourlyInterestRateTest() throws ApiException, CryptoException {
        String assets = "";
        String isIsolated = "false";
        ApiResponse<GetFutureHourlyInterestRateResponse> response =
                api.getFutureHourlyInterestRate(assets, isIsolated);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "assets=&isIsolated=false&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2387652ad7bac3e1193d741e641740cf64adb884868d4a1e300d99a49a15ea31",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/margin/next-hourly-interest-rate", actualRequest.url().encodedPath());
    }

    /**
     * Get Interest History (USER_DATA)
     *
     * <p>Get Interest History * Response in descending order * If isolatedSymbol is not sent,
     * crossed margin data will be returned * The max interval between &#x60;startTime&#x60; and
     * &#x60;endTime&#x60; is 30 days. It is a MUST to ensure data correctness. * If
     * &#x60;startTime&#x60;and &#x60;endTime&#x60; not sent, return records of the last 7 days by
     * default. * If &#x60;startTime&#x60; is sent and &#x60;endTime&#x60; is not sent, return
     * records of [max(&#x60;startTime&#x60;, now-30d), now]. * If &#x60;startTime&#x60; is not sent
     * and &#x60;endTime&#x60; is sent, return records of [&#x60;endTime&#x60;-7,
     * &#x60;endTime&#x60;] * &#x60;type&#x60; in response has 4 enums: * &#x60;PERIODIC&#x60;
     * interest charged per hour * &#x60;ON_BORROW&#x60; first interest charged on borrow *
     * &#x60;PERIODIC_CONVERTED&#x60; interest charged per hour converted into BNB *
     * &#x60;ON_BORROW_CONVERTED&#x60; first interest charged on borrow converted into BNB *
     * &#x60;PORTFOLIO&#x60; interest charged daily on the portfolio margin negative balance Weight:
     * 1(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getInterestHistoryTest() throws ApiException, CryptoException {
        String asset = "";
        String isolatedSymbol = "";
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long current = 1L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<GetInterestHistoryResponse> response =
                api.getInterestHistory(
                        asset, isolatedSymbol, startTime, endTime, current, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "asset=&isolatedSymbol=&startTime=1623319461670&endTime=1641782889000&current=1&size=10&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "dbde03d1c3fdbcc6436ec6818d4e920ff1602671280b0d98f33673c254b22efd",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/interestHistory", actualRequest.url().encodedPath());
    }

    /**
     * Margin account borrow/repay(MARGIN)
     *
     * <p>Margin account borrow/repay(MARGIN) Weight: 1500
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void marginAccountBorrowRepayTest() throws ApiException, CryptoException {
        MarginAccountBorrowRepayRequest marginAccountBorrowRepayRequest =
                new MarginAccountBorrowRepayRequest();

        marginAccountBorrowRepayRequest.asset("");
        marginAccountBorrowRepayRequest.isIsolated("false");
        marginAccountBorrowRepayRequest.symbol("");
        marginAccountBorrowRepayRequest.amount("");
        marginAccountBorrowRepayRequest.type("");

        ApiResponse<MarginAccountBorrowRepayResponse> response =
                api.marginAccountBorrowRepay(marginAccountBorrowRepayRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=&amount=&isIsolated=false&asset=&type=",
                signInputCaptor.getValue());
        assertEquals(
                "cf39a535a9ce053d58cc411f8ed47fa0998432f15bf01424a936f508b6134ec8",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/borrow-repay", actualRequest.url().encodedPath());
    }

    /**
     * Query borrow/repay records in Margin account(USER_DATA)
     *
     * <p>Query borrow/repay records in Margin account * &#x60;txId&#x60; or &#x60;startTime&#x60;
     * must be sent. &#x60;txId&#x60; takes precedence. * If an asset is sent, data within 30 days
     * before &#x60;endTime&#x60;; If an asset is not sent, data within 7 days before
     * &#x60;endTime&#x60; * If neither &#x60;startTime&#x60; nor &#x60;endTime&#x60; is sent, the
     * recent 7-day data will be returned. * &#x60;startTime&#x60; set as &#x60;endTime&#x60; -
     * 7days by default, &#x60;endTime&#x60; set as current time by default Weight: 10(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryBorrowRepayRecordsInMarginAccountTest() throws ApiException, CryptoException {
        String type = "";
        String asset = "";
        String isolatedSymbol = "";
        Long txId = 1L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long current = 1L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<QueryBorrowRepayRecordsInMarginAccountResponse> response =
                api.queryBorrowRepayRecordsInMarginAccount(
                        type,
                        asset,
                        isolatedSymbol,
                        txId,
                        startTime,
                        endTime,
                        current,
                        size,
                        recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "asset=&isolatedSymbol=&txId=1&startTime=1623319461670&endTime=1641782889000&current=1&size=10&type=&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "412d39a43c198510d843f932bec86af52957fc98447679840459426d9f3547ce",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/borrow-repay", actualRequest.url().encodedPath());
    }

    /**
     * Query Margin Interest Rate History (USER_DATA)
     *
     * <p>Query Margin Interest Rate History Weight: 1(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryMarginInterestRateHistoryTest() throws ApiException, CryptoException {
        String asset = "";
        Long vipLevel = 1L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long recvWindow = 5000L;
        ApiResponse<QueryMarginInterestRateHistoryResponse> response =
                api.queryMarginInterestRateHistory(asset, vipLevel, startTime, endTime, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "asset=&vipLevel=1&startTime=1623319461670&endTime=1641782889000&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "6dd354c5666cefbda9607a5594913706b6681a6f388625f6781b39c2be2a858f",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/interestRateHistory", actualRequest.url().encodedPath());
    }

    /**
     * Query Max Borrow (USER_DATA)
     *
     * <p>Query Max Borrow * If isolatedSymbol is not sent, crossed margin data will be sent. *
     * &#x60;borrowLimit&#x60; is also available from
     * [https://www.binance.com/en/margin-fee](https://www.binance.com/en/margin-fee) Weight: 50(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryMaxBorrowTest() throws ApiException, CryptoException {
        String asset = "";
        String isolatedSymbol = "";
        Long recvWindow = 5000L;
        ApiResponse<QueryMaxBorrowResponse> response =
                api.queryMaxBorrow(asset, isolatedSymbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "asset=&isolatedSymbol=&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "90c4a3668764b733f6c643c57f90568be4756aa70d3d7923c44995f762b25e21",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/maxBorrowable", actualRequest.url().encodedPath());
    }
}
