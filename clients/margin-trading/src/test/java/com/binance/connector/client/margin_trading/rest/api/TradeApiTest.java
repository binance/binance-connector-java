/*
 * Binance Margin Trading REST API
 * OpenAPI Specification for the Binance Margin Trading REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.margin_trading.rest.api;

import static org.junit.Assert.assertEquals;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.auth.BinanceAuthenticationFactory;
import com.binance.connector.client.common.auth.SignatureAuthentication;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.configuration.SignatureConfiguration;
import com.binance.connector.client.common.sign.HmacSignatureGenerator;
import com.binance.connector.client.common.sign.SignatureGenerator;
import com.binance.connector.client.margin_trading.rest.model.AssetNames;
import com.binance.connector.client.margin_trading.rest.model.CreateSpecialKeyRequest;
import com.binance.connector.client.margin_trading.rest.model.CreateSpecialKeyResponse;
import com.binance.connector.client.margin_trading.rest.model.EditIpForSpecialKeyRequest;
import com.binance.connector.client.margin_trading.rest.model.GetForceLiquidationRecordResponse;
import com.binance.connector.client.margin_trading.rest.model.GetSmallLiabilityExchangeCoinListResponse;
import com.binance.connector.client.margin_trading.rest.model.GetSmallLiabilityExchangeHistoryResponse;
import com.binance.connector.client.margin_trading.rest.model.MarginAccountCancelAllOpenOrdersOnASymbolResponse;
import com.binance.connector.client.margin_trading.rest.model.MarginAccountCancelOcoResponse;
import com.binance.connector.client.margin_trading.rest.model.MarginAccountCancelOrderResponse;
import com.binance.connector.client.margin_trading.rest.model.MarginAccountNewOcoRequest;
import com.binance.connector.client.margin_trading.rest.model.MarginAccountNewOcoResponse;
import com.binance.connector.client.margin_trading.rest.model.MarginAccountNewOrderRequest;
import com.binance.connector.client.margin_trading.rest.model.MarginAccountNewOrderResponse;
import com.binance.connector.client.margin_trading.rest.model.MarginAccountNewOtoRequest;
import com.binance.connector.client.margin_trading.rest.model.MarginAccountNewOtoResponse;
import com.binance.connector.client.margin_trading.rest.model.MarginAccountNewOtocoRequest;
import com.binance.connector.client.margin_trading.rest.model.MarginAccountNewOtocoResponse;
import com.binance.connector.client.margin_trading.rest.model.MarginManualLiquidationRequest;
import com.binance.connector.client.margin_trading.rest.model.MarginManualLiquidationResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryCurrentMarginOrderCountUsageResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryMarginAccountsAllOcoResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryMarginAccountsAllOrdersResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryMarginAccountsOcoResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryMarginAccountsOpenOcoResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryMarginAccountsOpenOrdersResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryMarginAccountsOrderResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryMarginAccountsTradeListResponse;
import com.binance.connector.client.margin_trading.rest.model.QuerySpecialKeyListResponse;
import com.binance.connector.client.margin_trading.rest.model.QuerySpecialKeyResponse;
import com.binance.connector.client.margin_trading.rest.model.Side;
import com.binance.connector.client.margin_trading.rest.model.SmallLiabilityExchangeRequest;
import jakarta.validation.constraints.*;
import okhttp3.Call;
import okhttp3.Request;
import org.bouncycastle.crypto.CryptoException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;

/** API tests for TradeApi */
public class TradeApiTest {

    private TradeApi api;
    private ApiClient apiClientSpy;
    private SignatureGenerator signatureGeneratorSpy;

    @BeforeEach
    public void initApiClient() throws ApiException {
        ClientConfiguration clientConfiguration = new ClientConfiguration();
        clientConfiguration.setUrl("http://localhost:8080");
        SignatureConfiguration signatureConfiguration = new SignatureConfiguration();
        signatureConfiguration.setApiKey("apiKey");
        signatureConfiguration.setSecretKey("secretKey");
        clientConfiguration.setSignatureConfiguration(signatureConfiguration);

        HmacSignatureGenerator signatureGenerator =
                new HmacSignatureGenerator(signatureConfiguration.getSecretKey());
        signatureGeneratorSpy = Mockito.spy(signatureGenerator);
        SignatureAuthentication signatureAuthentication =
                new SignatureAuthentication(
                        signatureConfiguration.getApiKey(), signatureGeneratorSpy);
        SignatureAuthentication authenticationSpy = Mockito.spy(signatureAuthentication);
        Mockito.doReturn("1736393892000").when(authenticationSpy).buildTimestamp();

        BinanceAuthenticationFactory factoryMock = Mockito.mock(BinanceAuthenticationFactory.class);
        Mockito.doReturn(authenticationSpy)
                .when(factoryMock)
                .getAuthentication(signatureConfiguration);

        ApiClient apiClient = new ApiClient(clientConfiguration, factoryMock);

        apiClientSpy = Mockito.spy(apiClient);
        Mockito.doReturn(new ApiResponse<>(200, null))
                .when(apiClientSpy)
                .execute(Mockito.any(), Mockito.any(java.lang.reflect.Type.class));
        Mockito.doReturn(new ApiResponse<>(200, null)).when(apiClientSpy).execute(Mockito.any());
        Mockito.doReturn("1736393892000").when(apiClientSpy).buildTimestamp();

        api = new TradeApi(apiClientSpy);
    }

    /**
     * Create Special Key(Low-Latency Trading)(TRADE)
     *
     * <p>**Binance Margin offers low-latency trading through a [special
     * key](https://www.binance.com/en/support/faq/frequently-asked-questions-on-margin-special-api-key-3208663e900d4d2e9fec4140e1832f4e),
     * available exclusively to users with VIP level 4 or higher. ** **If you are VIP level 3 or
     * below, please contact your VIP manager for eligibility criterias.** We support several types
     * of API keys: * Ed25519 (recommended) * HMAC * RSA We recommend to **use Ed25519 API keys** as
     * it should provide the best performance and security out of all supported key types. We accept
     * PKCS#8 (BEGIN PUBLIC KEY). For how to generate an RSA key pair to send API requests on
     * Binance. Please refer to the document below
     * [FAQ](https://www.binance.com/en/support/faq/how-to-generate-an-rsa-key-pair-to-send-api-requests-on-binance-2b79728f331e43079b27440d9d15c5db)
     * . Read [REST
     * API](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md#signed-trade-and-user_data-endpoint-security)
     * or [WebSocket
     * API](https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-api.md#request-security)
     * documentation to learn how to use different API keys You need to enable Permits “Enable Spot
     * &amp; Margin Trading” option for the API Key which requests this endpoint. Weight: 1(UID)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createSpecialKeyTest() throws ApiException, CryptoException {
        CreateSpecialKeyRequest createSpecialKeyRequest = new CreateSpecialKeyRequest();

        createSpecialKeyRequest.apiName("");

        ApiResponse<CreateSpecialKeyResponse> response =
                api.createSpecialKey(createSpecialKeyRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000apiName=", signInputCaptor.getValue());
        assertEquals(
                "a2ad423c0df49a3d8b7f2faeda0307aade418bcd976219b90d89fa8ef3f2a712",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/apiKey", actualRequest.url().encodedPath());
    }

    /**
     * Delete Special Key(Low-Latency Trading)(TRADE)
     *
     * <p>This only applies to Special Key for Low Latency Trading. If apiKey is given, apiName will
     * be ignored. If apiName is given with no apiKey, all apikeys with given apiName will be
     * deleted. You need to enable Permits “Enable Spot &amp; Margin Trading” option for the API Key
     * which requests this endpoint. Weight: 1(UID)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteSpecialKeyTest() throws ApiException, CryptoException {
        String apiName = "";
        String symbol = "";
        Long recvWindow = 5000L;
        api.deleteSpecialKey(apiName, symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy).execute(callArgumentCaptor.capture());

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "apiName=&symbol=&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "9cb386225deeface4c3aea3d1600f720006f7e67c5fe0f7dc7ec4ff0fdc53fcf",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/apiKey", actualRequest.url().encodedPath());
    }

    /**
     * Edit ip for Special Key(Low-Latency Trading)(TRADE)
     *
     * <p>Edit ip restriction. This only applies to Special Key for Low Latency Trading. You need to
     * enable Permits “Enable Spot &amp; Margin Trading” option for the API Key which requests this
     * endpoint. Weight: 1(UID)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void editIpForSpecialKeyTest() throws ApiException, CryptoException {
        EditIpForSpecialKeyRequest editIpForSpecialKeyRequest = new EditIpForSpecialKeyRequest();

        editIpForSpecialKeyRequest.ip("");

        api.editIpForSpecialKey(editIpForSpecialKeyRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy).execute(callArgumentCaptor.capture());

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000ip=", signInputCaptor.getValue());
        assertEquals(
                "66267361179ca0a67b144a0ceadbd0338510680bed6f7d4546abbd4e4eb7fee0",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/apiKey/ip", actualRequest.url().encodedPath());
    }

    /**
     * Get Force Liquidation Record (USER_DATA)
     *
     * <p>Get Force Liquidation Record * Response in descending order Weight: 1(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getForceLiquidationRecordTest() throws ApiException, CryptoException {
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        String isolatedSymbol = "";
        Long current = 1L;
        Long size = 10L;
        Long recvWindow = 5000L;
        ApiResponse<GetForceLiquidationRecordResponse> response =
                api.getForceLiquidationRecord(
                        startTime, endTime, isolatedSymbol, current, size, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "startTime=1623319461670&endTime=1641782889000&isolatedSymbol=&current=1&size=10&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "dff844dbf8ae3029286ecfaf18cd34dbda2bc10e91ca64e3b9f17c59a4d9d12c",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/forceLiquidationRec", actualRequest.url().encodedPath());
    }

    /**
     * Get Small Liability Exchange Coin List (USER_DATA)
     *
     * <p>Query the coins which can be small liability exchange Weight: 100
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getSmallLiabilityExchangeCoinListTest() throws ApiException, CryptoException {
        Long recvWindow = 5000L;
        ApiResponse<GetSmallLiabilityExchangeCoinListResponse> response =
                api.getSmallLiabilityExchangeCoinList(recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "2cdd1e484bce80021437bee6b762e6a276b1954c3a0c011a16f6f2f6a47aba75",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/exchange-small-liability", actualRequest.url().encodedPath());
    }

    /**
     * Get Small Liability Exchange History (USER_DATA)
     *
     * <p>Get Small liability Exchange History Weight: 100(UID)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getSmallLiabilityExchangeHistoryTest() throws ApiException, CryptoException {
        Long current = 1L;
        Long size = 10L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long recvWindow = 5000L;
        ApiResponse<GetSmallLiabilityExchangeHistoryResponse> response =
                api.getSmallLiabilityExchangeHistory(current, size, startTime, endTime, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "current=1&size=10&startTime=1623319461670&endTime=1641782889000&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "cf3665c6ad1ae7c4af54fc90d8cae844164449f5f850748c21373dd86013616b",
                actualRequest.url().queryParameter("signature"));
        assertEquals(
                "/sapi/v1/margin/exchange-small-liability-history",
                actualRequest.url().encodedPath());
    }

    /**
     * Margin Account Cancel all Open Orders on a Symbol (TRADE)
     *
     * <p>Cancels all active orders on a symbol for margin account.&lt;br&gt;&lt;/br&gt; This
     * includes OCO orders. Weight: 1
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void marginAccountCancelAllOpenOrdersOnASymbolTest()
            throws ApiException, CryptoException {
        String symbol = "";
        String isIsolated = "false";
        Long recvWindow = 5000L;
        ApiResponse<MarginAccountCancelAllOpenOrdersOnASymbolResponse> response =
                api.marginAccountCancelAllOpenOrdersOnASymbol(symbol, isIsolated, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&isIsolated=false&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "add65e05865fdd18a5031b8cd03b817c53044ab47bc775e023898c5f451f9fab",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/openOrders", actualRequest.url().encodedPath());
    }

    /**
     * Margin Account Cancel OCO (TRADE)
     *
     * <p>Cancel an entire Order List for a margin account. * Canceling an individual leg will
     * cancel the entire OCO Weight: 1(UID)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void marginAccountCancelOcoTest() throws ApiException, CryptoException {
        String symbol = "";
        String isIsolated = "false";
        Long orderListId = 1L;
        String listClientOrderId = "1";
        String newClientOrderId = "1";
        Long recvWindow = 5000L;
        ApiResponse<MarginAccountCancelOcoResponse> response =
                api.marginAccountCancelOco(
                        symbol,
                        isIsolated,
                        orderListId,
                        listClientOrderId,
                        newClientOrderId,
                        recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&isIsolated=false&orderListId=1&listClientOrderId=1&newClientOrderId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "b9b55143daefd9ab6b09b85bfeb910d085e7558d9dc486af9975f9815ca1f72a",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/orderList", actualRequest.url().encodedPath());
    }

    /**
     * Margin Account Cancel Order (TRADE)
     *
     * <p>Cancel an active order for margin account. * Either orderId or origClientOrderId must be
     * sent. Weight: 10(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void marginAccountCancelOrderTest() throws ApiException, CryptoException {
        String symbol = "";
        String isIsolated = "false";
        Long orderId = 1L;
        String origClientOrderId = "1";
        String newClientOrderId = "1";
        Long recvWindow = 5000L;
        ApiResponse<MarginAccountCancelOrderResponse> response =
                api.marginAccountCancelOrder(
                        symbol,
                        isIsolated,
                        orderId,
                        origClientOrderId,
                        newClientOrderId,
                        recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&isIsolated=false&orderId=1&origClientOrderId=1&newClientOrderId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "524eb7d8ebb73bd66897f739ec254947072e8149af95053fd246d59bc6cff1f3",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/order", actualRequest.url().encodedPath());
    }

    /**
     * Margin Account New OCO (TRADE)
     *
     * <p>Send in a new OCO for a margin account * autoRepayAtCancel is suggested to set as “FALSE”
     * to keep liability unrepaid under high frequent new order/cancel order execution Weight:
     * 6(UID)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void marginAccountNewOcoTest() throws ApiException, CryptoException {
        MarginAccountNewOcoRequest marginAccountNewOcoRequest = new MarginAccountNewOcoRequest();

        marginAccountNewOcoRequest.symbol("");
        marginAccountNewOcoRequest.side(Side.BUY);
        marginAccountNewOcoRequest.quantity(1d);
        marginAccountNewOcoRequest.price(1d);
        marginAccountNewOcoRequest.stopPrice(1d);

        ApiResponse<MarginAccountNewOcoResponse> response =
                api.marginAccountNewOco(marginAccountNewOcoRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=&side=BUY&stopPrice=1&quantity=1&price=1",
                signInputCaptor.getValue());
        assertEquals(
                "a44f38881c72baae22ef0ab8d4275a3dad363487848a7ea9ea3c7ba58a6ccdb9",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/order/oco", actualRequest.url().encodedPath());
    }

    /**
     * Margin Account New Order (TRADE)
     *
     * <p>Post a new order for margin account. * autoRepayAtCancel is suggested to set as “FALSE” to
     * keep liability unrepaid under high frequent new order/cancel order execution Weight: 6(UID)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void marginAccountNewOrderTest() throws ApiException, CryptoException {
        MarginAccountNewOrderRequest marginAccountNewOrderRequest =
                new MarginAccountNewOrderRequest();

        marginAccountNewOrderRequest.symbol("");
        marginAccountNewOrderRequest.side(Side.BUY);
        marginAccountNewOrderRequest.type("");

        ApiResponse<MarginAccountNewOrderResponse> response =
                api.marginAccountNewOrder(marginAccountNewOrderRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000symbol=&side=BUY&type=", signInputCaptor.getValue());
        assertEquals(
                "fa7ddab4a660903f7305421c43e7705a88aa40d3039a17e6bf6ad242ec379289",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/order", actualRequest.url().encodedPath());
    }

    /**
     * Margin Account New OTO (TRADE)
     *
     * <p>Post a new OTO order for margin account: - An OTO (One-Triggers-the-Other) is an order
     * list comprised of 2 orders. - The first order is called the **working order** and must be
     * &#x60;LIMIT&#x60; or &#x60;LIMIT_MAKER&#x60;. Initially, only the working order goes on the
     * order book. - The second order is called the **pending order**. It can be any order type
     * except for &#x60;MARKET&#x60; orders using parameter &#x60;quoteOrderQty&#x60;. The pending
     * order is only placed on the order book when the working order gets **fully filled**. - If
     * either the working order or the pending order is cancelled individually, the other order in
     * the order list will also be canceled or expired. - When the order list is placed, if the
     * working order gets **immediately fully filled**, the placement response will show the working
     * order as &#x60;FILLED&#x60; but the pending order will still appear as
     * &#x60;PENDING_NEW&#x60;. You need to query the status of the pending order again to see its
     * updated status. - OTOs add **2 orders** to the unfilled order count,
     * &#x60;EXCHANGE_MAX_NUM_ORDERS&#x60; filter and &#x60;MAX_NUM_ORDERS&#x60; filter. *
     * autoRepayAtCancel is suggested to set as “FALSE” to keep liability unrepaid under high
     * frequent new order/cancel order execution * Depending on the &#x60;pendingType&#x60; or
     * &#x60;workingType&#x60;, some optional parameters will become mandatory: Weight: 6(UID)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void marginAccountNewOtoTest() throws ApiException, CryptoException {
        MarginAccountNewOtoRequest marginAccountNewOtoRequest = new MarginAccountNewOtoRequest();

        marginAccountNewOtoRequest.symbol("");
        marginAccountNewOtoRequest.workingType("");
        marginAccountNewOtoRequest.workingSide("");
        marginAccountNewOtoRequest.workingPrice(1d);
        marginAccountNewOtoRequest.workingQuantity(1d);
        marginAccountNewOtoRequest.workingIcebergQty(1d);
        marginAccountNewOtoRequest.pendingType("Order Types");
        marginAccountNewOtoRequest.pendingSide("");
        marginAccountNewOtoRequest.pendingQuantity(1d);

        ApiResponse<MarginAccountNewOtoResponse> response =
                api.marginAccountNewOto(marginAccountNewOtoRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=&workingIcebergQty=1&workingQuantity=1&pendingSide=&pendingQuantity=1&pendingType=Order%20Types&workingSide=&workingPrice=1&workingType=",
                signInputCaptor.getValue());
        assertEquals(
                "b3e064facb953c7bfe41bc98b73c1d1e77e572950f680288dcac3fb4abee16e0",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/order/oto", actualRequest.url().encodedPath());
    }

    /**
     * Margin Account New OTOCO (TRADE)
     *
     * <p>Post a new OTOCO order for margin account： - An OTOCO (One-Triggers-One-Cancels-the-Other)
     * is an order list comprised of 3 orders. - The first order is called the **working order** and
     * must be &#x60;LIMIT&#x60; or &#x60;LIMIT_MAKER&#x60;. Initially, only the working order goes
     * on the order book. - The behavior of the working order is the same as the OTO. - OTOCO has 2
     * pending orders (pending above and pending below), forming an OCO pair. The pending orders are
     * only placed on the order book when the working order gets **fully filled**. - The rules of
     * the pending above and pending below follow the same rules as the [Order List
     * OCO](https://developers.binance.com/docs/margin_trading/trade/Margin-Account-New-OCO). -
     * OTOCOs add **3 orders** against the unfilled order count, &#x60;EXCHANGE_MAX_NUM_ORDERS&#x60;
     * filter, and &#x60;MAX_NUM_ORDERS&#x60; filter. * autoRepayAtCancel is suggested to set as
     * “FALSE” to keep liability unrepaid under high frequent new order/cancel order execution *
     * Depending on the &#x60;pendingAboveType&#x60;/&#x60;pendingBelowType&#x60; or
     * &#x60;workingType&#x60;, some optional parameters will become mandatory: Weight: 6(UID)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void marginAccountNewOtocoTest() throws ApiException, CryptoException {
        MarginAccountNewOtocoRequest marginAccountNewOtocoRequest =
                new MarginAccountNewOtocoRequest();

        marginAccountNewOtocoRequest.symbol("");
        marginAccountNewOtocoRequest.workingType("");
        marginAccountNewOtocoRequest.workingSide("");
        marginAccountNewOtocoRequest.workingPrice(1d);
        marginAccountNewOtocoRequest.workingQuantity(1d);
        marginAccountNewOtocoRequest.pendingSide("");
        marginAccountNewOtocoRequest.pendingQuantity(1d);
        marginAccountNewOtocoRequest.pendingAboveType("");

        ApiResponse<MarginAccountNewOtocoResponse> response =
                api.marginAccountNewOtoco(marginAccountNewOtocoRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "timestamp=1736393892000symbol=&workingQuantity=1&pendingSide=&pendingQuantity=1&pendingAboveType=&workingSide=&workingPrice=1&workingType=",
                signInputCaptor.getValue());
        assertEquals(
                "b59af59f8ffdb7c77917fb2e5103f247b6ec76aa2f533042bc1277beebf0c112",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/order/otoco", actualRequest.url().encodedPath());
    }

    /**
     * Margin Manual Liquidation(MARGIN)
     *
     * <p>Margin Manual Liquidation * This endpoint can support Cross Margin Classic Mode and Pro
     * Mode. * And only support Isolated Margin for restricted region. Weight: 3000
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void marginManualLiquidationTest() throws ApiException, CryptoException {
        MarginManualLiquidationRequest marginManualLiquidationRequest =
                new MarginManualLiquidationRequest();

        marginManualLiquidationRequest.type("");

        ApiResponse<MarginManualLiquidationResponse> response =
                api.marginManualLiquidation(marginManualLiquidationRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000type=", signInputCaptor.getValue());
        assertEquals(
                "c32d33d6407f8d47d4fd8e91fbc9fbacb0db2d899069618021e801a0cf447157",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/manual-liquidation", actualRequest.url().encodedPath());
    }

    /**
     * Query Current Margin Order Count Usage (TRADE)
     *
     * <p>Displays the user&#39;s current margin order count usage for all intervals. Weight: 20(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryCurrentMarginOrderCountUsageTest() throws ApiException, CryptoException {
        String isIsolated = "false";
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<QueryCurrentMarginOrderCountUsageResponse> response =
                api.queryCurrentMarginOrderCountUsage(isIsolated, symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "isIsolated=false&symbol=&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "4af886ac30fe924fc1b3a164db48b5dc0a90f78ef1bc9ccff06a9c29e6ea221c",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/rateLimit/order", actualRequest.url().encodedPath());
    }

    /**
     * Query Margin Account&#39;s all OCO (USER_DATA)
     *
     * <p>Retrieves all OCO for a specific margin account based on provided optional parameters
     * Weight: 200(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryMarginAccountsAllOcoTest() throws ApiException, CryptoException {
        String isIsolated = "false";
        String symbol = "";
        Long fromId = 1L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 500L;
        Long recvWindow = 5000L;
        ApiResponse<QueryMarginAccountsAllOcoResponse> response =
                api.queryMarginAccountsAllOco(
                        isIsolated, symbol, fromId, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "isIsolated=false&symbol=&fromId=1&startTime=1623319461670&endTime=1641782889000&limit=500&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "59e78917e0ee7b158e98245287910e232a5b54ff6cbdece62b598c580665a879",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/allOrderList", actualRequest.url().encodedPath());
    }

    /**
     * Query Margin Account&#39;s All Orders (USER_DATA)
     *
     * <p>Query Margin Account&#39;s All Orders * If orderId is set, it will get orders &gt;&#x3D;
     * that orderId. Otherwise the orders within 24 hours are returned. * For some historical orders
     * cummulativeQuoteQty will be &lt; 0, meaning the data is not available at this time. * Less
     * than 24 hours between startTime and endTime. Weight: 200(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryMarginAccountsAllOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        String isIsolated = "false";
        Long orderId = 1L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long limit = 500L;
        Long recvWindow = 5000L;
        ApiResponse<QueryMarginAccountsAllOrdersResponse> response =
                api.queryMarginAccountsAllOrders(
                        symbol, isIsolated, orderId, startTime, endTime, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&isIsolated=false&orderId=1&startTime=1623319461670&endTime=1641782889000&limit=500&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "b19144d8ecaee65d9a44334e0bff7233225b2e742455de322f7d6cee6585236d",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/allOrders", actualRequest.url().encodedPath());
    }

    /**
     * Query Margin Account&#39;s OCO (USER_DATA)
     *
     * <p>Retrieves a specific OCO based on provided optional parameters Weight: 10(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryMarginAccountsOcoTest() throws ApiException, CryptoException {
        String isIsolated = "false";
        String symbol = "";
        Long orderListId = 1L;
        String origClientOrderId = "1";
        Long recvWindow = 5000L;
        ApiResponse<QueryMarginAccountsOcoResponse> response =
                api.queryMarginAccountsOco(
                        isIsolated, symbol, orderListId, origClientOrderId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "isIsolated=false&symbol=&orderListId=1&origClientOrderId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "65c1de468d71a9069148cfd2ab6a625c99380dc889980ab0420d121b301b8a44",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/orderList", actualRequest.url().encodedPath());
    }

    /**
     * Query Margin Account&#39;s Open OCO (USER_DATA)
     *
     * <p>Query Margin Account&#39;s Open OCO Weight: 10(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryMarginAccountsOpenOcoTest() throws ApiException, CryptoException {
        String isIsolated = "false";
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<QueryMarginAccountsOpenOcoResponse> response =
                api.queryMarginAccountsOpenOco(isIsolated, symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "isIsolated=false&symbol=&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "4af886ac30fe924fc1b3a164db48b5dc0a90f78ef1bc9ccff06a9c29e6ea221c",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/openOrderList", actualRequest.url().encodedPath());
    }

    /**
     * Query Margin Account&#39;s Open Orders (USER_DATA)
     *
     * <p>Query Margin Account&#39;s Open Orders * If the symbol is not sent, orders for all symbols
     * will be returned in an array. * When all symbols are returned, the number of requests counted
     * against the rate limiter is equal to the number of symbols currently trading on the exchange.
     * * If isIsolated &#x3D;\&quot;TRUE\&quot;, symbol must be sent. Weight: 10(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryMarginAccountsOpenOrdersTest() throws ApiException, CryptoException {
        String symbol = "";
        String isIsolated = "false";
        Long recvWindow = 5000L;
        ApiResponse<QueryMarginAccountsOpenOrdersResponse> response =
                api.queryMarginAccountsOpenOrders(symbol, isIsolated, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&isIsolated=false&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "add65e05865fdd18a5031b8cd03b817c53044ab47bc775e023898c5f451f9fab",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/openOrders", actualRequest.url().encodedPath());
    }

    /**
     * Query Margin Account&#39;s Order (USER_DATA)
     *
     * <p>Query Margin Account&#39;s Order * Either orderId or origClientOrderId must be sent. * For
     * some historical orders cummulativeQuoteQty will be &lt; 0, meaning the data is not available
     * at this time. Weight: 10(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryMarginAccountsOrderTest() throws ApiException, CryptoException {
        String symbol = "";
        String isIsolated = "false";
        Long orderId = 1L;
        String origClientOrderId = "1";
        Long recvWindow = 5000L;
        ApiResponse<QueryMarginAccountsOrderResponse> response =
                api.queryMarginAccountsOrder(
                        symbol, isIsolated, orderId, origClientOrderId, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&isIsolated=false&orderId=1&origClientOrderId=1&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "28c77d755a10d018e01fcdf7982e25569fd38c91bd89e0dea2a98c986cebd842",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/order", actualRequest.url().encodedPath());
    }

    /**
     * Query Margin Account&#39;s Trade List (USER_DATA)
     *
     * <p>Query Margin Account&#39;s Trade List * If fromId is set, it will get trades &gt;&#x3D;
     * that fromId. Otherwise the trades within 24 hours are returned. * Less than 24 hours between
     * startTime and endTime. Weight: 10(IP)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void queryMarginAccountsTradeListTest() throws ApiException, CryptoException {
        String symbol = "";
        String isIsolated = "false";
        Long orderId = 1L;
        Long startTime = 1623319461670L;
        Long endTime = 1641782889000L;
        Long fromId = 1L;
        Long limit = 500L;
        Long recvWindow = 5000L;
        ApiResponse<QueryMarginAccountsTradeListResponse> response =
                api.queryMarginAccountsTradeList(
                        symbol, isIsolated, orderId, startTime, endTime, fromId, limit, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals(
                "symbol=&isIsolated=false&orderId=1&startTime=1623319461670&endTime=1641782889000&fromId=1&limit=500&recvWindow=5000&timestamp=1736393892000",
                signInputCaptor.getValue());
        assertEquals(
                "54ee52c6763e418b1d66b1520323fe3d0b3ace00a4e5fe68bd2fa0513d8d93e7",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/myTrades", actualRequest.url().encodedPath());
    }

    /**
     * Query Special key(Low Latency Trading)(TRADE)
     *
     * <p>Query Special Key Information. This only applies to Special Key for Low Latency Trading.
     * Weight: 1(UID)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void querySpecialKeyTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<QuerySpecialKeyResponse> response = api.querySpecialKey(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/apiKey", actualRequest.url().encodedPath());
    }

    /**
     * Query Special key List(Low Latency Trading)(TRADE)
     *
     * <p>This only applies to Special Key for Low Latency Trading. Weight: 1(UID)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void querySpecialKeyListTest() throws ApiException, CryptoException {
        String symbol = "";
        Long recvWindow = 5000L;
        ApiResponse<QuerySpecialKeyListResponse> response =
                api.querySpecialKeyList(symbol, recvWindow);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy)
                .execute(callArgumentCaptor.capture(), Mockito.any(java.lang.reflect.Type.class));

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("symbol=&recvWindow=5000&timestamp=1736393892000", signInputCaptor.getValue());
        assertEquals(
                "db1a455af0a2e82b4ec79595d994eb2e7f6b8a93c91a67a2aa59e2b2eae4bc68",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/api-key-list", actualRequest.url().encodedPath());
    }

    /**
     * Small Liability Exchange (MARGIN)
     *
     * <p>Small Liability Exchange * Only convert once within 6 hours * Only liability valuation
     * less than 10 USDT are supported * The maximum number of coin is 10 Weight: 3000(UID)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void smallLiabilityExchangeTest() throws ApiException, CryptoException {
        SmallLiabilityExchangeRequest smallLiabilityExchangeRequest =
                new SmallLiabilityExchangeRequest();

        smallLiabilityExchangeRequest.assetNames(new AssetNames());

        api.smallLiabilityExchange(smallLiabilityExchangeRequest);

        ArgumentCaptor<Call> callArgumentCaptor = ArgumentCaptor.forClass(Call.class);
        Mockito.verify(apiClientSpy).execute(callArgumentCaptor.capture());

        ArgumentCaptor<String> signInputCaptor = ArgumentCaptor.forClass(String.class);
        Mockito.verify(signatureGeneratorSpy).signAsString(signInputCaptor.capture());

        Call captorValue = callArgumentCaptor.getValue();
        Request actualRequest = captorValue.request();

        assertEquals("timestamp=1736393892000assetNames=%5B%5D", signInputCaptor.getValue());
        assertEquals(
                "ba2268aff20977513c2ec557cdf2b6721242a78d2f8bf2791821f1fecffd01e2",
                actualRequest.url().queryParameter("signature"));
        assertEquals("/sapi/v1/margin/exchange-small-liability", actualRequest.url().encodedPath());
    }
}
