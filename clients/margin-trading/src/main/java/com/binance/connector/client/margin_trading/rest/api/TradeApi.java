/*
 * Binance Margin Trading REST API
 * OpenAPI Specification for the Binance Margin Trading REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.margin_trading.rest.api;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.DecimalFormatter;
import com.binance.connector.client.common.JSON;
import com.binance.connector.client.common.Pair;
import com.binance.connector.client.common.SystemUtil;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.exception.ConstraintViolationException;
import com.binance.connector.client.margin_trading.rest.model.CreateSpecialKeyRequest;
import com.binance.connector.client.margin_trading.rest.model.CreateSpecialKeyResponse;
import com.binance.connector.client.margin_trading.rest.model.EditIpForSpecialKeyRequest;
import com.binance.connector.client.margin_trading.rest.model.GetForceLiquidationRecordResponse;
import com.binance.connector.client.margin_trading.rest.model.GetSmallLiabilityExchangeCoinListResponse;
import com.binance.connector.client.margin_trading.rest.model.GetSmallLiabilityExchangeHistoryResponse;
import com.binance.connector.client.margin_trading.rest.model.MarginAccountCancelAllOpenOrdersOnASymbolResponse;
import com.binance.connector.client.margin_trading.rest.model.MarginAccountCancelOcoResponse;
import com.binance.connector.client.margin_trading.rest.model.MarginAccountCancelOrderResponse;
import com.binance.connector.client.margin_trading.rest.model.MarginAccountNewOcoRequest;
import com.binance.connector.client.margin_trading.rest.model.MarginAccountNewOcoResponse;
import com.binance.connector.client.margin_trading.rest.model.MarginAccountNewOrderRequest;
import com.binance.connector.client.margin_trading.rest.model.MarginAccountNewOrderResponse;
import com.binance.connector.client.margin_trading.rest.model.MarginAccountNewOtoRequest;
import com.binance.connector.client.margin_trading.rest.model.MarginAccountNewOtoResponse;
import com.binance.connector.client.margin_trading.rest.model.MarginAccountNewOtocoRequest;
import com.binance.connector.client.margin_trading.rest.model.MarginAccountNewOtocoResponse;
import com.binance.connector.client.margin_trading.rest.model.MarginManualLiquidationRequest;
import com.binance.connector.client.margin_trading.rest.model.MarginManualLiquidationResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryCurrentMarginOrderCountUsageResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryMarginAccountsAllOcoResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryMarginAccountsAllOrdersResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryMarginAccountsOcoResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryMarginAccountsOpenOcoResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryMarginAccountsOpenOrdersResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryMarginAccountsOrderResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryMarginAccountsTradeListResponse;
import com.binance.connector.client.margin_trading.rest.model.QuerySpecialKeyListResponse;
import com.binance.connector.client.margin_trading.rest.model.QuerySpecialKeyResponse;
import com.binance.connector.client.margin_trading.rest.model.SmallLiabilityExchangeRequest;
import com.google.gson.reflect.TypeToken;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Valid;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.constraints.*;
import jakarta.validation.executable.ExecutableValidator;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator;

public class TradeApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    private static final String USER_AGENT =
            String.format(
                    "binance-margin-trading/2.0.0 (Java/%s; %s; %s)",
                    SystemUtil.getJavaVersion(), SystemUtil.getOs(), SystemUtil.getArch());
    private static final boolean HAS_TIME_UNIT = false;

    public TradeApi(ClientConfiguration clientConfiguration) {
        this(new ApiClient(clientConfiguration));
    }

    public TradeApi(ApiClient apiClient) {
        apiClient.setUserAgent(USER_AGENT);
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for createSpecialKey
     *
     * @param createSpecialKeyRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Create Special Key </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Create-Special-Key-of-Low-Latency-Trading">Create
     *     Special Key(Low-Latency Trading)(TRADE) Documentation</a>
     */
    private okhttp3.Call createSpecialKeyCall(CreateSpecialKeyRequest createSpecialKeyRequest)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/apiKey";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (createSpecialKeyRequest.getApiName() != null) {
            localVarFormParams.put("apiName", createSpecialKeyRequest.getApiName());
        }

        if (createSpecialKeyRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", createSpecialKeyRequest.getSymbol());
        }

        if (createSpecialKeyRequest.getIp() != null) {
            localVarFormParams.put("ip", createSpecialKeyRequest.getIp());
        }

        if (createSpecialKeyRequest.getPublicKey() != null) {
            localVarFormParams.put("publicKey", createSpecialKeyRequest.getPublicKey());
        }

        if (createSpecialKeyRequest.getPermissionMode() != null) {
            localVarFormParams.put("permissionMode", createSpecialKeyRequest.getPermissionMode());
        }

        if (createSpecialKeyRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", createSpecialKeyRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createSpecialKeyValidateBeforeCall(
            CreateSpecialKeyRequest createSpecialKeyRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {createSpecialKeyRequest};
            Method method =
                    this.getClass().getMethod("createSpecialKey", CreateSpecialKeyRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return createSpecialKeyCall(createSpecialKeyRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Create Special Key(Low-Latency Trading)(TRADE) **Binance Margin offers low-latency trading
     * through a [special
     * key](https://www.binance.com/en/support/faq/frequently-asked-questions-on-margin-special-api-key-3208663e900d4d2e9fec4140e1832f4e),
     * available exclusively to users with VIP level 4 or higher. ** **If you are VIP level 3 or
     * below, please contact your VIP manager for eligibility criterias.** We support several types
     * of API keys: * Ed25519 (recommended) * HMAC * RSA We recommend to **use Ed25519 API keys** as
     * it should provide the best performance and security out of all supported key types. We accept
     * PKCS#8 (BEGIN PUBLIC KEY). For how to generate an RSA key pair to send API requests on
     * Binance. Please refer to the document below
     * [FAQ](https://www.binance.com/en/support/faq/how-to-generate-an-rsa-key-pair-to-send-api-requests-on-binance-2b79728f331e43079b27440d9d15c5db)
     * . Read [REST
     * API](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md#signed-trade-and-user_data-endpoint-security)
     * or [WebSocket
     * API](https://github.com/binance/binance-spot-api-docs/blob/master/web-socket-api.md#request-security)
     * documentation to learn how to use different API keys You need to enable Permits “Enable Spot
     * &amp; Margin Trading” option for the API Key which requests this endpoint. Weight: 1(UID)
     *
     * @param createSpecialKeyRequest (required)
     * @return ApiResponse&lt;CreateSpecialKeyResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Create Special Key </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Create-Special-Key-of-Low-Latency-Trading">Create
     *     Special Key(Low-Latency Trading)(TRADE) Documentation</a>
     */
    public ApiResponse<CreateSpecialKeyResponse> createSpecialKey(
            @Valid @NotNull CreateSpecialKeyRequest createSpecialKeyRequest) throws ApiException {
        okhttp3.Call localVarCall = createSpecialKeyValidateBeforeCall(createSpecialKeyRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<CreateSpecialKeyResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for deleteSpecialKey
     *
     * @param apiName (optional)
     * @param symbol isolated margin pair (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Delete-Special-Key-of-Low-Latency-Trading">Delete
     *     Special Key(Low-Latency Trading)(TRADE) Documentation</a>
     */
    private okhttp3.Call deleteSpecialKeyCall(String apiName, String symbol, Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/apiKey";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (apiName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("apiName", apiName));
        }

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "DELETE",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteSpecialKeyValidateBeforeCall(
            String apiName, String symbol, Long recvWindow) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {apiName, symbol, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod("deleteSpecialKey", String.class, String.class, Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return deleteSpecialKeyCall(apiName, symbol, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Delete Special Key(Low-Latency Trading)(TRADE) This only applies to Special Key for Low
     * Latency Trading. If apiKey is given, apiName will be ignored. If apiName is given with no
     * apiKey, all apikeys with given apiName will be deleted. You need to enable Permits “Enable
     * Spot &amp; Margin Trading” option for the API Key which requests this endpoint. Weight:
     * 1(UID)
     *
     * @param apiName (optional)
     * @param symbol isolated margin pair (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Delete-Special-Key-of-Low-Latency-Trading">Delete
     *     Special Key(Low-Latency Trading)(TRADE) Documentation</a>
     */
    public ApiResponse<Void> deleteSpecialKey(String apiName, String symbol, Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall = deleteSpecialKeyValidateBeforeCall(apiName, symbol, recvWindow);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Build call for editIpForSpecialKey
     *
     * @param editIpForSpecialKeyRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Edit-ip-for-Special-Key-of-Low-Latency-Trading">Edit
     *     ip for Special Key(Low-Latency Trading)(TRADE) Documentation</a>
     */
    private okhttp3.Call editIpForSpecialKeyCall(
            EditIpForSpecialKeyRequest editIpForSpecialKeyRequest) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/apiKey/ip";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (editIpForSpecialKeyRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", editIpForSpecialKeyRequest.getSymbol());
        }

        if (editIpForSpecialKeyRequest.getIp() != null) {
            localVarFormParams.put("ip", editIpForSpecialKeyRequest.getIp());
        }

        if (editIpForSpecialKeyRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", editIpForSpecialKeyRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "PUT",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call editIpForSpecialKeyValidateBeforeCall(
            EditIpForSpecialKeyRequest editIpForSpecialKeyRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {editIpForSpecialKeyRequest};
            Method method =
                    this.getClass()
                            .getMethod("editIpForSpecialKey", EditIpForSpecialKeyRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return editIpForSpecialKeyCall(editIpForSpecialKeyRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Edit ip for Special Key(Low-Latency Trading)(TRADE) Edit ip restriction. This only applies to
     * Special Key for Low Latency Trading. You need to enable Permits “Enable Spot &amp; Margin
     * Trading” option for the API Key which requests this endpoint. Weight: 1(UID)
     *
     * @param editIpForSpecialKeyRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Edit-ip-for-Special-Key-of-Low-Latency-Trading">Edit
     *     ip for Special Key(Low-Latency Trading)(TRADE) Documentation</a>
     */
    public ApiResponse<Void> editIpForSpecialKey(
            @Valid @NotNull EditIpForSpecialKeyRequest editIpForSpecialKeyRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                editIpForSpecialKeyValidateBeforeCall(editIpForSpecialKeyRequest);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Build call for getForceLiquidationRecord
     *
     * @param startTime 只支持查询最近90天的数据 (optional)
     * @param endTime (optional)
     * @param isolatedSymbol isolated symbol (optional)
     * @param current Currently querying page. Start from 1. Default:1 (optional)
     * @param size Default:10 Max:100 (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Get Force Liquidation Record </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Get-Force-Liquidation-Record">Get
     *     Force Liquidation Record (USER_DATA) Documentation</a>
     */
    private okhttp3.Call getForceLiquidationRecordCall(
            Long startTime,
            Long endTime,
            String isolatedSymbol,
            Long current,
            Long size,
            Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/forceLiquidationRec";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (isolatedSymbol != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("isolatedSymbol", isolatedSymbol));
        }

        if (current != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("current", current));
        }

        if (size != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("size", size));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getForceLiquidationRecordValidateBeforeCall(
            Long startTime,
            Long endTime,
            String isolatedSymbol,
            Long current,
            Long size,
            Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {
                startTime, endTime, isolatedSymbol, current, size, recvWindow
            };
            Method method =
                    this.getClass()
                            .getMethod(
                                    "getForceLiquidationRecord",
                                    Long.class,
                                    Long.class,
                                    String.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return getForceLiquidationRecordCall(
                        startTime, endTime, isolatedSymbol, current, size, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Get Force Liquidation Record (USER_DATA) Get Force Liquidation Record * Response in
     * descending order Weight: 1(IP)
     *
     * @param startTime 只支持查询最近90天的数据 (optional)
     * @param endTime (optional)
     * @param isolatedSymbol isolated symbol (optional)
     * @param current Currently querying page. Start from 1. Default:1 (optional)
     * @param size Default:10 Max:100 (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;GetForceLiquidationRecordResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Get Force Liquidation Record </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Get-Force-Liquidation-Record">Get
     *     Force Liquidation Record (USER_DATA) Documentation</a>
     */
    public ApiResponse<GetForceLiquidationRecordResponse> getForceLiquidationRecord(
            Long startTime,
            Long endTime,
            String isolatedSymbol,
            Long current,
            Long size,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                getForceLiquidationRecordValidateBeforeCall(
                        startTime, endTime, isolatedSymbol, current, size, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<GetForceLiquidationRecordResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for getSmallLiabilityExchangeCoinList
     *
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Get Small Liability Exchange Coin List </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Get-Small-Liability-Exchange-Coin-List">Get
     *     Small Liability Exchange Coin List (USER_DATA) Documentation</a>
     */
    private okhttp3.Call getSmallLiabilityExchangeCoinListCall(Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/exchange-small-liability";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSmallLiabilityExchangeCoinListValidateBeforeCall(Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {recvWindow};
            Method method =
                    this.getClass().getMethod("getSmallLiabilityExchangeCoinList", Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return getSmallLiabilityExchangeCoinListCall(recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Get Small Liability Exchange Coin List (USER_DATA) Query the coins which can be small
     * liability exchange Weight: 100
     *
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;GetSmallLiabilityExchangeCoinListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Get Small Liability Exchange Coin List </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Get-Small-Liability-Exchange-Coin-List">Get
     *     Small Liability Exchange Coin List (USER_DATA) Documentation</a>
     */
    public ApiResponse<GetSmallLiabilityExchangeCoinListResponse> getSmallLiabilityExchangeCoinList(
            Long recvWindow) throws ApiException {
        okhttp3.Call localVarCall = getSmallLiabilityExchangeCoinListValidateBeforeCall(recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<GetSmallLiabilityExchangeCoinListResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for getSmallLiabilityExchangeHistory
     *
     * @param current Currently querying page. Start from 1. Default:1 (required)
     * @param size Default:10, Max:100 (required)
     * @param startTime 只支持查询最近90天的数据 (optional)
     * @param endTime (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Get Small Liability Exchange History </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Get-Small-Liability-Exchange-History">Get
     *     Small Liability Exchange History (USER_DATA) Documentation</a>
     */
    private okhttp3.Call getSmallLiabilityExchangeHistoryCall(
            Long current, Long size, Long startTime, Long endTime, Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/exchange-small-liability-history";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (current != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("current", current));
        }

        if (size != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("size", size));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSmallLiabilityExchangeHistoryValidateBeforeCall(
            Long current, Long size, Long startTime, Long endTime, Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {current, size, startTime, endTime, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "getSmallLiabilityExchangeHistory",
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return getSmallLiabilityExchangeHistoryCall(
                        current, size, startTime, endTime, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Get Small Liability Exchange History (USER_DATA) Get Small liability Exchange History Weight:
     * 100(UID)
     *
     * @param current Currently querying page. Start from 1. Default:1 (required)
     * @param size Default:10, Max:100 (required)
     * @param startTime 只支持查询最近90天的数据 (optional)
     * @param endTime (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;GetSmallLiabilityExchangeHistoryResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Get Small Liability Exchange History </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Get-Small-Liability-Exchange-History">Get
     *     Small Liability Exchange History (USER_DATA) Documentation</a>
     */
    public ApiResponse<GetSmallLiabilityExchangeHistoryResponse> getSmallLiabilityExchangeHistory(
            @NotNull Long current,
            @NotNull Long size,
            Long startTime,
            Long endTime,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                getSmallLiabilityExchangeHistoryValidateBeforeCall(
                        current, size, startTime, endTime, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<GetSmallLiabilityExchangeHistoryResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for marginAccountCancelAllOpenOrdersOnASymbol
     *
     * @param symbol (required)
     * @param isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default
     *     \&quot;FALSE\&quot; (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account Cancel all Open Orders on a Symbol </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Margin-Account-Cancel-All-Open-Orders">Margin
     *     Account Cancel all Open Orders on a Symbol (TRADE) Documentation</a>
     */
    private okhttp3.Call marginAccountCancelAllOpenOrdersOnASymbolCall(
            String symbol, String isIsolated, Long recvWindow) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/openOrders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (isIsolated != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("isIsolated", isIsolated));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "DELETE",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call marginAccountCancelAllOpenOrdersOnASymbolValidateBeforeCall(
            String symbol, String isIsolated, Long recvWindow) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, isIsolated, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "marginAccountCancelAllOpenOrdersOnASymbol",
                                    String.class,
                                    String.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return marginAccountCancelAllOpenOrdersOnASymbolCall(
                        symbol, isIsolated, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Margin Account Cancel all Open Orders on a Symbol (TRADE) Cancels all active orders on a
     * symbol for margin account.&lt;br&gt;&lt;/br&gt; This includes OCO orders. Weight: 1
     *
     * @param symbol (required)
     * @param isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default
     *     \&quot;FALSE\&quot; (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;MarginAccountCancelAllOpenOrdersOnASymbolResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account Cancel all Open Orders on a Symbol </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Margin-Account-Cancel-All-Open-Orders">Margin
     *     Account Cancel all Open Orders on a Symbol (TRADE) Documentation</a>
     */
    public ApiResponse<MarginAccountCancelAllOpenOrdersOnASymbolResponse>
            marginAccountCancelAllOpenOrdersOnASymbol(
                    @NotNull String symbol, String isIsolated, Long recvWindow)
                    throws ApiException {
        okhttp3.Call localVarCall =
                marginAccountCancelAllOpenOrdersOnASymbolValidateBeforeCall(
                        symbol, isIsolated, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<MarginAccountCancelAllOpenOrdersOnASymbolResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for marginAccountCancelOco
     *
     * @param symbol (required)
     * @param isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default
     *     \&quot;FALSE\&quot; (optional)
     * @param orderListId Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be
     *     provided (optional)
     * @param listClientOrderId Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must
     *     be provided (optional)
     * @param newClientOrderId Used to uniquely identify this cancel. Automatically generated by
     *     default (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account Cancel OCO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Margin-Account-Cancel-OCO">Margin
     *     Account Cancel OCO (TRADE) Documentation</a>
     */
    private okhttp3.Call marginAccountCancelOcoCall(
            String symbol,
            String isIsolated,
            Long orderListId,
            String listClientOrderId,
            String newClientOrderId,
            Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/orderList";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (isIsolated != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("isIsolated", isIsolated));
        }

        if (orderListId != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("orderListId", orderListId));
        }

        if (listClientOrderId != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("listClientOrderId", listClientOrderId));
        }

        if (newClientOrderId != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("newClientOrderId", newClientOrderId));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "DELETE",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call marginAccountCancelOcoValidateBeforeCall(
            String symbol,
            String isIsolated,
            Long orderListId,
            String listClientOrderId,
            String newClientOrderId,
            Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {
                symbol, isIsolated, orderListId, listClientOrderId, newClientOrderId, recvWindow
            };
            Method method =
                    this.getClass()
                            .getMethod(
                                    "marginAccountCancelOco",
                                    String.class,
                                    String.class,
                                    Long.class,
                                    String.class,
                                    String.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return marginAccountCancelOcoCall(
                        symbol,
                        isIsolated,
                        orderListId,
                        listClientOrderId,
                        newClientOrderId,
                        recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Margin Account Cancel OCO (TRADE) Cancel an entire Order List for a margin account. *
     * Canceling an individual leg will cancel the entire OCO Weight: 1(UID)
     *
     * @param symbol (required)
     * @param isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default
     *     \&quot;FALSE\&quot; (optional)
     * @param orderListId Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be
     *     provided (optional)
     * @param listClientOrderId Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must
     *     be provided (optional)
     * @param newClientOrderId Used to uniquely identify this cancel. Automatically generated by
     *     default (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;MarginAccountCancelOcoResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account Cancel OCO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Margin-Account-Cancel-OCO">Margin
     *     Account Cancel OCO (TRADE) Documentation</a>
     */
    public ApiResponse<MarginAccountCancelOcoResponse> marginAccountCancelOco(
            @NotNull String symbol,
            String isIsolated,
            Long orderListId,
            String listClientOrderId,
            String newClientOrderId,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                marginAccountCancelOcoValidateBeforeCall(
                        symbol,
                        isIsolated,
                        orderListId,
                        listClientOrderId,
                        newClientOrderId,
                        recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<MarginAccountCancelOcoResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for marginAccountCancelOrder
     *
     * @param symbol (required)
     * @param isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default
     *     \&quot;FALSE\&quot; (optional)
     * @param orderId (optional)
     * @param origClientOrderId (optional)
     * @param newClientOrderId Used to uniquely identify this cancel. Automatically generated by
     *     default (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account Cancel Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Margin-Account-Cancel-Order">Margin
     *     Account Cancel Order (TRADE) Documentation</a>
     */
    private okhttp3.Call marginAccountCancelOrderCall(
            String symbol,
            String isIsolated,
            Long orderId,
            String origClientOrderId,
            String newClientOrderId,
            Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/order";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (isIsolated != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("isIsolated", isIsolated));
        }

        if (orderId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderId", orderId));
        }

        if (origClientOrderId != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("origClientOrderId", origClientOrderId));
        }

        if (newClientOrderId != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("newClientOrderId", newClientOrderId));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "DELETE",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call marginAccountCancelOrderValidateBeforeCall(
            String symbol,
            String isIsolated,
            Long orderId,
            String origClientOrderId,
            String newClientOrderId,
            Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {
                symbol, isIsolated, orderId, origClientOrderId, newClientOrderId, recvWindow
            };
            Method method =
                    this.getClass()
                            .getMethod(
                                    "marginAccountCancelOrder",
                                    String.class,
                                    String.class,
                                    Long.class,
                                    String.class,
                                    String.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return marginAccountCancelOrderCall(
                        symbol,
                        isIsolated,
                        orderId,
                        origClientOrderId,
                        newClientOrderId,
                        recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Margin Account Cancel Order (TRADE) Cancel an active order for margin account. * Either
     * orderId or origClientOrderId must be sent. Weight: 10(IP)
     *
     * @param symbol (required)
     * @param isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default
     *     \&quot;FALSE\&quot; (optional)
     * @param orderId (optional)
     * @param origClientOrderId (optional)
     * @param newClientOrderId Used to uniquely identify this cancel. Automatically generated by
     *     default (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;MarginAccountCancelOrderResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account Cancel Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Margin-Account-Cancel-Order">Margin
     *     Account Cancel Order (TRADE) Documentation</a>
     */
    public ApiResponse<MarginAccountCancelOrderResponse> marginAccountCancelOrder(
            @NotNull String symbol,
            String isIsolated,
            Long orderId,
            String origClientOrderId,
            String newClientOrderId,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                marginAccountCancelOrderValidateBeforeCall(
                        symbol,
                        isIsolated,
                        orderId,
                        origClientOrderId,
                        newClientOrderId,
                        recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<MarginAccountCancelOrderResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for marginAccountNewOco
     *
     * @param marginAccountNewOcoRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account New OCO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Margin-Account-New-OCO">Margin
     *     Account New OCO (TRADE) Documentation</a>
     */
    private okhttp3.Call marginAccountNewOcoCall(
            MarginAccountNewOcoRequest marginAccountNewOcoRequest) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/order/oco";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (marginAccountNewOcoRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", marginAccountNewOcoRequest.getSymbol());
        }

        if (marginAccountNewOcoRequest.getIsIsolated() != null) {
            localVarFormParams.put("isIsolated", marginAccountNewOcoRequest.getIsIsolated());
        }

        if (marginAccountNewOcoRequest.getListClientOrderId() != null) {
            localVarFormParams.put(
                    "listClientOrderId", marginAccountNewOcoRequest.getListClientOrderId());
        }

        if (marginAccountNewOcoRequest.getSide() != null) {
            localVarFormParams.put("side", marginAccountNewOcoRequest.getSide());
        }

        if (marginAccountNewOcoRequest.getQuantity() != null) {
            localVarFormParams.put(
                    "quantity",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOcoRequest.getQuantity()));
        }

        if (marginAccountNewOcoRequest.getLimitClientOrderId() != null) {
            localVarFormParams.put(
                    "limitClientOrderId", marginAccountNewOcoRequest.getLimitClientOrderId());
        }

        if (marginAccountNewOcoRequest.getPrice() != null) {
            localVarFormParams.put(
                    "price",
                    DecimalFormatter.getFormatter().format(marginAccountNewOcoRequest.getPrice()));
        }

        if (marginAccountNewOcoRequest.getLimitIcebergQty() != null) {
            localVarFormParams.put(
                    "limitIcebergQty",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOcoRequest.getLimitIcebergQty()));
        }

        if (marginAccountNewOcoRequest.getStopClientOrderId() != null) {
            localVarFormParams.put(
                    "stopClientOrderId", marginAccountNewOcoRequest.getStopClientOrderId());
        }

        if (marginAccountNewOcoRequest.getStopPrice() != null) {
            localVarFormParams.put(
                    "stopPrice",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOcoRequest.getStopPrice()));
        }

        if (marginAccountNewOcoRequest.getStopLimitPrice() != null) {
            localVarFormParams.put(
                    "stopLimitPrice",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOcoRequest.getStopLimitPrice()));
        }

        if (marginAccountNewOcoRequest.getStopIcebergQty() != null) {
            localVarFormParams.put(
                    "stopIcebergQty",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOcoRequest.getStopIcebergQty()));
        }

        if (marginAccountNewOcoRequest.getStopLimitTimeInForce() != null) {
            localVarFormParams.put(
                    "stopLimitTimeInForce", marginAccountNewOcoRequest.getStopLimitTimeInForce());
        }

        if (marginAccountNewOcoRequest.getNewOrderRespType() != null) {
            localVarFormParams.put(
                    "newOrderRespType", marginAccountNewOcoRequest.getNewOrderRespType());
        }

        if (marginAccountNewOcoRequest.getSideEffectType() != null) {
            localVarFormParams.put(
                    "sideEffectType", marginAccountNewOcoRequest.getSideEffectType());
        }

        if (marginAccountNewOcoRequest.getSelfTradePreventionMode() != null) {
            localVarFormParams.put(
                    "selfTradePreventionMode",
                    marginAccountNewOcoRequest.getSelfTradePreventionMode());
        }

        if (marginAccountNewOcoRequest.getAutoRepayAtCancel() != null) {
            localVarFormParams.put(
                    "autoRepayAtCancel", marginAccountNewOcoRequest.getAutoRepayAtCancel());
        }

        if (marginAccountNewOcoRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", marginAccountNewOcoRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call marginAccountNewOcoValidateBeforeCall(
            MarginAccountNewOcoRequest marginAccountNewOcoRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {marginAccountNewOcoRequest};
            Method method =
                    this.getClass()
                            .getMethod("marginAccountNewOco", MarginAccountNewOcoRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return marginAccountNewOcoCall(marginAccountNewOcoRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Margin Account New OCO (TRADE) Send in a new OCO for a margin account * autoRepayAtCancel is
     * suggested to set as “FALSE” to keep liability unrepaid under high frequent new order/cancel
     * order execution Weight: 6(UID)
     *
     * @param marginAccountNewOcoRequest (required)
     * @return ApiResponse&lt;MarginAccountNewOcoResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account New OCO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Margin-Account-New-OCO">Margin
     *     Account New OCO (TRADE) Documentation</a>
     */
    public ApiResponse<MarginAccountNewOcoResponse> marginAccountNewOco(
            @Valid @NotNull MarginAccountNewOcoRequest marginAccountNewOcoRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                marginAccountNewOcoValidateBeforeCall(marginAccountNewOcoRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<MarginAccountNewOcoResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for marginAccountNewOrder
     *
     * @param marginAccountNewOrderRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account New Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Margin-Account-New-Order">Margin
     *     Account New Order (TRADE) Documentation</a>
     */
    private okhttp3.Call marginAccountNewOrderCall(
            MarginAccountNewOrderRequest marginAccountNewOrderRequest) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/order";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (marginAccountNewOrderRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", marginAccountNewOrderRequest.getSymbol());
        }

        if (marginAccountNewOrderRequest.getIsIsolated() != null) {
            localVarFormParams.put("isIsolated", marginAccountNewOrderRequest.getIsIsolated());
        }

        if (marginAccountNewOrderRequest.getSide() != null) {
            localVarFormParams.put("side", marginAccountNewOrderRequest.getSide());
        }

        if (marginAccountNewOrderRequest.getType() != null) {
            localVarFormParams.put("type", marginAccountNewOrderRequest.getType());
        }

        if (marginAccountNewOrderRequest.getQuantity() != null) {
            localVarFormParams.put(
                    "quantity",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOrderRequest.getQuantity()));
        }

        if (marginAccountNewOrderRequest.getQuoteOrderQty() != null) {
            localVarFormParams.put(
                    "quoteOrderQty",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOrderRequest.getQuoteOrderQty()));
        }

        if (marginAccountNewOrderRequest.getPrice() != null) {
            localVarFormParams.put(
                    "price",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOrderRequest.getPrice()));
        }

        if (marginAccountNewOrderRequest.getStopPrice() != null) {
            localVarFormParams.put(
                    "stopPrice",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOrderRequest.getStopPrice()));
        }

        if (marginAccountNewOrderRequest.getNewClientOrderId() != null) {
            localVarFormParams.put(
                    "newClientOrderId", marginAccountNewOrderRequest.getNewClientOrderId());
        }

        if (marginAccountNewOrderRequest.getIcebergQty() != null) {
            localVarFormParams.put(
                    "icebergQty",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOrderRequest.getIcebergQty()));
        }

        if (marginAccountNewOrderRequest.getNewOrderRespType() != null) {
            localVarFormParams.put(
                    "newOrderRespType", marginAccountNewOrderRequest.getNewOrderRespType());
        }

        if (marginAccountNewOrderRequest.getSideEffectType() != null) {
            localVarFormParams.put(
                    "sideEffectType", marginAccountNewOrderRequest.getSideEffectType());
        }

        if (marginAccountNewOrderRequest.getTimeInForce() != null) {
            localVarFormParams.put("timeInForce", marginAccountNewOrderRequest.getTimeInForce());
        }

        if (marginAccountNewOrderRequest.getSelfTradePreventionMode() != null) {
            localVarFormParams.put(
                    "selfTradePreventionMode",
                    marginAccountNewOrderRequest.getSelfTradePreventionMode());
        }

        if (marginAccountNewOrderRequest.getAutoRepayAtCancel() != null) {
            localVarFormParams.put(
                    "autoRepayAtCancel", marginAccountNewOrderRequest.getAutoRepayAtCancel());
        }

        if (marginAccountNewOrderRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", marginAccountNewOrderRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call marginAccountNewOrderValidateBeforeCall(
            MarginAccountNewOrderRequest marginAccountNewOrderRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {marginAccountNewOrderRequest};
            Method method =
                    this.getClass()
                            .getMethod("marginAccountNewOrder", MarginAccountNewOrderRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return marginAccountNewOrderCall(marginAccountNewOrderRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Margin Account New Order (TRADE) Post a new order for margin account. * autoRepayAtCancel is
     * suggested to set as “FALSE” to keep liability unrepaid under high frequent new order/cancel
     * order execution Weight: 6(UID)
     *
     * @param marginAccountNewOrderRequest (required)
     * @return ApiResponse&lt;MarginAccountNewOrderResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account New Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Margin-Account-New-Order">Margin
     *     Account New Order (TRADE) Documentation</a>
     */
    public ApiResponse<MarginAccountNewOrderResponse> marginAccountNewOrder(
            @Valid @NotNull MarginAccountNewOrderRequest marginAccountNewOrderRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                marginAccountNewOrderValidateBeforeCall(marginAccountNewOrderRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<MarginAccountNewOrderResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for marginAccountNewOto
     *
     * @param marginAccountNewOtoRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account New OTO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Margin-Account-New-OTO">Margin
     *     Account New OTO (TRADE) Documentation</a>
     */
    private okhttp3.Call marginAccountNewOtoCall(
            MarginAccountNewOtoRequest marginAccountNewOtoRequest) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/order/oto";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (marginAccountNewOtoRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", marginAccountNewOtoRequest.getSymbol());
        }

        if (marginAccountNewOtoRequest.getIsIsolated() != null) {
            localVarFormParams.put("isIsolated", marginAccountNewOtoRequest.getIsIsolated());
        }

        if (marginAccountNewOtoRequest.getListClientOrderId() != null) {
            localVarFormParams.put(
                    "listClientOrderId", marginAccountNewOtoRequest.getListClientOrderId());
        }

        if (marginAccountNewOtoRequest.getNewOrderRespType() != null) {
            localVarFormParams.put(
                    "newOrderRespType", marginAccountNewOtoRequest.getNewOrderRespType());
        }

        if (marginAccountNewOtoRequest.getSideEffectType() != null) {
            localVarFormParams.put(
                    "sideEffectType", marginAccountNewOtoRequest.getSideEffectType());
        }

        if (marginAccountNewOtoRequest.getSelfTradePreventionMode() != null) {
            localVarFormParams.put(
                    "selfTradePreventionMode",
                    marginAccountNewOtoRequest.getSelfTradePreventionMode());
        }

        if (marginAccountNewOtoRequest.getAutoRepayAtCancel() != null) {
            localVarFormParams.put(
                    "autoRepayAtCancel", marginAccountNewOtoRequest.getAutoRepayAtCancel());
        }

        if (marginAccountNewOtoRequest.getWorkingType() != null) {
            localVarFormParams.put("workingType", marginAccountNewOtoRequest.getWorkingType());
        }

        if (marginAccountNewOtoRequest.getWorkingSide() != null) {
            localVarFormParams.put("workingSide", marginAccountNewOtoRequest.getWorkingSide());
        }

        if (marginAccountNewOtoRequest.getWorkingClientOrderId() != null) {
            localVarFormParams.put(
                    "workingClientOrderId", marginAccountNewOtoRequest.getWorkingClientOrderId());
        }

        if (marginAccountNewOtoRequest.getWorkingPrice() != null) {
            localVarFormParams.put(
                    "workingPrice",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOtoRequest.getWorkingPrice()));
        }

        if (marginAccountNewOtoRequest.getWorkingQuantity() != null) {
            localVarFormParams.put(
                    "workingQuantity",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOtoRequest.getWorkingQuantity()));
        }

        if (marginAccountNewOtoRequest.getWorkingIcebergQty() != null) {
            localVarFormParams.put(
                    "workingIcebergQty",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOtoRequest.getWorkingIcebergQty()));
        }

        if (marginAccountNewOtoRequest.getWorkingTimeInForce() != null) {
            localVarFormParams.put(
                    "workingTimeInForce", marginAccountNewOtoRequest.getWorkingTimeInForce());
        }

        if (marginAccountNewOtoRequest.getPendingType() != null) {
            localVarFormParams.put("pendingType", marginAccountNewOtoRequest.getPendingType());
        }

        if (marginAccountNewOtoRequest.getPendingSide() != null) {
            localVarFormParams.put("pendingSide", marginAccountNewOtoRequest.getPendingSide());
        }

        if (marginAccountNewOtoRequest.getPendingClientOrderId() != null) {
            localVarFormParams.put(
                    "pendingClientOrderId", marginAccountNewOtoRequest.getPendingClientOrderId());
        }

        if (marginAccountNewOtoRequest.getPendingPrice() != null) {
            localVarFormParams.put(
                    "pendingPrice",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOtoRequest.getPendingPrice()));
        }

        if (marginAccountNewOtoRequest.getPendingStopPrice() != null) {
            localVarFormParams.put(
                    "pendingStopPrice",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOtoRequest.getPendingStopPrice()));
        }

        if (marginAccountNewOtoRequest.getPendingTrailingDelta() != null) {
            localVarFormParams.put(
                    "pendingTrailingDelta",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOtoRequest.getPendingTrailingDelta()));
        }

        if (marginAccountNewOtoRequest.getPendingQuantity() != null) {
            localVarFormParams.put(
                    "pendingQuantity",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOtoRequest.getPendingQuantity()));
        }

        if (marginAccountNewOtoRequest.getPendingIcebergQty() != null) {
            localVarFormParams.put(
                    "pendingIcebergQty",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOtoRequest.getPendingIcebergQty()));
        }

        if (marginAccountNewOtoRequest.getPendingTimeInForce() != null) {
            localVarFormParams.put(
                    "pendingTimeInForce", marginAccountNewOtoRequest.getPendingTimeInForce());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call marginAccountNewOtoValidateBeforeCall(
            MarginAccountNewOtoRequest marginAccountNewOtoRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {marginAccountNewOtoRequest};
            Method method =
                    this.getClass()
                            .getMethod("marginAccountNewOto", MarginAccountNewOtoRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return marginAccountNewOtoCall(marginAccountNewOtoRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Margin Account New OTO (TRADE) Post a new OTO order for margin account: - An OTO
     * (One-Triggers-the-Other) is an order list comprised of 2 orders. - The first order is called
     * the **working order** and must be &#x60;LIMIT&#x60; or &#x60;LIMIT_MAKER&#x60;. Initially,
     * only the working order goes on the order book. - The second order is called the **pending
     * order**. It can be any order type except for &#x60;MARKET&#x60; orders using parameter
     * &#x60;quoteOrderQty&#x60;. The pending order is only placed on the order book when the
     * working order gets **fully filled**. - If either the working order or the pending order is
     * cancelled individually, the other order in the order list will also be canceled or expired. -
     * When the order list is placed, if the working order gets **immediately fully filled**, the
     * placement response will show the working order as &#x60;FILLED&#x60; but the pending order
     * will still appear as &#x60;PENDING_NEW&#x60;. You need to query the status of the pending
     * order again to see its updated status. - OTOs add **2 orders** to the unfilled order count,
     * &#x60;EXCHANGE_MAX_NUM_ORDERS&#x60; filter and &#x60;MAX_NUM_ORDERS&#x60; filter. *
     * autoRepayAtCancel is suggested to set as “FALSE” to keep liability unrepaid under high
     * frequent new order/cancel order execution * Depending on the &#x60;pendingType&#x60; or
     * &#x60;workingType&#x60;, some optional parameters will become mandatory: Weight: 6(UID)
     *
     * @param marginAccountNewOtoRequest (required)
     * @return ApiResponse&lt;MarginAccountNewOtoResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account New OTO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Margin-Account-New-OTO">Margin
     *     Account New OTO (TRADE) Documentation</a>
     */
    public ApiResponse<MarginAccountNewOtoResponse> marginAccountNewOto(
            @Valid @NotNull MarginAccountNewOtoRequest marginAccountNewOtoRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                marginAccountNewOtoValidateBeforeCall(marginAccountNewOtoRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<MarginAccountNewOtoResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for marginAccountNewOtoco
     *
     * @param marginAccountNewOtocoRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account New OTOCO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Margin-Account-New-OTOCO">Margin
     *     Account New OTOCO (TRADE) Documentation</a>
     */
    private okhttp3.Call marginAccountNewOtocoCall(
            MarginAccountNewOtocoRequest marginAccountNewOtocoRequest) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/order/otoco";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (marginAccountNewOtocoRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", marginAccountNewOtocoRequest.getSymbol());
        }

        if (marginAccountNewOtocoRequest.getIsIsolated() != null) {
            localVarFormParams.put("isIsolated", marginAccountNewOtocoRequest.getIsIsolated());
        }

        if (marginAccountNewOtocoRequest.getSideEffectType() != null) {
            localVarFormParams.put(
                    "sideEffectType", marginAccountNewOtocoRequest.getSideEffectType());
        }

        if (marginAccountNewOtocoRequest.getAutoRepayAtCancel() != null) {
            localVarFormParams.put(
                    "autoRepayAtCancel", marginAccountNewOtocoRequest.getAutoRepayAtCancel());
        }

        if (marginAccountNewOtocoRequest.getListClientOrderId() != null) {
            localVarFormParams.put(
                    "listClientOrderId", marginAccountNewOtocoRequest.getListClientOrderId());
        }

        if (marginAccountNewOtocoRequest.getNewOrderRespType() != null) {
            localVarFormParams.put(
                    "newOrderRespType", marginAccountNewOtocoRequest.getNewOrderRespType());
        }

        if (marginAccountNewOtocoRequest.getSelfTradePreventionMode() != null) {
            localVarFormParams.put(
                    "selfTradePreventionMode",
                    marginAccountNewOtocoRequest.getSelfTradePreventionMode());
        }

        if (marginAccountNewOtocoRequest.getWorkingType() != null) {
            localVarFormParams.put("workingType", marginAccountNewOtocoRequest.getWorkingType());
        }

        if (marginAccountNewOtocoRequest.getWorkingSide() != null) {
            localVarFormParams.put("workingSide", marginAccountNewOtocoRequest.getWorkingSide());
        }

        if (marginAccountNewOtocoRequest.getWorkingClientOrderId() != null) {
            localVarFormParams.put(
                    "workingClientOrderId", marginAccountNewOtocoRequest.getWorkingClientOrderId());
        }

        if (marginAccountNewOtocoRequest.getWorkingPrice() != null) {
            localVarFormParams.put(
                    "workingPrice",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOtocoRequest.getWorkingPrice()));
        }

        if (marginAccountNewOtocoRequest.getWorkingQuantity() != null) {
            localVarFormParams.put(
                    "workingQuantity",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOtocoRequest.getWorkingQuantity()));
        }

        if (marginAccountNewOtocoRequest.getWorkingIcebergQty() != null) {
            localVarFormParams.put(
                    "workingIcebergQty",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOtocoRequest.getWorkingIcebergQty()));
        }

        if (marginAccountNewOtocoRequest.getWorkingTimeInForce() != null) {
            localVarFormParams.put(
                    "workingTimeInForce", marginAccountNewOtocoRequest.getWorkingTimeInForce());
        }

        if (marginAccountNewOtocoRequest.getPendingSide() != null) {
            localVarFormParams.put("pendingSide", marginAccountNewOtocoRequest.getPendingSide());
        }

        if (marginAccountNewOtocoRequest.getPendingQuantity() != null) {
            localVarFormParams.put(
                    "pendingQuantity",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOtocoRequest.getPendingQuantity()));
        }

        if (marginAccountNewOtocoRequest.getPendingAboveType() != null) {
            localVarFormParams.put(
                    "pendingAboveType", marginAccountNewOtocoRequest.getPendingAboveType());
        }

        if (marginAccountNewOtocoRequest.getPendingAboveClientOrderId() != null) {
            localVarFormParams.put(
                    "pendingAboveClientOrderId",
                    marginAccountNewOtocoRequest.getPendingAboveClientOrderId());
        }

        if (marginAccountNewOtocoRequest.getPendingAbovePrice() != null) {
            localVarFormParams.put(
                    "pendingAbovePrice",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOtocoRequest.getPendingAbovePrice()));
        }

        if (marginAccountNewOtocoRequest.getPendingAboveStopPrice() != null) {
            localVarFormParams.put(
                    "pendingAboveStopPrice",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOtocoRequest.getPendingAboveStopPrice()));
        }

        if (marginAccountNewOtocoRequest.getPendingAboveTrailingDelta() != null) {
            localVarFormParams.put(
                    "pendingAboveTrailingDelta",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOtocoRequest.getPendingAboveTrailingDelta()));
        }

        if (marginAccountNewOtocoRequest.getPendingAboveIcebergQty() != null) {
            localVarFormParams.put(
                    "pendingAboveIcebergQty",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOtocoRequest.getPendingAboveIcebergQty()));
        }

        if (marginAccountNewOtocoRequest.getPendingAboveTimeInForce() != null) {
            localVarFormParams.put(
                    "pendingAboveTimeInForce",
                    marginAccountNewOtocoRequest.getPendingAboveTimeInForce());
        }

        if (marginAccountNewOtocoRequest.getPendingBelowType() != null) {
            localVarFormParams.put(
                    "pendingBelowType", marginAccountNewOtocoRequest.getPendingBelowType());
        }

        if (marginAccountNewOtocoRequest.getPendingBelowClientOrderId() != null) {
            localVarFormParams.put(
                    "pendingBelowClientOrderId",
                    marginAccountNewOtocoRequest.getPendingBelowClientOrderId());
        }

        if (marginAccountNewOtocoRequest.getPendingBelowPrice() != null) {
            localVarFormParams.put(
                    "pendingBelowPrice",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOtocoRequest.getPendingBelowPrice()));
        }

        if (marginAccountNewOtocoRequest.getPendingBelowStopPrice() != null) {
            localVarFormParams.put(
                    "pendingBelowStopPrice",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOtocoRequest.getPendingBelowStopPrice()));
        }

        if (marginAccountNewOtocoRequest.getPendingBelowTrailingDelta() != null) {
            localVarFormParams.put(
                    "pendingBelowTrailingDelta",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOtocoRequest.getPendingBelowTrailingDelta()));
        }

        if (marginAccountNewOtocoRequest.getPendingBelowIcebergQty() != null) {
            localVarFormParams.put(
                    "pendingBelowIcebergQty",
                    DecimalFormatter.getFormatter()
                            .format(marginAccountNewOtocoRequest.getPendingBelowIcebergQty()));
        }

        if (marginAccountNewOtocoRequest.getPendingBelowTimeInForce() != null) {
            localVarFormParams.put(
                    "pendingBelowTimeInForce",
                    marginAccountNewOtocoRequest.getPendingBelowTimeInForce());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call marginAccountNewOtocoValidateBeforeCall(
            MarginAccountNewOtocoRequest marginAccountNewOtocoRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {marginAccountNewOtocoRequest};
            Method method =
                    this.getClass()
                            .getMethod("marginAccountNewOtoco", MarginAccountNewOtocoRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return marginAccountNewOtocoCall(marginAccountNewOtocoRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Margin Account New OTOCO (TRADE) Post a new OTOCO order for margin account： - An OTOCO
     * (One-Triggers-One-Cancels-the-Other) is an order list comprised of 3 orders. - The first
     * order is called the **working order** and must be &#x60;LIMIT&#x60; or
     * &#x60;LIMIT_MAKER&#x60;. Initially, only the working order goes on the order book. - The
     * behavior of the working order is the same as the OTO. - OTOCO has 2 pending orders (pending
     * above and pending below), forming an OCO pair. The pending orders are only placed on the
     * order book when the working order gets **fully filled**. - The rules of the pending above and
     * pending below follow the same rules as the [Order List
     * OCO](https://developers.binance.com/docs/margin_trading/trade/Margin-Account-New-OCO). -
     * OTOCOs add **3 orders** against the unfilled order count, &#x60;EXCHANGE_MAX_NUM_ORDERS&#x60;
     * filter, and &#x60;MAX_NUM_ORDERS&#x60; filter. * autoRepayAtCancel is suggested to set as
     * “FALSE” to keep liability unrepaid under high frequent new order/cancel order execution *
     * Depending on the &#x60;pendingAboveType&#x60;/&#x60;pendingBelowType&#x60; or
     * &#x60;workingType&#x60;, some optional parameters will become mandatory: Weight: 6(UID)
     *
     * @param marginAccountNewOtocoRequest (required)
     * @return ApiResponse&lt;MarginAccountNewOtocoResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account New OTOCO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Margin-Account-New-OTOCO">Margin
     *     Account New OTOCO (TRADE) Documentation</a>
     */
    public ApiResponse<MarginAccountNewOtocoResponse> marginAccountNewOtoco(
            @Valid @NotNull MarginAccountNewOtocoRequest marginAccountNewOtocoRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                marginAccountNewOtocoValidateBeforeCall(marginAccountNewOtocoRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<MarginAccountNewOtocoResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for marginManualLiquidation
     *
     * @param marginManualLiquidationRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Manual Liquidation </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Margin-Manual-Liquidation">Margin
     *     Manual Liquidation(MARGIN) Documentation</a>
     */
    private okhttp3.Call marginManualLiquidationCall(
            MarginManualLiquidationRequest marginManualLiquidationRequest) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/manual-liquidation";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (marginManualLiquidationRequest.getType() != null) {
            localVarFormParams.put("type", marginManualLiquidationRequest.getType());
        }

        if (marginManualLiquidationRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", marginManualLiquidationRequest.getSymbol());
        }

        if (marginManualLiquidationRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", marginManualLiquidationRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call marginManualLiquidationValidateBeforeCall(
            MarginManualLiquidationRequest marginManualLiquidationRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {marginManualLiquidationRequest};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "marginManualLiquidation",
                                    MarginManualLiquidationRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return marginManualLiquidationCall(marginManualLiquidationRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Margin Manual Liquidation(MARGIN) Margin Manual Liquidation * This endpoint can support Cross
     * Margin Classic Mode and Pro Mode. * And only support Isolated Margin for restricted region.
     * Weight: 3000
     *
     * @param marginManualLiquidationRequest (required)
     * @return ApiResponse&lt;MarginManualLiquidationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Manual Liquidation </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Margin-Manual-Liquidation">Margin
     *     Manual Liquidation(MARGIN) Documentation</a>
     */
    public ApiResponse<MarginManualLiquidationResponse> marginManualLiquidation(
            @Valid @NotNull MarginManualLiquidationRequest marginManualLiquidationRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                marginManualLiquidationValidateBeforeCall(marginManualLiquidationRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<MarginManualLiquidationResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for queryCurrentMarginOrderCountUsage
     *
     * @param isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default
     *     \&quot;FALSE\&quot; (optional)
     * @param symbol isolated margin pair (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Current Margin Order Count Usage </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Query-Current-Margin-Order-Count-Usage">Query
     *     Current Margin Order Count Usage (TRADE) Documentation</a>
     */
    private okhttp3.Call queryCurrentMarginOrderCountUsageCall(
            String isIsolated, String symbol, Long recvWindow) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/rateLimit/order";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (isIsolated != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("isIsolated", isIsolated));
        }

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryCurrentMarginOrderCountUsageValidateBeforeCall(
            String isIsolated, String symbol, Long recvWindow) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {isIsolated, symbol, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "queryCurrentMarginOrderCountUsage",
                                    String.class,
                                    String.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return queryCurrentMarginOrderCountUsageCall(isIsolated, symbol, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Query Current Margin Order Count Usage (TRADE) Displays the user&#39;s current margin order
     * count usage for all intervals. Weight: 20(IP)
     *
     * @param isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default
     *     \&quot;FALSE\&quot; (optional)
     * @param symbol isolated margin pair (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;QueryCurrentMarginOrderCountUsageResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Current Margin Order Count Usage </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Query-Current-Margin-Order-Count-Usage">Query
     *     Current Margin Order Count Usage (TRADE) Documentation</a>
     */
    public ApiResponse<QueryCurrentMarginOrderCountUsageResponse> queryCurrentMarginOrderCountUsage(
            String isIsolated, String symbol, Long recvWindow) throws ApiException {
        okhttp3.Call localVarCall =
                queryCurrentMarginOrderCountUsageValidateBeforeCall(isIsolated, symbol, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<QueryCurrentMarginOrderCountUsageResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for queryMarginAccountsAllOco
     *
     * @param isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default
     *     \&quot;FALSE\&quot; (optional)
     * @param symbol isolated margin pair (optional)
     * @param fromId 如设置fromId, 将返回id &gt; fromId的数据。否则将返回最新数据 (optional)
     * @param startTime 只支持查询最近90天的数据 (optional)
     * @param endTime (optional)
     * @param limit Default Value: 500; Max Value: 1000 (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account&#39;s all OCO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-all-OCO">Query
     *     Margin Account&#39;s all OCO (USER_DATA) Documentation</a>
     */
    private okhttp3.Call queryMarginAccountsAllOcoCall(
            String isIsolated,
            String symbol,
            Long fromId,
            Long startTime,
            Long endTime,
            Long limit,
            Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/allOrderList";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (isIsolated != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("isIsolated", isIsolated));
        }

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (fromId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromId", fromId));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryMarginAccountsAllOcoValidateBeforeCall(
            String isIsolated,
            String symbol,
            Long fromId,
            Long startTime,
            Long endTime,
            Long limit,
            Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {
                isIsolated, symbol, fromId, startTime, endTime, limit, recvWindow
            };
            Method method =
                    this.getClass()
                            .getMethod(
                                    "queryMarginAccountsAllOco",
                                    String.class,
                                    String.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return queryMarginAccountsAllOcoCall(
                        isIsolated, symbol, fromId, startTime, endTime, limit, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Query Margin Account&#39;s all OCO (USER_DATA) Retrieves all OCO for a specific margin
     * account based on provided optional parameters Weight: 200(IP)
     *
     * @param isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default
     *     \&quot;FALSE\&quot; (optional)
     * @param symbol isolated margin pair (optional)
     * @param fromId 如设置fromId, 将返回id &gt; fromId的数据。否则将返回最新数据 (optional)
     * @param startTime 只支持查询最近90天的数据 (optional)
     * @param endTime (optional)
     * @param limit Default Value: 500; Max Value: 1000 (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;QueryMarginAccountsAllOcoResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account&#39;s all OCO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-all-OCO">Query
     *     Margin Account&#39;s all OCO (USER_DATA) Documentation</a>
     */
    public ApiResponse<QueryMarginAccountsAllOcoResponse> queryMarginAccountsAllOco(
            String isIsolated,
            String symbol,
            Long fromId,
            Long startTime,
            Long endTime,
            Long limit,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                queryMarginAccountsAllOcoValidateBeforeCall(
                        isIsolated, symbol, fromId, startTime, endTime, limit, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<QueryMarginAccountsAllOcoResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for queryMarginAccountsAllOrders
     *
     * @param symbol (required)
     * @param isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default
     *     \&quot;FALSE\&quot; (optional)
     * @param orderId (optional)
     * @param startTime 只支持查询最近90天的数据 (optional)
     * @param endTime (optional)
     * @param limit Default Value: 500; Max Value: 1000 (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account&#39;s All Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-All-Orders">Query
     *     Margin Account&#39;s All Orders (USER_DATA) Documentation</a>
     */
    private okhttp3.Call queryMarginAccountsAllOrdersCall(
            String symbol,
            String isIsolated,
            Long orderId,
            Long startTime,
            Long endTime,
            Long limit,
            Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/allOrders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (isIsolated != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("isIsolated", isIsolated));
        }

        if (orderId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderId", orderId));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryMarginAccountsAllOrdersValidateBeforeCall(
            String symbol,
            String isIsolated,
            Long orderId,
            Long startTime,
            Long endTime,
            Long limit,
            Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {
                symbol, isIsolated, orderId, startTime, endTime, limit, recvWindow
            };
            Method method =
                    this.getClass()
                            .getMethod(
                                    "queryMarginAccountsAllOrders",
                                    String.class,
                                    String.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return queryMarginAccountsAllOrdersCall(
                        symbol, isIsolated, orderId, startTime, endTime, limit, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Query Margin Account&#39;s All Orders (USER_DATA) Query Margin Account&#39;s All Orders * If
     * orderId is set, it will get orders &gt;&#x3D; that orderId. Otherwise the orders within 24
     * hours are returned. * For some historical orders cummulativeQuoteQty will be &lt; 0, meaning
     * the data is not available at this time. * Less than 24 hours between startTime and endTime.
     * Weight: 200(IP)
     *
     * @param symbol (required)
     * @param isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default
     *     \&quot;FALSE\&quot; (optional)
     * @param orderId (optional)
     * @param startTime 只支持查询最近90天的数据 (optional)
     * @param endTime (optional)
     * @param limit Default Value: 500; Max Value: 1000 (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;QueryMarginAccountsAllOrdersResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account&#39;s All Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-All-Orders">Query
     *     Margin Account&#39;s All Orders (USER_DATA) Documentation</a>
     */
    public ApiResponse<QueryMarginAccountsAllOrdersResponse> queryMarginAccountsAllOrders(
            @NotNull String symbol,
            String isIsolated,
            Long orderId,
            Long startTime,
            Long endTime,
            Long limit,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                queryMarginAccountsAllOrdersValidateBeforeCall(
                        symbol, isIsolated, orderId, startTime, endTime, limit, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<QueryMarginAccountsAllOrdersResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for queryMarginAccountsOco
     *
     * @param isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default
     *     \&quot;FALSE\&quot; (optional)
     * @param symbol isolated margin pair (optional)
     * @param orderListId Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be
     *     provided (optional)
     * @param origClientOrderId (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account&#39;s OCO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-OCO">Query
     *     Margin Account&#39;s OCO (USER_DATA) Documentation</a>
     */
    private okhttp3.Call queryMarginAccountsOcoCall(
            String isIsolated,
            String symbol,
            Long orderListId,
            String origClientOrderId,
            Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/orderList";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (isIsolated != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("isIsolated", isIsolated));
        }

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (orderListId != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("orderListId", orderListId));
        }

        if (origClientOrderId != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("origClientOrderId", origClientOrderId));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryMarginAccountsOcoValidateBeforeCall(
            String isIsolated,
            String symbol,
            Long orderListId,
            String origClientOrderId,
            Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {
                isIsolated, symbol, orderListId, origClientOrderId, recvWindow
            };
            Method method =
                    this.getClass()
                            .getMethod(
                                    "queryMarginAccountsOco",
                                    String.class,
                                    String.class,
                                    Long.class,
                                    String.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return queryMarginAccountsOcoCall(
                        isIsolated, symbol, orderListId, origClientOrderId, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Query Margin Account&#39;s OCO (USER_DATA) Retrieves a specific OCO based on provided
     * optional parameters Weight: 10(IP)
     *
     * @param isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default
     *     \&quot;FALSE\&quot; (optional)
     * @param symbol isolated margin pair (optional)
     * @param orderListId Either &#x60;orderListId&#x60; or &#x60;listClientOrderId&#x60; must be
     *     provided (optional)
     * @param origClientOrderId (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;QueryMarginAccountsOcoResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account&#39;s OCO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-OCO">Query
     *     Margin Account&#39;s OCO (USER_DATA) Documentation</a>
     */
    public ApiResponse<QueryMarginAccountsOcoResponse> queryMarginAccountsOco(
            String isIsolated,
            String symbol,
            Long orderListId,
            String origClientOrderId,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                queryMarginAccountsOcoValidateBeforeCall(
                        isIsolated, symbol, orderListId, origClientOrderId, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<QueryMarginAccountsOcoResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for queryMarginAccountsOpenOco
     *
     * @param isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default
     *     \&quot;FALSE\&quot; (optional)
     * @param symbol isolated margin pair (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account&#39;s Open OCO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-Open-OCO">Query
     *     Margin Account&#39;s Open OCO (USER_DATA) Documentation</a>
     */
    private okhttp3.Call queryMarginAccountsOpenOcoCall(
            String isIsolated, String symbol, Long recvWindow) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/openOrderList";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (isIsolated != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("isIsolated", isIsolated));
        }

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryMarginAccountsOpenOcoValidateBeforeCall(
            String isIsolated, String symbol, Long recvWindow) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {isIsolated, symbol, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "queryMarginAccountsOpenOco",
                                    String.class,
                                    String.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return queryMarginAccountsOpenOcoCall(isIsolated, symbol, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Query Margin Account&#39;s Open OCO (USER_DATA) Query Margin Account&#39;s Open OCO Weight:
     * 10(IP)
     *
     * @param isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default
     *     \&quot;FALSE\&quot; (optional)
     * @param symbol isolated margin pair (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;QueryMarginAccountsOpenOcoResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account&#39;s Open OCO </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-Open-OCO">Query
     *     Margin Account&#39;s Open OCO (USER_DATA) Documentation</a>
     */
    public ApiResponse<QueryMarginAccountsOpenOcoResponse> queryMarginAccountsOpenOco(
            String isIsolated, String symbol, Long recvWindow) throws ApiException {
        okhttp3.Call localVarCall =
                queryMarginAccountsOpenOcoValidateBeforeCall(isIsolated, symbol, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<QueryMarginAccountsOpenOcoResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for queryMarginAccountsOpenOrders
     *
     * @param symbol isolated margin pair (optional)
     * @param isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default
     *     \&quot;FALSE\&quot; (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account&#39;s Open Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-Open-Orders">Query
     *     Margin Account&#39;s Open Orders (USER_DATA) Documentation</a>
     */
    private okhttp3.Call queryMarginAccountsOpenOrdersCall(
            String symbol, String isIsolated, Long recvWindow) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/openOrders";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (isIsolated != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("isIsolated", isIsolated));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryMarginAccountsOpenOrdersValidateBeforeCall(
            String symbol, String isIsolated, Long recvWindow) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, isIsolated, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "queryMarginAccountsOpenOrders",
                                    String.class,
                                    String.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return queryMarginAccountsOpenOrdersCall(symbol, isIsolated, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Query Margin Account&#39;s Open Orders (USER_DATA) Query Margin Account&#39;s Open Orders *
     * If the symbol is not sent, orders for all symbols will be returned in an array. * When all
     * symbols are returned, the number of requests counted against the rate limiter is equal to the
     * number of symbols currently trading on the exchange. * If isIsolated
     * &#x3D;\&quot;TRUE\&quot;, symbol must be sent. Weight: 10(IP)
     *
     * @param symbol isolated margin pair (optional)
     * @param isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default
     *     \&quot;FALSE\&quot; (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;QueryMarginAccountsOpenOrdersResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account&#39;s Open Orders </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-Open-Orders">Query
     *     Margin Account&#39;s Open Orders (USER_DATA) Documentation</a>
     */
    public ApiResponse<QueryMarginAccountsOpenOrdersResponse> queryMarginAccountsOpenOrders(
            String symbol, String isIsolated, Long recvWindow) throws ApiException {
        okhttp3.Call localVarCall =
                queryMarginAccountsOpenOrdersValidateBeforeCall(symbol, isIsolated, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<QueryMarginAccountsOpenOrdersResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for queryMarginAccountsOrder
     *
     * @param symbol (required)
     * @param isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default
     *     \&quot;FALSE\&quot; (optional)
     * @param orderId (optional)
     * @param origClientOrderId (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account&#39;s Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-Order">Query
     *     Margin Account&#39;s Order (USER_DATA) Documentation</a>
     */
    private okhttp3.Call queryMarginAccountsOrderCall(
            String symbol,
            String isIsolated,
            Long orderId,
            String origClientOrderId,
            Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/order";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (isIsolated != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("isIsolated", isIsolated));
        }

        if (orderId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderId", orderId));
        }

        if (origClientOrderId != null) {
            localVarQueryParams.addAll(
                    localVarApiClient.parameterToPair("origClientOrderId", origClientOrderId));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryMarginAccountsOrderValidateBeforeCall(
            String symbol,
            String isIsolated,
            Long orderId,
            String origClientOrderId,
            Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, isIsolated, orderId, origClientOrderId, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "queryMarginAccountsOrder",
                                    String.class,
                                    String.class,
                                    Long.class,
                                    String.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return queryMarginAccountsOrderCall(
                        symbol, isIsolated, orderId, origClientOrderId, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Query Margin Account&#39;s Order (USER_DATA) Query Margin Account&#39;s Order * Either
     * orderId or origClientOrderId must be sent. * For some historical orders cummulativeQuoteQty
     * will be &lt; 0, meaning the data is not available at this time. Weight: 10(IP)
     *
     * @param symbol (required)
     * @param isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default
     *     \&quot;FALSE\&quot; (optional)
     * @param orderId (optional)
     * @param origClientOrderId (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;QueryMarginAccountsOrderResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account&#39;s Order </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-Order">Query
     *     Margin Account&#39;s Order (USER_DATA) Documentation</a>
     */
    public ApiResponse<QueryMarginAccountsOrderResponse> queryMarginAccountsOrder(
            @NotNull String symbol,
            String isIsolated,
            Long orderId,
            String origClientOrderId,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                queryMarginAccountsOrderValidateBeforeCall(
                        symbol, isIsolated, orderId, origClientOrderId, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<QueryMarginAccountsOrderResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for queryMarginAccountsTradeList
     *
     * @param symbol (required)
     * @param isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default
     *     \&quot;FALSE\&quot; (optional)
     * @param orderId (optional)
     * @param startTime 只支持查询最近90天的数据 (optional)
     * @param endTime (optional)
     * @param fromId 如设置fromId, 将返回id &gt; fromId的数据。否则将返回最新数据 (optional)
     * @param limit Default Value: 500; Max Value: 1000 (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account&#39;s Trade List </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-Trade-List">Query
     *     Margin Account&#39;s Trade List (USER_DATA) Documentation</a>
     */
    private okhttp3.Call queryMarginAccountsTradeListCall(
            String symbol,
            String isIsolated,
            Long orderId,
            Long startTime,
            Long endTime,
            Long fromId,
            Long limit,
            Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/myTrades";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (isIsolated != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("isIsolated", isIsolated));
        }

        if (orderId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("orderId", orderId));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (fromId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromId", fromId));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryMarginAccountsTradeListValidateBeforeCall(
            String symbol,
            String isIsolated,
            Long orderId,
            Long startTime,
            Long endTime,
            Long fromId,
            Long limit,
            Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {
                symbol, isIsolated, orderId, startTime, endTime, fromId, limit, recvWindow
            };
            Method method =
                    this.getClass()
                            .getMethod(
                                    "queryMarginAccountsTradeList",
                                    String.class,
                                    String.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return queryMarginAccountsTradeListCall(
                        symbol, isIsolated, orderId, startTime, endTime, fromId, limit, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Query Margin Account&#39;s Trade List (USER_DATA) Query Margin Account&#39;s Trade List * If
     * fromId is set, it will get trades &gt;&#x3D; that fromId. Otherwise the trades within 24
     * hours are returned. * Less than 24 hours between startTime and endTime. Weight: 10(IP)
     *
     * @param symbol (required)
     * @param isIsolated for isolated margin or not, \&quot;TRUE\&quot;, \&quot;FALSE\&quot;，default
     *     \&quot;FALSE\&quot; (optional)
     * @param orderId (optional)
     * @param startTime 只支持查询最近90天的数据 (optional)
     * @param endTime (optional)
     * @param fromId 如设置fromId, 将返回id &gt; fromId的数据。否则将返回最新数据 (optional)
     * @param limit Default Value: 500; Max Value: 1000 (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;QueryMarginAccountsTradeListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Margin Account&#39;s Trade List </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-Trade-List">Query
     *     Margin Account&#39;s Trade List (USER_DATA) Documentation</a>
     */
    public ApiResponse<QueryMarginAccountsTradeListResponse> queryMarginAccountsTradeList(
            @NotNull String symbol,
            String isIsolated,
            Long orderId,
            Long startTime,
            Long endTime,
            Long fromId,
            Long limit,
            Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall =
                queryMarginAccountsTradeListValidateBeforeCall(
                        symbol, isIsolated, orderId, startTime, endTime, fromId, limit, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<QueryMarginAccountsTradeListResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for querySpecialKey
     *
     * @param symbol isolated margin pair (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Special key </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Query-Special-Key-of-Low-Latency-Trading">Query
     *     Special key(Low Latency Trading)(TRADE) Documentation</a>
     */
    private okhttp3.Call querySpecialKeyCall(String symbol, Long recvWindow) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/apiKey";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call querySpecialKeyValidateBeforeCall(String symbol, Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, recvWindow};
            Method method = this.getClass().getMethod("querySpecialKey", String.class, Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return querySpecialKeyCall(symbol, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Query Special key(Low Latency Trading)(TRADE) Query Special Key Information. This only
     * applies to Special Key for Low Latency Trading. Weight: 1(UID)
     *
     * @param symbol isolated margin pair (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;QuerySpecialKeyResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Special key </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Query-Special-Key-of-Low-Latency-Trading">Query
     *     Special key(Low Latency Trading)(TRADE) Documentation</a>
     */
    public ApiResponse<QuerySpecialKeyResponse> querySpecialKey(String symbol, Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall = querySpecialKeyValidateBeforeCall(symbol, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<QuerySpecialKeyResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for querySpecialKeyList
     *
     * @param symbol isolated margin pair (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Special key List </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Query-Special-Key-List-of-Low-Latency-Trading">Query
     *     Special key List(Low Latency Trading)(TRADE) Documentation</a>
     */
    private okhttp3.Call querySpecialKeyListCall(String symbol, Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/api-key-list";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call querySpecialKeyListValidateBeforeCall(String symbol, Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, recvWindow};
            Method method =
                    this.getClass().getMethod("querySpecialKeyList", String.class, Long.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return querySpecialKeyListCall(symbol, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Query Special key List(Low Latency Trading)(TRADE) This only applies to Special Key for Low
     * Latency Trading. Weight: 1(UID)
     *
     * @param symbol isolated margin pair (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;QuerySpecialKeyListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Special key List </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Query-Special-Key-List-of-Low-Latency-Trading">Query
     *     Special key List(Low Latency Trading)(TRADE) Documentation</a>
     */
    public ApiResponse<QuerySpecialKeyListResponse> querySpecialKeyList(
            String symbol, Long recvWindow) throws ApiException {
        okhttp3.Call localVarCall = querySpecialKeyListValidateBeforeCall(symbol, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<QuerySpecialKeyListResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for smallLiabilityExchange
     *
     * @param smallLiabilityExchangeRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Small-Liability-Exchange">Small
     *     Liability Exchange (MARGIN) Documentation</a>
     */
    private okhttp3.Call smallLiabilityExchangeCall(
            SmallLiabilityExchangeRequest smallLiabilityExchangeRequest) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/exchange-small-liability";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (smallLiabilityExchangeRequest.getAssetNames() != null) {
            String json = JSON.getGson().toJson(smallLiabilityExchangeRequest.getAssetNames());
            localVarFormParams.put("assetNames", json);
        }

        if (smallLiabilityExchangeRequest.getRecvWindow() != null) {
            localVarFormParams.put("recvWindow", smallLiabilityExchangeRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call smallLiabilityExchangeValidateBeforeCall(
            SmallLiabilityExchangeRequest smallLiabilityExchangeRequest) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {smallLiabilityExchangeRequest};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "smallLiabilityExchange", SmallLiabilityExchangeRequest.class);
            Set<ConstraintViolation<TradeApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return smallLiabilityExchangeCall(smallLiabilityExchangeRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Small Liability Exchange (MARGIN) Small Liability Exchange * Only convert once within 6 hours
     * * Only liability valuation less than 10 USDT are supported * The maximum number of coin is 10
     * Weight: 3000(UID)
     *
     * @param smallLiabilityExchangeRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/trade/Small-Liability-Exchange">Small
     *     Liability Exchange (MARGIN) Documentation</a>
     */
    public ApiResponse<Void> smallLiabilityExchange(
            @Valid @NotNull SmallLiabilityExchangeRequest smallLiabilityExchangeRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                smallLiabilityExchangeValidateBeforeCall(smallLiabilityExchangeRequest);
        return localVarApiClient.execute(localVarCall);
    }
}
