/*
 * Binance Margin Trading REST API
 * OpenAPI Specification for the Binance Margin Trading REST API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.binance.connector.client.margin_trading.rest.api;

import com.binance.connector.client.common.ApiClient;
import com.binance.connector.client.common.ApiException;
import com.binance.connector.client.common.ApiResponse;
import com.binance.connector.client.common.Pair;
import com.binance.connector.client.common.SystemUtil;
import com.binance.connector.client.common.configuration.ClientConfiguration;
import com.binance.connector.client.common.exception.ConstraintViolationException;
import com.binance.connector.client.margin_trading.rest.model.AdjustCrossMarginMaxLeverageRequest;
import com.binance.connector.client.margin_trading.rest.model.AdjustCrossMarginMaxLeverageResponse;
import com.binance.connector.client.margin_trading.rest.model.DisableIsolatedMarginAccountResponse;
import com.binance.connector.client.margin_trading.rest.model.EnableIsolatedMarginAccountRequest;
import com.binance.connector.client.margin_trading.rest.model.EnableIsolatedMarginAccountResponse;
import com.binance.connector.client.margin_trading.rest.model.GetBnbBurnStatusResponse;
import com.binance.connector.client.margin_trading.rest.model.GetSummaryOfMarginAccountResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryCrossIsolatedMarginCapitalFlowResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryCrossMarginAccountDetailsResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryCrossMarginFeeDataResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryEnabledIsolatedMarginAccountLimitResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryIsolatedMarginAccountInfoResponse;
import com.binance.connector.client.margin_trading.rest.model.QueryIsolatedMarginFeeDataResponse;
import com.google.gson.reflect.TypeToken;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Valid;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.constraints.*;
import jakarta.validation.executable.ExecutableValidator;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator;

public class AccountApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    private static final String USER_AGENT =
            String.format(
                    "binance-margin-trading/2.0.0 (Java/%s; %s; %s)",
                    SystemUtil.getJavaVersion(), SystemUtil.getOs(), SystemUtil.getArch());
    private static final boolean HAS_TIME_UNIT = false;

    public AccountApi(ClientConfiguration clientConfiguration) {
        this(new ApiClient(clientConfiguration));
    }

    public AccountApi(ApiClient apiClient) {
        apiClient.setUserAgent(USER_AGENT);
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for adjustCrossMarginMaxLeverage
     *
     * @param adjustCrossMarginMaxLeverageRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Adjust cross margin max leverage </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/account/Adjust-cross-margin-max-leverage">Adjust
     *     cross margin max leverage (USER_DATA) Documentation</a>
     */
    private okhttp3.Call adjustCrossMarginMaxLeverageCall(
            AdjustCrossMarginMaxLeverageRequest adjustCrossMarginMaxLeverageRequest)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/max-leverage";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (adjustCrossMarginMaxLeverageRequest.getMaxLeverage() != null) {
            localVarFormParams.put(
                    "maxLeverage", adjustCrossMarginMaxLeverageRequest.getMaxLeverage());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call adjustCrossMarginMaxLeverageValidateBeforeCall(
            AdjustCrossMarginMaxLeverageRequest adjustCrossMarginMaxLeverageRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {adjustCrossMarginMaxLeverageRequest};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "adjustCrossMarginMaxLeverage",
                                    AdjustCrossMarginMaxLeverageRequest.class);
            Set<ConstraintViolation<AccountApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return adjustCrossMarginMaxLeverageCall(adjustCrossMarginMaxLeverageRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Adjust cross margin max leverage (USER_DATA) Adjust cross margin max leverage * The margin
     * level need higher than the initial risk ratio of adjusted leverage, the initial risk ratio of
     * 3x is 1.5 , the initial risk ratio of 5x is 1.25; The detail conditions on how to switch
     * between Cross Margin Classic and Cross Margin Pro can refer to [the
     * FAQ](https://www.binance.com/en/support/faq/how-to-activate-the-cross-margin-pro-mode-on-binance-e27786da05e743a694b8c625b3bc475d).
     * Weight: 3000
     *
     * @param adjustCrossMarginMaxLeverageRequest (required)
     * @return ApiResponse&lt;AdjustCrossMarginMaxLeverageResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Adjust cross margin max leverage </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/account/Adjust-cross-margin-max-leverage">Adjust
     *     cross margin max leverage (USER_DATA) Documentation</a>
     */
    public ApiResponse<AdjustCrossMarginMaxLeverageResponse> adjustCrossMarginMaxLeverage(
            @Valid @NotNull AdjustCrossMarginMaxLeverageRequest adjustCrossMarginMaxLeverageRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                adjustCrossMarginMaxLeverageValidateBeforeCall(adjustCrossMarginMaxLeverageRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<AdjustCrossMarginMaxLeverageResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for disableIsolatedMarginAccount
     *
     * @param symbol (required)
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Disable Isolated Margin Account </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/account/Disable-Isolated-Margin-Account">Disable
     *     Isolated Margin Account (TRADE) Documentation</a>
     */
    private okhttp3.Call disableIsolatedMarginAccountCall(String symbol, Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/isolated/account";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "DELETE",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call disableIsolatedMarginAccountValidateBeforeCall(
            String symbol, Long recvWindow) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbol, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod("disableIsolatedMarginAccount", String.class, Long.class);
            Set<ConstraintViolation<AccountApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return disableIsolatedMarginAccountCall(symbol, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Disable Isolated Margin Account (TRADE) Disable isolated margin account for a specific
     * symbol. Each trading pair can only be deactivated once every 24 hours. Weight: 300(UID)
     *
     * @param symbol (required)
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;DisableIsolatedMarginAccountResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Disable Isolated Margin Account </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/account/Disable-Isolated-Margin-Account">Disable
     *     Isolated Margin Account (TRADE) Documentation</a>
     */
    public ApiResponse<DisableIsolatedMarginAccountResponse> disableIsolatedMarginAccount(
            @NotNull String symbol, Long recvWindow) throws ApiException {
        okhttp3.Call localVarCall =
                disableIsolatedMarginAccountValidateBeforeCall(symbol, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<DisableIsolatedMarginAccountResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for enableIsolatedMarginAccount
     *
     * @param enableIsolatedMarginAccountRequest (required)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Enable Isolated Margin Account </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/account/Enable-Isolated-Margin-Account">Enable
     *     Isolated Margin Account (TRADE) Documentation</a>
     */
    private okhttp3.Call enableIsolatedMarginAccountCall(
            EnableIsolatedMarginAccountRequest enableIsolatedMarginAccountRequest)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/isolated/account";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (enableIsolatedMarginAccountRequest.getSymbol() != null) {
            localVarFormParams.put("symbol", enableIsolatedMarginAccountRequest.getSymbol());
        }

        if (enableIsolatedMarginAccountRequest.getRecvWindow() != null) {
            localVarFormParams.put(
                    "recvWindow", enableIsolatedMarginAccountRequest.getRecvWindow());
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call enableIsolatedMarginAccountValidateBeforeCall(
            EnableIsolatedMarginAccountRequest enableIsolatedMarginAccountRequest)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {enableIsolatedMarginAccountRequest};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "enableIsolatedMarginAccount",
                                    EnableIsolatedMarginAccountRequest.class);
            Set<ConstraintViolation<AccountApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return enableIsolatedMarginAccountCall(enableIsolatedMarginAccountRequest);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Enable Isolated Margin Account (TRADE) Enable isolated margin account for a specific
     * symbol(Only supports activation of previously disabled accounts). Weight: 300(UID)
     *
     * @param enableIsolatedMarginAccountRequest (required)
     * @return ApiResponse&lt;EnableIsolatedMarginAccountResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Enable Isolated Margin Account </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/account/Enable-Isolated-Margin-Account">Enable
     *     Isolated Margin Account (TRADE) Documentation</a>
     */
    public ApiResponse<EnableIsolatedMarginAccountResponse> enableIsolatedMarginAccount(
            @Valid @NotNull EnableIsolatedMarginAccountRequest enableIsolatedMarginAccountRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                enableIsolatedMarginAccountValidateBeforeCall(enableIsolatedMarginAccountRequest);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<EnableIsolatedMarginAccountResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for getBnbBurnStatus
     *
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Get BNB Burn Status </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/account/Get-BNB-Burn-Status">Get
     *     BNB Burn Status (USER_DATA) Documentation</a>
     */
    private okhttp3.Call getBnbBurnStatusCall(Long recvWindow) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/bnbBurn";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getBnbBurnStatusValidateBeforeCall(Long recvWindow) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {recvWindow};
            Method method = this.getClass().getMethod("getBnbBurnStatus", Long.class);
            Set<ConstraintViolation<AccountApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return getBnbBurnStatusCall(recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Get BNB Burn Status (USER_DATA) Get BNB Burn Status Weight: 1(IP)
     *
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;GetBnbBurnStatusResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Get BNB Burn Status </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/account/Get-BNB-Burn-Status">Get
     *     BNB Burn Status (USER_DATA) Documentation</a>
     */
    public ApiResponse<GetBnbBurnStatusResponse> getBnbBurnStatus(Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall = getBnbBurnStatusValidateBeforeCall(recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<GetBnbBurnStatusResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for getSummaryOfMarginAccount
     *
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Get Summary of Margin account </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/account/Get-Summary-of-Margin-account">Get
     *     Summary of Margin account (USER_DATA) Documentation</a>
     */
    private okhttp3.Call getSummaryOfMarginAccountCall(Long recvWindow) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/tradeCoeff";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSummaryOfMarginAccountValidateBeforeCall(Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {recvWindow};
            Method method = this.getClass().getMethod("getSummaryOfMarginAccount", Long.class);
            Set<ConstraintViolation<AccountApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return getSummaryOfMarginAccountCall(recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Get Summary of Margin account (USER_DATA) Get personal margin level information Weight:
     * 10(IP)
     *
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;GetSummaryOfMarginAccountResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Get Summary of Margin account </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/account/Get-Summary-of-Margin-account">Get
     *     Summary of Margin account (USER_DATA) Documentation</a>
     */
    public ApiResponse<GetSummaryOfMarginAccountResponse> getSummaryOfMarginAccount(Long recvWindow)
            throws ApiException {
        okhttp3.Call localVarCall = getSummaryOfMarginAccountValidateBeforeCall(recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<GetSummaryOfMarginAccountResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for queryCrossIsolatedMarginCapitalFlow
     *
     * @param asset (optional)
     * @param symbol isolated margin pair (optional)
     * @param type Transfer Type: ROLL_IN, ROLL_OUT (optional)
     * @param startTime 只支持查询最近90天的数据 (optional)
     * @param endTime (optional)
     * @param fromId 如设置fromId, 将返回id &gt; fromId的数据。否则将返回最新数据 (optional)
     * @param limit Default Value: 500; Max Value: 1000 (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cross Isolated Margin Capital Flow </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/account/Query-Cross-Isolated-Margin-Capital-Flow">Query
     *     Cross Isolated Margin Capital Flow (USER_DATA) Documentation</a>
     */
    private okhttp3.Call queryCrossIsolatedMarginCapitalFlowCall(
            String asset,
            String symbol,
            String type,
            Long startTime,
            Long endTime,
            Long fromId,
            Long limit,
            Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/capital-flow";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (asset != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("asset", asset));
        }

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (type != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("type", type));
        }

        if (startTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("startTime", startTime));
        }

        if (endTime != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("endTime", endTime));
        }

        if (fromId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromId", fromId));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryCrossIsolatedMarginCapitalFlowValidateBeforeCall(
            String asset,
            String symbol,
            String type,
            Long startTime,
            Long endTime,
            Long fromId,
            Long limit,
            Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {
                asset, symbol, type, startTime, endTime, fromId, limit, recvWindow
            };
            Method method =
                    this.getClass()
                            .getMethod(
                                    "queryCrossIsolatedMarginCapitalFlow",
                                    String.class,
                                    String.class,
                                    String.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class,
                                    Long.class);
            Set<ConstraintViolation<AccountApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return queryCrossIsolatedMarginCapitalFlowCall(
                        asset, symbol, type, startTime, endTime, fromId, limit, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Query Cross Isolated Margin Capital Flow (USER_DATA) Query Cross Isolated Margin Capital Flow
     * Weight: 100(IP)
     *
     * @param asset (optional)
     * @param symbol isolated margin pair (optional)
     * @param type Transfer Type: ROLL_IN, ROLL_OUT (optional)
     * @param startTime 只支持查询最近90天的数据 (optional)
     * @param endTime (optional)
     * @param fromId 如设置fromId, 将返回id &gt; fromId的数据。否则将返回最新数据 (optional)
     * @param limit Default Value: 500; Max Value: 1000 (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;QueryCrossIsolatedMarginCapitalFlowResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cross Isolated Margin Capital Flow </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/account/Query-Cross-Isolated-Margin-Capital-Flow">Query
     *     Cross Isolated Margin Capital Flow (USER_DATA) Documentation</a>
     */
    public ApiResponse<QueryCrossIsolatedMarginCapitalFlowResponse>
            queryCrossIsolatedMarginCapitalFlow(
                    String asset,
                    String symbol,
                    String type,
                    Long startTime,
                    Long endTime,
                    Long fromId,
                    Long limit,
                    Long recvWindow)
                    throws ApiException {
        okhttp3.Call localVarCall =
                queryCrossIsolatedMarginCapitalFlowValidateBeforeCall(
                        asset, symbol, type, startTime, endTime, fromId, limit, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<QueryCrossIsolatedMarginCapitalFlowResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for queryCrossMarginAccountDetails
     *
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cross Margin Account Details </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/account/Query-Cross-Margin-Account-Details">Query
     *     Cross Margin Account Details (USER_DATA) Documentation</a>
     */
    private okhttp3.Call queryCrossMarginAccountDetailsCall(Long recvWindow) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/account";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryCrossMarginAccountDetailsValidateBeforeCall(Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {recvWindow};
            Method method = this.getClass().getMethod("queryCrossMarginAccountDetails", Long.class);
            Set<ConstraintViolation<AccountApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return queryCrossMarginAccountDetailsCall(recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Query Cross Margin Account Details (USER_DATA) Query Cross Margin Account Details Weight:
     * 10(IP)
     *
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;QueryCrossMarginAccountDetailsResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cross Margin Account Details </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/account/Query-Cross-Margin-Account-Details">Query
     *     Cross Margin Account Details (USER_DATA) Documentation</a>
     */
    public ApiResponse<QueryCrossMarginAccountDetailsResponse> queryCrossMarginAccountDetails(
            Long recvWindow) throws ApiException {
        okhttp3.Call localVarCall = queryCrossMarginAccountDetailsValidateBeforeCall(recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<QueryCrossMarginAccountDetailsResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for queryCrossMarginFeeData
     *
     * @param vipLevel User&#39;s current specific margin data will be returned if vipLevel is
     *     omitted (optional)
     * @param coin (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cross Margin Fee Data </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/account/Query-Cross-Margin-Fee-Data">Query
     *     Cross Margin Fee Data (USER_DATA) Documentation</a>
     */
    private okhttp3.Call queryCrossMarginFeeDataCall(Long vipLevel, String coin, Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/crossMarginData";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (vipLevel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("vipLevel", vipLevel));
        }

        if (coin != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("coin", coin));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryCrossMarginFeeDataValidateBeforeCall(
            Long vipLevel, String coin, Long recvWindow) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {vipLevel, coin, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "queryCrossMarginFeeData",
                                    Long.class,
                                    String.class,
                                    Long.class);
            Set<ConstraintViolation<AccountApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return queryCrossMarginFeeDataCall(vipLevel, coin, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Query Cross Margin Fee Data (USER_DATA) Get cross margin fee data collection with any vip
     * level or user&#39;s current specific data as https://www.binance.com/en/margin-fee Weight: 1
     * when coin is specified;(IP)
     *
     * @param vipLevel User&#39;s current specific margin data will be returned if vipLevel is
     *     omitted (optional)
     * @param coin (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;QueryCrossMarginFeeDataResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cross Margin Fee Data </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/account/Query-Cross-Margin-Fee-Data">Query
     *     Cross Margin Fee Data (USER_DATA) Documentation</a>
     */
    public ApiResponse<QueryCrossMarginFeeDataResponse> queryCrossMarginFeeData(
            Long vipLevel, String coin, Long recvWindow) throws ApiException {
        okhttp3.Call localVarCall =
                queryCrossMarginFeeDataValidateBeforeCall(vipLevel, coin, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<QueryCrossMarginFeeDataResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for queryEnabledIsolatedMarginAccountLimit
     *
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Enabled Isolated Margin Account Limit </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/account/Query-Enabled-Isolated-Margin-Account-Limit">Query
     *     Enabled Isolated Margin Account Limit (USER_DATA) Documentation</a>
     */
    private okhttp3.Call queryEnabledIsolatedMarginAccountLimitCall(Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/isolated/accountLimit";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryEnabledIsolatedMarginAccountLimitValidateBeforeCall(Long recvWindow)
            throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {recvWindow};
            Method method =
                    this.getClass().getMethod("queryEnabledIsolatedMarginAccountLimit", Long.class);
            Set<ConstraintViolation<AccountApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return queryEnabledIsolatedMarginAccountLimitCall(recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Query Enabled Isolated Margin Account Limit (USER_DATA) Query enabled isolated margin account
     * limit. Weight: 1(IP)
     *
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;QueryEnabledIsolatedMarginAccountLimitResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Enabled Isolated Margin Account Limit </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/account/Query-Enabled-Isolated-Margin-Account-Limit">Query
     *     Enabled Isolated Margin Account Limit (USER_DATA) Documentation</a>
     */
    public ApiResponse<QueryEnabledIsolatedMarginAccountLimitResponse>
            queryEnabledIsolatedMarginAccountLimit(Long recvWindow) throws ApiException {
        okhttp3.Call localVarCall =
                queryEnabledIsolatedMarginAccountLimitValidateBeforeCall(recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<QueryEnabledIsolatedMarginAccountLimitResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for queryIsolatedMarginAccountInfo
     *
     * @param symbols Max 5 symbols can be sent; separated by \&quot;,\&quot;. e.g.
     *     \&quot;BTCUSDT,BNBUSDT,ADAUSDT\&quot; (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Isolated Margin Account Info </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/account/Query-Isolated-Margin-Account-Info">Query
     *     Isolated Margin Account Info (USER_DATA) Documentation</a>
     */
    private okhttp3.Call queryIsolatedMarginAccountInfoCall(String symbols, Long recvWindow)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/isolated/account";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (symbols != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbols", symbols));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryIsolatedMarginAccountInfoValidateBeforeCall(
            String symbols, Long recvWindow) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {symbols, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod("queryIsolatedMarginAccountInfo", String.class, Long.class);
            Set<ConstraintViolation<AccountApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return queryIsolatedMarginAccountInfoCall(symbols, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Query Isolated Margin Account Info (USER_DATA) Query Isolated Margin Account Info * If
     * \&quot;symbols\&quot; is not sent, all isolated assets will be returned. * If
     * \&quot;symbols\&quot; is sent, only the isolated assets of the sent symbols will be returned.
     * Weight: 10(IP)
     *
     * @param symbols Max 5 symbols can be sent; separated by \&quot;,\&quot;. e.g.
     *     \&quot;BTCUSDT,BNBUSDT,ADAUSDT\&quot; (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;QueryIsolatedMarginAccountInfoResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Isolated Margin Account Info </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/account/Query-Isolated-Margin-Account-Info">Query
     *     Isolated Margin Account Info (USER_DATA) Documentation</a>
     */
    public ApiResponse<QueryIsolatedMarginAccountInfoResponse> queryIsolatedMarginAccountInfo(
            String symbols, Long recvWindow) throws ApiException {
        okhttp3.Call localVarCall =
                queryIsolatedMarginAccountInfoValidateBeforeCall(symbols, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<QueryIsolatedMarginAccountInfoResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Build call for queryIsolatedMarginFeeData
     *
     * @param vipLevel User&#39;s current specific margin data will be returned if vipLevel is
     *     omitted (optional)
     * @param symbol isolated margin pair (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Isolated Margin Fee Data </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/account/Query-Isolated-Margin-Fee-Data">Query
     *     Isolated Margin Fee Data (USER_DATA) Documentation</a>
     */
    private okhttp3.Call queryIsolatedMarginFeeDataCall(
            Long vipLevel, String symbol, Long recvWindow) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/sapi/v1/margin/isolatedMarginData";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (vipLevel != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("vipLevel", vipLevel));
        }

        if (symbol != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("symbol", symbol));
        }

        if (recvWindow != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("recvWindow", recvWindow));
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/x-www-form-urlencoded"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }
        List<String> localVarAuthNames = new ArrayList<>();
        localVarAuthNames.addAll(
                Arrays.asList(
                        new String[] {
                            "binanceSignature",
                        }));
        if (HAS_TIME_UNIT) {
            localVarAuthNames.add("timeUnit");
        }
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames.toArray(new String[0]));
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryIsolatedMarginFeeDataValidateBeforeCall(
            Long vipLevel, String symbol, Long recvWindow) throws ApiException {
        try {
            Validator validator =
                    Validation.byDefaultProvider()
                            .configure()
                            .messageInterpolator(new ParameterMessageInterpolator())
                            .buildValidatorFactory()
                            .getValidator();
            ExecutableValidator executableValidator = validator.forExecutables();

            Object[] parameterValues = {vipLevel, symbol, recvWindow};
            Method method =
                    this.getClass()
                            .getMethod(
                                    "queryIsolatedMarginFeeData",
                                    Long.class,
                                    String.class,
                                    Long.class);
            Set<ConstraintViolation<AccountApi>> violations =
                    executableValidator.validateParameters(this, method, parameterValues);

            if (violations.size() == 0) {
                return queryIsolatedMarginFeeDataCall(vipLevel, symbol, recvWindow);
            } else {
                throw new ConstraintViolationException((Set) violations);
            }
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        } catch (SecurityException e) {
            e.printStackTrace();
            throw new ApiException(e.getMessage());
        }
    }

    /**
     * Query Isolated Margin Fee Data (USER_DATA) Get isolated margin fee data collection with any
     * vip level or user&#39;s current specific data as https://www.binance.com/en/margin-fee
     * Weight: 1 when a single is specified;(IP)
     *
     * @param vipLevel User&#39;s current specific margin data will be returned if vipLevel is
     *     omitted (optional)
     * @param symbol isolated margin pair (optional)
     * @param recvWindow No more than 60000 (optional)
     * @return ApiResponse&lt;QueryIsolatedMarginFeeDataResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Isolated Margin Fee Data </td><td>  -  </td></tr>
     * </table>
     *
     * @see <a
     *     href="https://developers.binance.com/docs/margin_trading/account/Query-Isolated-Margin-Fee-Data">Query
     *     Isolated Margin Fee Data (USER_DATA) Documentation</a>
     */
    public ApiResponse<QueryIsolatedMarginFeeDataResponse> queryIsolatedMarginFeeData(
            Long vipLevel, String symbol, Long recvWindow) throws ApiException {
        okhttp3.Call localVarCall =
                queryIsolatedMarginFeeDataValidateBeforeCall(vipLevel, symbol, recvWindow);
        java.lang.reflect.Type localVarReturnType =
                new TypeToken<QueryIsolatedMarginFeeDataResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }
}
